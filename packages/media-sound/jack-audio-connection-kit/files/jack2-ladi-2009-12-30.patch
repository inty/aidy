diff --git a/ChangeLog b/ChangeLog
index 8dfeca7..66aa7ae 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -6,7 +6,6 @@ Dmitry Baikov
 Steven Chamberlain
 Thom Johansen
 Thibault LeMeur
-Pieter Palmers
 Tom Szilagyi
 Andrzej Szombierski 
 Kjetil S.Matheussen
@@ -19,12 +18,71 @@ Romain Moret
 Florian Faber
 Michael Voigt
 Torben Hohn  
-Paul Davis
+Paul Davis
+Peter L Jones
+Devin Anderson
+Josh Green
+Mario Lang
 
 ---------------------------
   Jackdmp changes log
 ---------------------------
 
+2009-12-15 Stephane Letz  <letz@grame.fr>
+
+	* Shared memory manager was calling abort in case of fatal error, now return an error in caller.
+
+2009-12-13 Stephane Letz  <letz@grame.fr>
+
+	* Mario Lang alsa_io time calculation overflow patch.
+
+2009-12-10 Stephane Letz  <letz@grame.fr>
+
+	* Use a QUIT notification to properly quit the server channel, the server channel thread can then be 'stopped' instead of 'canceled'.
+
+2009-12-09 Stephane Letz  <letz@grame.fr>
+
+	* When threads are cancelled, the exception has to be rethrown. 
+
+2009-12-08 Stephane Letz  <letz@grame.fr>
+
+	* Josh Green ALSA driver capture only patch.  
+
+2009-12-03 Stephane Letz  <letz@grame.fr>
+
+	* Fix JackCoreMidiDriver::ReadProcAux when ring buffer is full (thanks Devin Anderson).  
+
+2009-12-02 Stephane Letz  <letz@grame.fr>
+
+	* Special code in JackCoreAudio driver to handle completely buggy Digidesign CoreAudio user-land driver. 
+	* Ensure that client-side message buffer thread calls thread_init callback if/when it is set by the client (backport of JACK1 rev 3838).
+	* Check dynamic port-max value.
+
+2009-12-01 Stephane Letz  <letz@grame.fr>
+
+	* Fix port_rename callback : now both old name and new name are given as parameters.
+
+2009-11-30 Stephane Letz  <letz@grame.fr>
+
+	* Devin Anderson patch for Jack FFADO driver issues with lost MIDI bytes between periods (and more). 
+
+2009-11-29 Stephane Letz  <letz@grame.fr>
+
+	* More robust sample rate change handling code in JackCoreAudioDriver.
+
+2009-11-24 Stephane Letz  <letz@grame.fr>
+
+	* Dynamic choice of maximum port number.
+
+2009-11-23 Stephane Letz  <letz@grame.fr>
+
+	* Peter L Jones patch for NetJack1 compilation on Windows.
+
+2009-11-20 Stephane Letz  <letz@grame.fr>
+
+	* Version 1.9.5 started.
+	* Client debugging code improved.
+
 2009-11-18 Stephane Letz  <letz@grame.fr>
 
 	* Sync JackCoreAudioAdapter code with JackCoreAudioDriver.
diff --git a/common/JackAPI.cpp b/common/JackAPI.cpp
index 97e5883..0640883 100644
--- a/common/JackAPI.cpp
+++ b/common/JackAPI.cpp
@@ -251,7 +251,7 @@ extern "C"
 
 static inline bool CheckPort(jack_port_id_t port_index)
 {
-    return (port_index > 0 && port_index < PORT_NUM);
+    return (port_index > 0 && port_index < PORT_NUM_MAX);
 }
 
 static inline bool CheckBufferSize(jack_nframes_t buffer_size)
@@ -290,6 +290,9 @@ EXPORT void jack_set_info_function (print_function func)
 
 EXPORT jack_client_t* jack_client_new(const char* client_name)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_new");
+#endif
     try {
         assert(JackGlobals::fOpenMutex);
         JackGlobals::fOpenMutex->Lock();
@@ -312,7 +315,7 @@ EXPORT jack_client_t* jack_client_new(const char* client_name)
 EXPORT void* jack_port_get_buffer(jack_port_t* port, jack_nframes_t frames)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_get_buffer");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -332,7 +335,7 @@ EXPORT void* jack_port_get_buffer(jack_port_t* port, jack_nframes_t frames)
 EXPORT const char* jack_port_name(const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_name");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -352,7 +355,7 @@ EXPORT const char* jack_port_name(const jack_port_t* port)
 EXPORT const char* jack_port_short_name(const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_short_name");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -372,7 +375,7 @@ EXPORT const char* jack_port_short_name(const jack_port_t* port)
 EXPORT int jack_port_flags(const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_flags");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -392,7 +395,7 @@ EXPORT int jack_port_flags(const jack_port_t* port)
 EXPORT const char* jack_port_type(const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_type");
 #endif
  #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -412,7 +415,7 @@ EXPORT const char* jack_port_type(const jack_port_t* port)
 EXPORT jack_port_type_id_t jack_port_type_id(const jack_port_t *port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_type_id");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -432,7 +435,7 @@ EXPORT jack_port_type_id_t jack_port_type_id(const jack_port_t *port)
 EXPORT int jack_port_connected(const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_connected");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -453,7 +456,7 @@ EXPORT int jack_port_connected(const jack_port_t* port)
 EXPORT int jack_port_connected_to(const jack_port_t* port, const char* port_name)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_connected_to");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -483,7 +486,7 @@ EXPORT int jack_port_connected_to(const jack_port_t* port, const char* port_name
 EXPORT int jack_port_tie(jack_port_t* src, jack_port_t* dst)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_tie");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t src_aux = (uint64_t)src;
@@ -517,7 +520,7 @@ EXPORT int jack_port_tie(jack_port_t* src, jack_port_t* dst)
 EXPORT int jack_port_untie(jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_untie");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -537,7 +540,7 @@ EXPORT int jack_port_untie(jack_port_t* port)
 EXPORT jack_nframes_t jack_port_get_latency(jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_get_latency");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -558,7 +561,7 @@ EXPORT jack_nframes_t jack_port_get_latency(jack_port_t* port)
 EXPORT void jack_port_set_latency(jack_port_t* port, jack_nframes_t frames)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_set_latency");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -578,7 +581,7 @@ EXPORT void jack_port_set_latency(jack_port_t* port, jack_nframes_t frames)
 EXPORT int jack_recompute_total_latency(jack_client_t* ext_client, jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_recompute_total_latency");
 #endif
 
     JackClient* client = (JackClient*)ext_client;
@@ -604,7 +607,7 @@ EXPORT int jack_recompute_total_latency(jack_client_t* ext_client, jack_port_t*
 EXPORT int jack_recompute_total_latencies(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_recompute_total_latencies");
 #endif
 
     JackClient* client = (JackClient*)ext_client;
@@ -625,7 +628,7 @@ This is unsafe if case of concurrent access, and should be "serialized" doing a
 EXPORT int jack_port_set_name(jack_port_t* port, const char* name)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_set_name");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -655,7 +658,7 @@ EXPORT int jack_port_set_name(jack_port_t* port, const char* name)
 EXPORT int jack_port_set_alias(jack_port_t* port, const char* name)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_set_alias");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -678,7 +681,7 @@ EXPORT int jack_port_set_alias(jack_port_t* port, const char* name)
 EXPORT int jack_port_unset_alias(jack_port_t* port, const char* name)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_unset_alias");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -701,7 +704,7 @@ EXPORT int jack_port_unset_alias(jack_port_t* port, const char* name)
 EXPORT int jack_port_get_aliases(const jack_port_t* port, char* const aliases[2])
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_get_aliases");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -721,7 +724,7 @@ EXPORT int jack_port_get_aliases(const jack_port_t* port, char* const aliases[2]
 EXPORT int jack_port_request_monitor(jack_port_t* port, int onoff)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_request_monitor");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -741,7 +744,7 @@ EXPORT int jack_port_request_monitor(jack_port_t* port, int onoff)
 EXPORT int jack_port_request_monitor_by_name(jack_client_t* ext_client, const char* port_name, int onoff)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_request_monitor_by_name");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -764,7 +767,7 @@ EXPORT int jack_port_request_monitor_by_name(jack_client_t* ext_client, const ch
 EXPORT int jack_port_ensure_monitor(jack_port_t* port, int onoff)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_ensure_monitor");
 #endif
  #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -784,7 +787,7 @@ EXPORT int jack_port_ensure_monitor(jack_port_t* port, int onoff)
 EXPORT int jack_port_monitoring_input(jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_monitoring_input");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -804,7 +807,7 @@ EXPORT int jack_port_monitoring_input(jack_port_t* port)
 EXPORT int jack_is_realtime(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_is_realtime");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -819,7 +822,7 @@ EXPORT int jack_is_realtime(jack_client_t* ext_client)
 EXPORT void jack_on_shutdown(jack_client_t* ext_client, JackShutdownCallback callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_on_shutdown");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -832,7 +835,7 @@ EXPORT void jack_on_shutdown(jack_client_t* ext_client, JackShutdownCallback cal
 EXPORT void jack_on_info_shutdown(jack_client_t* ext_client, JackInfoShutdownCallback callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_on_info_shutdown");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -845,7 +848,7 @@ EXPORT void jack_on_info_shutdown(jack_client_t* ext_client, JackInfoShutdownCal
 EXPORT int jack_set_process_callback(jack_client_t* ext_client, JackProcessCallback callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_process_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -859,7 +862,7 @@ EXPORT int jack_set_process_callback(jack_client_t* ext_client, JackProcessCallb
 EXPORT jack_nframes_t jack_thread_wait(jack_client_t* ext_client, int status)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_thread_wait");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -874,7 +877,7 @@ EXPORT jack_nframes_t jack_thread_wait(jack_client_t* ext_client, int status)
 EXPORT jack_nframes_t jack_cycle_wait(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_cycle_wait");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -888,7 +891,7 @@ EXPORT jack_nframes_t jack_cycle_wait(jack_client_t* ext_client)
 EXPORT void jack_cycle_signal(jack_client_t* ext_client, int status)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_cycle_signal");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -901,7 +904,7 @@ EXPORT void jack_cycle_signal(jack_client_t* ext_client, int status)
 EXPORT int jack_set_process_thread(jack_client_t* ext_client, JackThreadCallback fun, void *arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_process_thread");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -915,7 +918,7 @@ EXPORT int jack_set_process_thread(jack_client_t* ext_client, JackThreadCallback
 EXPORT int jack_set_freewheel_callback(jack_client_t* ext_client, JackFreewheelCallback freewheel_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_freewheel_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -929,7 +932,7 @@ EXPORT int jack_set_freewheel_callback(jack_client_t* ext_client, JackFreewheelC
 EXPORT int jack_set_freewheel(jack_client_t* ext_client, int onoff)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_freewheel");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -943,7 +946,7 @@ EXPORT int jack_set_freewheel(jack_client_t* ext_client, int onoff)
 EXPORT int jack_set_buffer_size(jack_client_t* ext_client, jack_nframes_t buffer_size)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_buffer_size");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -959,7 +962,7 @@ EXPORT int jack_set_buffer_size(jack_client_t* ext_client, jack_nframes_t buffer
 EXPORT int jack_set_buffer_size_callback(jack_client_t* ext_client, JackBufferSizeCallback bufsize_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_buffer_size_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -973,7 +976,7 @@ EXPORT int jack_set_buffer_size_callback(jack_client_t* ext_client, JackBufferSi
 EXPORT int jack_set_sample_rate_callback(jack_client_t* ext_client, JackSampleRateCallback srate_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_sample_rate_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -987,7 +990,7 @@ EXPORT int jack_set_sample_rate_callback(jack_client_t* ext_client, JackSampleRa
 EXPORT int jack_set_client_registration_callback(jack_client_t* ext_client, JackClientRegistrationCallback registration_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_client_registration_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1001,7 +1004,7 @@ EXPORT int jack_set_client_registration_callback(jack_client_t* ext_client, Jack
 EXPORT int jack_set_port_registration_callback(jack_client_t* ext_client, JackPortRegistrationCallback registration_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_port_registration_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1015,7 +1018,7 @@ EXPORT int jack_set_port_registration_callback(jack_client_t* ext_client, JackPo
 EXPORT int jack_set_port_connect_callback(jack_client_t* ext_client, JackPortConnectCallback portconnect_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_port_connect_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1029,7 +1032,7 @@ EXPORT int jack_set_port_connect_callback(jack_client_t* ext_client, JackPortCon
 EXPORT int jack_set_port_rename_callback(jack_client_t* ext_client, JackPortRenameCallback rename_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_port_rename_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1043,7 +1046,7 @@ EXPORT int jack_set_port_rename_callback(jack_client_t* ext_client, JackPortRena
 EXPORT int jack_set_graph_order_callback(jack_client_t* ext_client, JackGraphOrderCallback graph_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_graph_order_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     jack_log("jack_set_graph_order_callback ext_client %x client %x ", ext_client, client);
@@ -1058,7 +1061,7 @@ EXPORT int jack_set_graph_order_callback(jack_client_t* ext_client, JackGraphOrd
 EXPORT int jack_set_xrun_callback(jack_client_t* ext_client, JackXRunCallback xrun_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_xrun_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1072,7 +1075,7 @@ EXPORT int jack_set_xrun_callback(jack_client_t* ext_client, JackXRunCallback xr
 EXPORT int jack_set_thread_init_callback(jack_client_t* ext_client, JackThreadInitCallback init_callback, void *arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_thread_init_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     jack_log("jack_set_thread_init_callback ext_client %x client %x ", ext_client, client);
@@ -1087,7 +1090,7 @@ EXPORT int jack_set_thread_init_callback(jack_client_t* ext_client, JackThreadIn
 EXPORT int jack_activate(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_activate");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1101,7 +1104,7 @@ EXPORT int jack_activate(jack_client_t* ext_client)
 EXPORT int jack_deactivate(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_deactivate");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1115,7 +1118,7 @@ EXPORT int jack_deactivate(jack_client_t* ext_client)
 EXPORT jack_port_t* jack_port_register(jack_client_t* ext_client, const char* port_name, const char* port_type, unsigned long flags, unsigned long buffer_size)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_register");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1136,7 +1139,7 @@ EXPORT jack_port_t* jack_port_register(jack_client_t* ext_client, const char* po
 EXPORT int jack_port_unregister(jack_client_t* ext_client, jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_unregister");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1159,7 +1162,7 @@ EXPORT int jack_port_unregister(jack_client_t* ext_client, jack_port_t* port)
 EXPORT int jack_port_is_mine(const jack_client_t* ext_client, const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_is_mine");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1182,7 +1185,7 @@ EXPORT int jack_port_is_mine(const jack_client_t* ext_client, const jack_port_t*
 EXPORT const char** jack_port_get_connections(const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_get_connections");
 #endif
 #if defined(__x86_64__) || defined(__ppc64__)
     uint64_t port_aux = (uint64_t)port;
@@ -1204,7 +1207,7 @@ EXPORT const char** jack_port_get_connections(const jack_port_t* port)
 EXPORT const char** jack_port_get_all_connections(const jack_client_t* ext_client, const jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_get_all_connections");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1231,7 +1234,7 @@ EXPORT const char** jack_port_get_all_connections(const jack_client_t* ext_clien
 EXPORT jack_nframes_t jack_port_get_total_latency(jack_client_t* ext_client, jack_port_t* port)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_get_total_latency");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1263,7 +1266,7 @@ EXPORT jack_nframes_t jack_port_get_total_latency(jack_client_t* ext_client, jac
 EXPORT int jack_connect(jack_client_t* ext_client, const char* src, const char* dst)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_connect");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1280,7 +1283,7 @@ EXPORT int jack_connect(jack_client_t* ext_client, const char* src, const char*
 EXPORT int jack_disconnect(jack_client_t* ext_client, const char* src, const char* dst)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_disconnect");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1297,7 +1300,7 @@ EXPORT int jack_disconnect(jack_client_t* ext_client, const char* src, const cha
 EXPORT int jack_port_disconnect(jack_client_t* ext_client, jack_port_t* src)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_disconnect");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1320,7 +1323,7 @@ EXPORT int jack_port_disconnect(jack_client_t* ext_client, jack_port_t* src)
 EXPORT jack_nframes_t jack_get_sample_rate(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_sample_rate");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1335,7 +1338,7 @@ EXPORT jack_nframes_t jack_get_sample_rate(jack_client_t* ext_client)
 EXPORT jack_nframes_t jack_get_buffer_size(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_buffer_size");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1350,7 +1353,7 @@ EXPORT jack_nframes_t jack_get_buffer_size(jack_client_t* ext_client)
 EXPORT const char** jack_get_ports(jack_client_t* ext_client, const char* port_name_pattern, const char* type_name_pattern, unsigned long flags)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_ports");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1364,7 +1367,7 @@ EXPORT const char** jack_get_ports(jack_client_t* ext_client, const char* port_n
 EXPORT jack_port_t* jack_port_by_name(jack_client_t* ext_client, const char* portname)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_by_name");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1391,7 +1394,7 @@ EXPORT jack_port_t* jack_port_by_name(jack_client_t* ext_client, const char* por
 EXPORT jack_port_t* jack_port_by_id(jack_client_t* ext_client, jack_port_id_t id)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_port_by_id");
 #endif
     /* jack_port_t* type is actually the port index */
 #if defined(__x86_64__) || defined(__ppc64__)
@@ -1404,7 +1407,7 @@ EXPORT jack_port_t* jack_port_by_id(jack_client_t* ext_client, jack_port_id_t id
 EXPORT int jack_engine_takeover_timebase(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_engine_takeover_timebase");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1419,7 +1422,7 @@ EXPORT int jack_engine_takeover_timebase(jack_client_t* ext_client)
 EXPORT jack_nframes_t jack_frames_since_cycle_start(const jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_frames_since_cycle_start");
 #endif
     JackTimer timer;
     JackEngineControl* control = GetEngineControl();
@@ -1433,13 +1436,16 @@ EXPORT jack_nframes_t jack_frames_since_cycle_start(const jack_client_t* ext_cli
 
 EXPORT jack_time_t jack_get_time()
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_get_time");
+#endif
     return GetMicroSeconds();
 }
 
 EXPORT jack_time_t jack_frames_to_time(const jack_client_t* ext_client, jack_nframes_t frames)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_frames_to_time");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1460,7 +1466,7 @@ EXPORT jack_time_t jack_frames_to_time(const jack_client_t* ext_client, jack_nfr
 EXPORT jack_nframes_t jack_time_to_frames(const jack_client_t* ext_client, jack_time_t time)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_time_to_frames");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1480,13 +1486,16 @@ EXPORT jack_nframes_t jack_time_to_frames(const jack_client_t* ext_client, jack_
 
 EXPORT jack_nframes_t jack_frame_time(const jack_client_t* ext_client)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_frame_time");
+#endif
     return jack_time_to_frames(ext_client, GetMicroSeconds());
 }
 
 EXPORT jack_nframes_t jack_last_frame_time(const jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_last_frame_time");
 #endif
     JackEngineControl* control = GetEngineControl();
     return (control) ? control->fFrameTimer.ReadCurrentState()->CurFrame() : 0;
@@ -1495,7 +1504,7 @@ EXPORT jack_nframes_t jack_last_frame_time(const jack_client_t* ext_client)
 EXPORT float jack_cpu_load(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_cpu_load");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1510,7 +1519,7 @@ EXPORT float jack_cpu_load(jack_client_t* ext_client)
 EXPORT pthread_t jack_client_thread_id(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_client_thread_id");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1524,7 +1533,7 @@ EXPORT pthread_t jack_client_thread_id(jack_client_t* ext_client)
 EXPORT char* jack_get_client_name(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_client_name");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1554,7 +1563,7 @@ EXPORT int jack_port_type_size(void)
 EXPORT int jack_release_timebase(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_release_timebase");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1568,7 +1577,7 @@ EXPORT int jack_release_timebase(jack_client_t* ext_client)
 EXPORT int jack_set_sync_callback(jack_client_t* ext_client, JackSyncCallback sync_callback, void *arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_sync_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1582,7 +1591,7 @@ EXPORT int jack_set_sync_callback(jack_client_t* ext_client, JackSyncCallback sy
 EXPORT int jack_set_sync_timeout(jack_client_t* ext_client, jack_time_t timeout)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_sync_timeout");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1596,7 +1605,7 @@ EXPORT int jack_set_sync_timeout(jack_client_t* ext_client, jack_time_t timeout)
 EXPORT int jack_set_timebase_callback(jack_client_t* ext_client, int conditional, JackTimebaseCallback timebase_callback, void* arg)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_set_timebase_callback");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1610,7 +1619,7 @@ EXPORT int jack_set_timebase_callback(jack_client_t* ext_client, int conditional
 EXPORT int jack_transport_locate(jack_client_t* ext_client, jack_nframes_t frame)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_transport_locate");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1625,7 +1634,7 @@ EXPORT int jack_transport_locate(jack_client_t* ext_client, jack_nframes_t frame
 EXPORT jack_transport_state_t jack_transport_query(const jack_client_t* ext_client, jack_position_t* pos)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_transport_query");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1639,7 +1648,7 @@ EXPORT jack_transport_state_t jack_transport_query(const jack_client_t* ext_clie
 EXPORT jack_nframes_t jack_get_current_transport_frame(const jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_current_transport_frame");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1653,7 +1662,7 @@ EXPORT jack_nframes_t jack_get_current_transport_frame(const jack_client_t* ext_
 EXPORT int jack_transport_reposition(jack_client_t* ext_client, jack_position_t* pos)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_transport_reposition");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1668,7 +1677,7 @@ EXPORT int jack_transport_reposition(jack_client_t* ext_client, jack_position_t*
 EXPORT void jack_transport_start(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_transport_start");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1681,7 +1690,7 @@ EXPORT void jack_transport_start(jack_client_t* ext_client)
 EXPORT void jack_transport_stop(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_transport_stop");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1694,6 +1703,9 @@ EXPORT void jack_transport_stop(jack_client_t* ext_client)
 // deprecated
 EXPORT void jack_get_transport_info(jack_client_t* ext_client, jack_transport_info_t* tinfo)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_get_transport_info");
+#endif
     jack_error("jack_get_transport_info: deprecated");
     if (tinfo)
         memset(tinfo, 0, sizeof(jack_transport_info_t));
@@ -1701,6 +1713,9 @@ EXPORT void jack_get_transport_info(jack_client_t* ext_client, jack_transport_in
 
 EXPORT void jack_set_transport_info(jack_client_t* ext_client, jack_transport_info_t* tinfo)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_set_transport_info");
+#endif    
     jack_error("jack_set_transport_info: deprecated");
     if (tinfo)
         memset(tinfo, 0, sizeof(jack_transport_info_t));
@@ -1710,7 +1725,7 @@ EXPORT void jack_set_transport_info(jack_client_t* ext_client, jack_transport_in
 EXPORT float jack_get_max_delayed_usecs(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_max_delayed_usecs");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1725,7 +1740,7 @@ EXPORT float jack_get_max_delayed_usecs(jack_client_t* ext_client)
 EXPORT float jack_get_xrun_delayed_usecs(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_xrun_delayed_usecs");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1740,7 +1755,7 @@ EXPORT float jack_get_xrun_delayed_usecs(jack_client_t* ext_client)
 EXPORT void jack_reset_max_delayed_usecs(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_reset_max_delayed_usecs");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1755,7 +1770,7 @@ EXPORT void jack_reset_max_delayed_usecs(jack_client_t* ext_client)
 EXPORT int jack_client_real_time_priority(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_client_real_time_priority");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1770,7 +1785,7 @@ EXPORT int jack_client_real_time_priority(jack_client_t* ext_client)
 EXPORT int jack_client_max_real_time_priority(jack_client_t* ext_client)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_client_max_real_time_priority");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1795,6 +1810,9 @@ EXPORT int jack_client_create_thread(jack_client_t* client,
                                      thread_routine routine,
                                      void *arg)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_create_thread");
+#endif    
     return JackThread::StartImp(thread, priority, realtime, routine, arg);
 }
 
@@ -1805,11 +1823,17 @@ EXPORT int jack_drop_real_time_scheduling(pthread_t thread)
 
 EXPORT int jack_client_stop_thread(jack_client_t* client, pthread_t thread)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_stop_thread");
+#endif        
     return JackThread::StopImp(thread);
 }
 
 EXPORT int jack_client_kill_thread(jack_client_t* client, pthread_t thread)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_kill_thread");
+#endif            
     return JackThread::KillImp(thread);
 }
 
@@ -1837,7 +1861,7 @@ EXPORT void jack_internal_client_close (const char *client_name)
 EXPORT char* jack_get_internal_client_name(jack_client_t* ext_client, jack_intclient_t intclient)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_get_internal_client_name");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1854,7 +1878,7 @@ EXPORT char* jack_get_internal_client_name(jack_client_t* ext_client, jack_intcl
 EXPORT jack_intclient_t jack_internal_client_handle(jack_client_t* ext_client, const char* client_name, jack_status_t* status)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_internal_client_handle");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1872,7 +1896,7 @@ EXPORT jack_intclient_t jack_internal_client_handle(jack_client_t* ext_client, c
 EXPORT jack_intclient_t jack_internal_client_load_aux(jack_client_t* ext_client, const char* client_name, jack_options_t options, jack_status_t* status, va_list ap)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_internal_client_load_aux");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
@@ -1911,7 +1935,7 @@ EXPORT jack_intclient_t jack_internal_client_load(jack_client_t *client, const c
 EXPORT jack_status_t jack_internal_client_unload(jack_client_t* ext_client, jack_intclient_t intclient)
 {
 #ifdef __CLIENTDEBUG__
-    JackLibGlobals::CheckContext();
+    JackGlobals::CheckContext("jack_internal_client_load");
 #endif
     JackClient* client = (JackClient*)ext_client;
     if (client == NULL) {
diff --git a/common/JackAudioDriver.cpp b/common/JackAudioDriver.cpp
index 3bcae9e..dc53077 100644
--- a/common/JackAudioDriver.cpp
+++ b/common/JackAudioDriver.cpp
@@ -101,7 +101,6 @@ int JackAudioDriver::Attach()
     jack_port_id_t port_index;
     char name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
     char alias[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
-    unsigned long port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
     int i;
 
     jack_log("JackAudioDriver::Attach fBufferSize = %ld fSampleRate = %ld", fEngineControl->fBufferSize, fEngineControl->fSampleRate);
@@ -109,7 +108,7 @@ int JackAudioDriver::Attach()
     for (i = 0; i < fCaptureChannels; i++) {
         snprintf(alias, sizeof(alias) - 1, "%s:%s:out%d", fAliasName, fCaptureDriverName, i + 1);
         snprintf(name, sizeof(name) - 1, "%s:capture_%d", fClientControl.fName, i + 1);
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, CaptureDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
@@ -120,12 +119,10 @@ int JackAudioDriver::Attach()
         jack_log("JackAudioDriver::Attach fCapturePortList[i] port_index = %ld", port_index);
     }
 
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     for (i = 0; i < fPlaybackChannels; i++) {
         snprintf(alias, sizeof(alias) - 1, "%s:%s:in%d", fAliasName, fPlaybackDriverName, i + 1);
         snprintf(name, sizeof(name) - 1, "%s:playback_%d", fClientControl.fName, i + 1);
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, PlaybackDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
diff --git a/common/JackClient.cpp b/common/JackClient.cpp
index e646926..d4359f8 100644
--- a/common/JackClient.cpp
+++ b/common/JackClient.cpp
@@ -254,7 +254,7 @@ int JackClient::ClientNotify(int refnum, const char* name, int notify, int sync,
              case kPortRenameCallback:
                 jack_log("JackClient::kPortRenameCallback port = %ld");
                 if (fPortRename) {
-                    fPortRename(value1, GetGraphManager()->GetPort(value1)->GetName(), fPortRenameArg);
+                    fPortRename(value1, message, GetGraphManager()->GetPort(value1)->GetName(), fPortRenameArg);
                 }
                 break;
 
@@ -848,6 +848,8 @@ int JackClient::SetInitCallback(JackThreadInitCallback callback, void *arg)
     } else {
         fInitArg = arg;
         fInit = callback;
+        /* make sure that the message buffer thread is initialized too */
+        JackMessageBuffer::fInstance->SetInitCallback(callback, arg);
         return 0;
     }
 }
diff --git a/common/JackConnectionManager.cpp b/common/JackConnectionManager.cpp
index 043b0c8..f6a74dc 100644
--- a/common/JackConnectionManager.cpp
+++ b/common/JackConnectionManager.cpp
@@ -33,7 +33,7 @@ JackConnectionManager::JackConnectionManager()
     int i;
     jack_log("JackConnectionManager::InitConnections size = %ld ", sizeof(JackConnectionManager));
 
-    for (i = 0; i < PORT_NUM; i++) {
+    for (i = 0; i < PORT_NUM_MAX; i++) {
         fConnection[i].Init();
     }
 
diff --git a/common/JackConnectionManager.h b/common/JackConnectionManager.h
index 4754303..5d5b8c6 100644
--- a/common/JackConnectionManager.h
+++ b/common/JackConnectionManager.h
@@ -353,11 +353,21 @@ struct JackClientTiming
     jack_time_t fFinishedAt;
     jack_client_state_t fStatus;
 
-    JackClientTiming(): fSignaledAt(0), fAwakeAt(0), fFinishedAt(0), fStatus(NotTriggered)
-    {}
+    JackClientTiming()
+    {
+        Init();
+    }
     ~JackClientTiming()
     {}
     
+    void Init()
+    {
+        fSignaledAt = 0;
+        fAwakeAt = 0;
+        fFinishedAt = 0;
+        fStatus = NotTriggered;
+    }
+    
 } POST_PACKED_STRUCTURE;
 
 /*!
@@ -379,7 +389,7 @@ class SERVER_EXPORT JackConnectionManager
 
     private:
 
-        JackFixedArray<CONNECTION_NUM_FOR_PORT> fConnection[PORT_NUM];  /*! Connection matrix: list of connected ports for a given port: needed to compute Mix buffer */
+        JackFixedArray<CONNECTION_NUM_FOR_PORT> fConnection[PORT_NUM_MAX];  /*! Connection matrix: list of connected ports for a given port: needed to compute Mix buffer */
         JackFixedArray1<PORT_NUM_FOR_CLIENT> fInputPort[CLIENT_NUM];	/*! Table of input port per refnum : to find a refnum for a given port */
         JackFixedArray<PORT_NUM_FOR_CLIENT> fOutputPort[CLIENT_NUM];	/*! Table of output port per refnum : to find a refnum for a given port */
         JackFixedMatrix<CLIENT_NUM> fConnectionRef;						/*! Table of port connections by (refnum , refnum) */
diff --git a/common/JackConstants.h b/common/JackConstants.h
index aa6e0ce..fad79c6 100644
--- a/common/JackConstants.h
+++ b/common/JackConstants.h
@@ -24,7 +24,7 @@
 #include "config.h"
 #endif
 
-#define VERSION "1.9.4"
+#define VERSION "1.9.5"
 
 #define BUFFER_SIZE_MAX 8192
 
@@ -38,6 +38,8 @@
 #define PORT_NUM 2048
 #endif
 
+#define PORT_NUM_MAX 4096           // The "max" value for ports used in connection manager, although port number in graph manager is dynamic
+
 #define DRIVER_PORT_NUM 256
 
 #ifndef PORT_NUM_FOR_CLIENT
@@ -98,4 +100,6 @@
 #define EMPTY   0xFFFD
 #define FREE	0xFFFC
 
+#define JACK_DEFAULT_SELF_CONNECT_MODE JackSelfConnectIgnoreAll
+
 #endif
diff --git a/common/JackControlAPI.cpp b/common/JackControlAPI.cpp
index 37eeb88..8358d3a 100644
--- a/common/JackControlAPI.cpp
+++ b/common/JackControlAPI.cpp
@@ -47,6 +47,13 @@
 
 using namespace Jack;
 
+#define SELF_CONNECT_MODE_ALLOW_CHAR                  ' '
+#define SELF_CONNECT_MODE_FAIL_EXTERNAL_ONLY_CHAR     'E'
+#define SELF_CONNECT_MODE_IGNORE_EXTERNAL_ONLY_CHAR   'e'
+#define SELF_CONNECT_MODE_FAIL_ALL_CHAR               'A'
+#define SELF_CONNECT_MODE_IGNORE_ALL_CHAR             'a'
+#define SELF_CONNECT_MODES_COUNT              5
+
 struct jackctl_server
 {
     JSList * drivers;
@@ -82,7 +89,11 @@ struct jackctl_server
     /* uint32_t, clock source type */
     union jackctl_parameter_value clock_source;
     union jackctl_parameter_value default_clock_source;
-
+   
+    /* uint32_t, max port number */
+    union jackctl_parameter_value port_max;
+    union jackctl_parameter_value default_port_max;
+    
     /* bool */
     union jackctl_parameter_value replace_registry;
     union jackctl_parameter_value default_replace_registry;
@@ -90,6 +101,12 @@ struct jackctl_server
     /* bool, synchronous or asynchronous engine mode */
     union jackctl_parameter_value sync;
     union jackctl_parameter_value default_sync;
+
+    /* char enum, self connect mode mode */
+    union jackctl_parameter_value self_connect_mode;
+    union jackctl_parameter_value default_self_connect_mode;
+    jack_driver_param_value_enum_t self_connect_mode_possible_values[SELF_CONNECT_MODES_COUNT];
+    jack_driver_param_constraint_desc_t self_connect_mode_constraint;
 };
 
 struct jackctl_driver
@@ -741,6 +758,20 @@ EXPORT jackctl_server_t * jackctl_server_create(
     {
         goto fail_free_parameters;
     }
+    
+    value.ui = PORT_NUM;
+    if (jackctl_add_parameter(
+          &server_ptr->parameters,
+          "port-max",
+          "Maximum number of ports.",
+          "",
+          JackParamUInt,
+          &server_ptr->port_max,
+          &server_ptr->default_port_max,
+          value) == NULL)
+    {
+        goto fail_free_parameters;
+    }
 
     value.b = false;
     if (jackctl_add_parameter(
@@ -770,6 +801,40 @@ EXPORT jackctl_server_t * jackctl_server_create(
         goto fail_free_parameters;
     }
 
+    server_ptr->self_connect_mode_constraint.flags = JACK_CONSTRAINT_FLAG_STRICT | JACK_CONSTRAINT_FLAG_FAKE_VALUE;
+    server_ptr->self_connect_mode_constraint.constraint.enumeration.count = SELF_CONNECT_MODES_COUNT;
+    server_ptr->self_connect_mode_constraint.constraint.enumeration.possible_values_array = server_ptr->self_connect_mode_possible_values;
+
+    server_ptr->self_connect_mode_possible_values[0].value.c = SELF_CONNECT_MODE_ALLOW_CHAR;
+    strcpy(server_ptr->self_connect_mode_possible_values[0].short_desc, "Don't restrict self connect requests");
+
+    server_ptr->self_connect_mode_possible_values[1].value.c = SELF_CONNECT_MODE_FAIL_EXTERNAL_ONLY_CHAR ;
+    strcpy(server_ptr->self_connect_mode_possible_values[1].short_desc, "Fail self connect requests to external ports only");
+
+    server_ptr->self_connect_mode_possible_values[2].value.c = SELF_CONNECT_MODE_IGNORE_EXTERNAL_ONLY_CHAR;
+    strcpy(server_ptr->self_connect_mode_possible_values[2].short_desc, "Ignore self connect requests to external ports only");
+
+    server_ptr->self_connect_mode_possible_values[3].value.c = SELF_CONNECT_MODE_FAIL_ALL_CHAR;
+    strcpy(server_ptr->self_connect_mode_possible_values[3].short_desc, "Fail all self connect requests");
+
+    server_ptr->self_connect_mode_possible_values[4].value.c = SELF_CONNECT_MODE_IGNORE_ALL_CHAR;
+    strcpy(server_ptr->self_connect_mode_possible_values[4].short_desc, "Ignore all self connect requests");
+
+    value.c = SELF_CONNECT_MODE_ALLOW_CHAR;
+    if (jackctl_add_parameter(
+            &server_ptr->parameters,
+            "self-connect-mode",
+            "Self connect mode.",
+            "Whether JACK clients are allowed to connect their own ports",
+            JackParamChar,
+            &server_ptr->self_connect_mode,
+            &server_ptr->default_self_connect_mode,
+            value,
+            &server_ptr->self_connect_mode_constraint) == NULL)
+    {
+        goto fail_free_parameters;
+    }
+
     JackServerGlobals::on_device_acquire = on_device_acquire;
     JackServerGlobals::on_device_release = on_device_release;
 
@@ -840,6 +905,7 @@ jackctl_server_start(
     jackctl_driver *driver_ptr)
 {
     int rc;
+    JackSelfConnectMode self_connect_mode;
 
     rc = jack_register_server(server_ptr->name.str, server_ptr->replace_registry.b);
     switch (rc)
@@ -864,17 +930,45 @@ jackctl_server_start(
 
     if (!server_ptr->realtime.b && server_ptr->client_timeout.i == 0)
         server_ptr->client_timeout.i = 500; /* 0.5 sec; usable when non realtime. */
+    
+    /* check port max value before allocating server */
+    if (server_ptr->port_max.ui > PORT_NUM_MAX) {
+        jack_error("JACK server started with too much ports %d (when port max can be %d)", server_ptr->port_max.ui, PORT_NUM_MAX);
+        goto fail;
+    }
 
-    /* get the engine/driver started */
+    switch (server_ptr->self_connect_mode.c)
+    {
+    case SELF_CONNECT_MODE_ALLOW_CHAR:
+        self_connect_mode = JackSelfConnectAllow;
+        break;
+    case SELF_CONNECT_MODE_FAIL_EXTERNAL_ONLY_CHAR:
+        self_connect_mode = JackSelfConnectFailExternalOnly;
+        break;
+    case SELF_CONNECT_MODE_IGNORE_EXTERNAL_ONLY_CHAR:
+        self_connect_mode = JackSelfConnectIgnoreExternalOnly;
+        break;
+    case SELF_CONNECT_MODE_FAIL_ALL_CHAR:
+        self_connect_mode = JackSelfConnectFailAll;
+        break;
+    case SELF_CONNECT_MODE_IGNORE_ALL_CHAR:
+        self_connect_mode = JackSelfConnectIgnoreAll;
+        break;
+    default:
+        self_connect_mode = JACK_DEFAULT_SELF_CONNECT_MODE;
+    }
 
+    /* get the engine/driver started */
     server_ptr->engine = new JackServer(
         server_ptr->sync.b,
         server_ptr->temporary.b,
         server_ptr->client_timeout.i,
         server_ptr->realtime.b,
         server_ptr->realtime_priority.i,
+        server_ptr->port_max.ui,                                
         server_ptr->verbose.b,
         (jack_timer_type_t)server_ptr->clock_source.ui,
+        self_connect_mode,
         server_ptr->name.str);
     if (server_ptr->engine == NULL)
     {
diff --git a/common/JackDebugClient.cpp b/common/JackDebugClient.cpp
index a2a61d8..df26377 100644
--- a/common/JackDebugClient.cpp
+++ b/common/JackDebugClient.cpp
@@ -19,6 +19,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 #include "JackDebugClient.h"
 #include "JackEngineControl.h"
+#include "JackException.h"
 #include "JackError.h"
 #include "JackTime.h"
 #include <iostream>
@@ -55,9 +56,9 @@ JackDebugClient::~JackDebugClient()
     *fStream << setw(5) << "- Total number of instantiated port : " << fTotalPortNumber << endl;
     *fStream << setw(5) << "- Number of port remaining open when exiting client : " << fOpenPortNumber << endl;
     if (fOpenPortNumber != 0)
-        *fStream << "!!! WARNING !!! Some ports have not been unregistrated ! Incorrect exiting !" << endl;
+        *fStream << "!!! WARNING !!! Some ports have not been unregistered ! Incorrect exiting !" << endl;
     if (fIsDeactivated != fIsActivated)
-        *fStream << "!!! ERROR !!! Client seem do not perform symetric activation-deactivation ! (not the same number of activate and deactivate)" << endl;
+        *fStream << "!!! ERROR !!! Client seem to not perform symetric activation-deactivation ! (not the same number of activate and deactivate)" << endl;
     if (fIsClosed == 0)
         *fStream << "!!! ERROR !!! Client have not been closed with jack_client_close() !" << endl;
 
@@ -68,9 +69,9 @@ JackDebugClient::~JackDebugClient()
         *fStream << setw(5) << "- Name : " << fPortList[i].name << endl;
         *fStream << setw(5) << "- idport : " << fPortList[i].idport << endl;
         *fStream << setw(5) << "- IsConnected : " << fPortList[i].IsConnected << endl;
-        *fStream << setw(5) << "- IsUnregistrated : " << fPortList[i].IsUnregistrated << endl;
-        if (fPortList[i].IsUnregistrated == 0)
-            *fStream << "!!! WARNING !!! Port have not been unregistrated ! Incorrect exiting !" << endl;
+        *fStream << setw(5) << "- IsUnregistered : " << fPortList[i].IsUnregistered << endl;
+        if (fPortList[i].IsUnregistered == 0)
+            *fStream << "!!! WARNING !!! Port have not been unregistered ! Incorrect exiting !" << endl;
     }
     *fStream << "delete object JackDebugClient : end of tracing" << endl;
     delete fStream;
@@ -106,33 +107,39 @@ int JackDebugClient::Open(const char* server_name, const char* name, jack_option
 
 int JackDebugClient::Close()
 {
-    fIsClosed++;
     *fStream << "Client '" << fClientName << "' was closed" << endl;
-    return fClient->Close();
+    int res = fClient->Close();
+    fIsClosed++;
+    return res;
 }
 
-void JackDebugClient::CheckClient() const
+void JackDebugClient::CheckClient(const char* function_name) const
 {
+    *fStream << "CheckClient : " << function_name << ", calling thread : " << pthread_self() << endl;
+    
     if (fIsClosed > 0)  {
-        *fStream << "!!! ERROR !!! : Accessing a client '" << fClientName << "' already closed !" << endl;
+        *fStream << "!!! ERROR !!! : Accessing a client '" << fClientName << "' already closed " << "from " << function_name << endl; 
         *fStream << "This is likely to cause crash !'" << endl;
+    #ifdef __APPLE__
+        Debugger();
+    #endif 
     }
 }
 
 pthread_t JackDebugClient::GetThreadID()
 {
-    CheckClient();
+    CheckClient("GetThreadID");
     return fClient->GetThreadID();
 }
 
 JackGraphManager* JackDebugClient::GetGraphManager() const
 {
-    CheckClient();
+    CheckClient("GetGraphManager");
     return fClient->GetGraphManager();
 }
 JackEngineControl* JackDebugClient::GetEngineControl() const
 {
-    CheckClient();
+    CheckClient("GetEngineControl");
     return fClient->GetEngineControl();
 }
 /*!
@@ -141,13 +148,13 @@ JackEngineControl* JackDebugClient::GetEngineControl() const
 
 int JackDebugClient::ClientNotify(int refnum, const char* name, int notify, int sync, const char* message, int value1, int value2)
 {
-    CheckClient();
+    CheckClient("ClientNotify");
     return fClient->ClientNotify( refnum, name, notify, sync, message, value1, value2);
 }
 
 int JackDebugClient::Activate()
 {
-    CheckClient();
+    CheckClient("Activate");
     int res = fClient->Activate();
     fIsActivated++;
     if (fIsDeactivated)
@@ -160,7 +167,7 @@ int JackDebugClient::Activate()
 
 int JackDebugClient::Deactivate()
 {
-    CheckClient();
+    CheckClient("Deactivate");
     int res = fClient->Deactivate();
     fIsDeactivated++;
     if (fIsActivated == 0)
@@ -177,7 +184,7 @@ int JackDebugClient::Deactivate()
 
 int JackDebugClient::PortRegister(const char* port_name, const char* port_type, unsigned long flags, unsigned long buffer_size)
 {
-    CheckClient();
+    CheckClient("PortRegister");
     int res = fClient->PortRegister(port_name, port_type, flags, buffer_size);
     if (res <= 0) {
         *fStream << "Client '" << fClientName << "' try port register ('" << port_name << "') and server return error  " << res << " ." << endl;
@@ -186,7 +193,7 @@ int JackDebugClient::PortRegister(const char* port_name, const char* port_type,
             fPortList[fTotalPortNumber].idport = res;
             strcpy(fPortList[fTotalPortNumber].name, port_name);
             fPortList[fTotalPortNumber].IsConnected = 0;
-            fPortList[fTotalPortNumber].IsUnregistrated = 0;
+            fPortList[fTotalPortNumber].IsUnregistered = 0;
         } else {
             *fStream << "!!! WARNING !!! History is full : no more port history will be recorded." << endl;
         }
@@ -199,42 +206,42 @@ int JackDebugClient::PortRegister(const char* port_name, const char* port_type,
 
 int JackDebugClient::PortUnRegister(jack_port_id_t port_index)
 {
-    CheckClient();
+    CheckClient("PortUnRegister");
     int res = fClient->PortUnRegister(port_index);
     fOpenPortNumber--;
     int i;
     for (i = (fTotalPortNumber - 1); i >= 0; i--) {	// We search the record into the history
         if (fPortList[i].idport == port_index) {		// We found the last record
-            if (fPortList[i].IsUnregistrated != 0)
+            if (fPortList[i].IsUnregistered != 0)
                 *fStream << "!!! ERROR !!! : '" << fClientName << "' id deregistering port '" << fPortList[i].name << "' that have already been unregistered !" << endl;
-            fPortList[i].IsUnregistrated++;
+            fPortList[i].IsUnregistered++;
             break;
         }
     }
     if (i == 0) // Port is not found
         *fStream << "JackClientDebug : PortUnregister : port " << port_index << " was not previously registered !" << endl;
     if (res != 0)
-        *fStream << "Client '" << fClientName << "' try to do PortUnregister and server return " << res << " )." << endl;
+        *fStream << "Client '" << fClientName << "' try to do PortUnregister and server return " << res << endl;
     *fStream << "Client '" << fClientName << "' unregister port '" << port_index << "'." << endl;
     return res;
 }
 
 int JackDebugClient::PortConnect(const char* src, const char* dst)
 {
-    CheckClient();
+    CheckClient("PortConnect");
     if (!fIsActivated)
         *fStream << "!!! ERROR !!! Trying to connect a port ( " << src << " to " << dst << ") while the client has not been activated !" << endl;
     int i;
     int res = fClient->PortConnect( src, dst);
     for (i = (fTotalPortNumber - 1); i >= 0; i--) {	// We search the record into the history
         if (strcmp(fPortList[i].name, src) == 0) {	// We found the last record in sources
-            if (fPortList[i].IsUnregistrated != 0)
+            if (fPortList[i].IsUnregistered != 0)
                 *fStream << "!!! ERROR !!! Connecting port " << src << " previoulsy unregistered !" << endl;
             fPortList[i].IsConnected++;
             *fStream << "Connecting port " << src << " to " << dst << ". ";
             break;
         } else if (strcmp(fPortList[i].name, dst) == 0 ) { // We found the record in dest
-            if (fPortList[i].IsUnregistrated != 0)
+            if (fPortList[i].IsUnregistered != 0)
                 *fStream << "!!! ERROR !!! Connecting port  " << dst << " previoulsy unregistered !" << endl;
             fPortList[i].IsConnected++;
             *fStream << "Connecting port " << src << " to " << dst << ". ";
@@ -251,20 +258,20 @@ int JackDebugClient::PortConnect(const char* src, const char* dst)
 
 int JackDebugClient::PortDisconnect(const char* src, const char* dst)
 {
-    CheckClient();
+    CheckClient("PortDisconnect");
     if (!fIsActivated)
         *fStream << "!!! ERROR !!! Trying to disconnect a port ( " << src << " to " << dst << ") while the client has not been activated !" << endl;
     int res = fClient->PortDisconnect( src, dst);
     int i;
     for (i = (fTotalPortNumber - 1); i >= 0; i--) { // We search the record into the history
         if (strcmp(fPortList[i].name, src) == 0) { // We found the record in sources
-            if (fPortList[i].IsUnregistrated != 0)
+            if (fPortList[i].IsUnregistered != 0)
                 *fStream << "!!! ERROR !!! : Disconnecting port " << src << " previoulsy unregistered !" << endl;
             fPortList[i].IsConnected--;
             *fStream << "disconnecting port " << src << ". ";
             break;
         } else if (strcmp(fPortList[i].name, dst) == 0 ) { // We found the record in dest
-            if (fPortList[i].IsUnregistrated != 0)
+            if (fPortList[i].IsUnregistered != 0)
                 *fStream << "!!! ERROR !!! : Disonnecting port  " << dst << " previoulsy unregistered !" << endl;
             fPortList[i].IsConnected--;
             *fStream << "disconnecting port " << dst << ". ";
@@ -281,14 +288,14 @@ int JackDebugClient::PortDisconnect(const char* src, const char* dst)
 
 int JackDebugClient::PortDisconnect(jack_port_id_t src)
 {
-    CheckClient();
+    CheckClient("PortDisconnect");
     if (!fIsActivated)
         *fStream << "!!! ERROR !!! : Trying to disconnect port  " << src << " while that client has not been activated !" << endl;
     int res = fClient->PortDisconnect(src);
     int i;
     for (i = (fTotalPortNumber - 1); i >= 0; i--) {		// We search the record into the history
         if (fPortList[i].idport == src) {				// We found the record in sources
-            if (fPortList[i].IsUnregistrated != 0)
+            if (fPortList[i].IsUnregistered != 0)
                 *fStream << "!!! ERROR !!! : Disconnecting port  " << src << " previoulsy unregistered !" << endl;
             fPortList[i].IsConnected--;
             *fStream << "Disconnecting port " << src << ". " << endl;
@@ -305,7 +312,7 @@ int JackDebugClient::PortDisconnect(jack_port_id_t src)
 
 int JackDebugClient::PortIsMine(jack_port_id_t port_index)
 {
-    CheckClient();
+    CheckClient("PortIsMine");
     return fClient->PortIsMine(port_index);
 }
 
@@ -315,13 +322,13 @@ int JackDebugClient::PortIsMine(jack_port_id_t port_index)
 
 int JackDebugClient::SetBufferSize(jack_nframes_t buffer_size)
 {
-    CheckClient();
+    CheckClient("SetBufferSize");
     return fClient->SetBufferSize(buffer_size);
 }
 
 int JackDebugClient::SetFreeWheel(int onoff)
 {
-    CheckClient();
+    CheckClient("SetFreeWheel");
     if (onoff && fFreewheel)
          *fStream << "!!! ERROR !!! : Freewheel setup seems incorrect : set = ON while FW is already ON " << endl;
     if (!onoff && !fFreewheel)
@@ -348,61 +355,61 @@ void JackDebugClient::ShutDown()
 
 int JackDebugClient::ReleaseTimebase()
 {
-    CheckClient();
+    CheckClient("ReleaseTimebase");
     return fClient->ReleaseTimebase();
 }
 
 int JackDebugClient::SetSyncCallback(JackSyncCallback sync_callback, void* arg)
 {
-    CheckClient();
+    CheckClient("SetSyncCallback");
     return fClient->SetSyncCallback(sync_callback, arg);
 }
 
 int JackDebugClient::SetSyncTimeout(jack_time_t timeout)
 {
-    CheckClient();
+    CheckClient("SetSyncTimeout");
     return fClient->SetSyncTimeout(timeout);
 }
 
 int JackDebugClient::SetTimebaseCallback(int conditional, JackTimebaseCallback timebase_callback, void* arg)
 {
-    CheckClient();
+    CheckClient("SetTimebaseCallback");
     return fClient->SetTimebaseCallback( conditional, timebase_callback, arg);
 }
 
 void JackDebugClient::TransportLocate(jack_nframes_t frame)
 {
-    CheckClient();
+    CheckClient("TransportLocate");
     fClient->TransportLocate(frame);
 }
 
 jack_transport_state_t JackDebugClient::TransportQuery(jack_position_t* pos)
 {
-    CheckClient();
+    CheckClient("TransportQuery");
     return fClient->TransportQuery(pos);
 }
 
 jack_nframes_t JackDebugClient::GetCurrentTransportFrame()
 {
-    CheckClient();
+    CheckClient("GetCurrentTransportFrame");
     return fClient->GetCurrentTransportFrame();
 }
 
 int JackDebugClient::TransportReposition(jack_position_t* pos)
 {
-    CheckClient();
+    CheckClient("TransportReposition");
     return fClient->TransportReposition(pos);
 }
 
 void JackDebugClient::TransportStart()
 {
-    CheckClient();
+    CheckClient("TransportStart");
     fClient->TransportStart();
 }
 
 void JackDebugClient::TransportStop()
 {
-    CheckClient();
+    CheckClient("TransportStop");
     fClient->TransportStop();
 }
 
@@ -412,13 +419,13 @@ void JackDebugClient::TransportStop()
 
 void JackDebugClient::OnShutdown(JackShutdownCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("OnShutdown");
     fClient->OnShutdown(callback, arg);
 }
 
 void JackDebugClient::OnInfoShutdown(JackInfoShutdownCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("OnInfoShutdown");
     fClient->OnInfoShutdown(callback, arg);
 }
     
@@ -427,16 +434,18 @@ int JackDebugClient::TimeCallback(jack_nframes_t nframes, void *arg)
     JackDebugClient* client = (JackDebugClient*)arg;
     jack_time_t t1 = GetMicroSeconds();
     int res = client->fProcessTimeCallback(nframes, client->fProcessTimeCallbackArg);
+    if (res == 0) {
     jack_time_t t2 = GetMicroSeconds();
-    long delta = long((t2 - t1) - client->GetEngineControl()->fPeriodUsecs);
-    if (delta > 0 && !client->fFreewheel)
-        *client->fStream << "!!! ERROR !!! : Process overload of " << delta << " us" << endl;
+        long delta = long((t2 - t1) - client->GetEngineControl()->fPeriodUsecs);
+        if (delta > 0 && !client->fFreewheel)
+            *client->fStream << "!!! ERROR !!! : Process overload of " << delta << " us" << endl;
+    }
     return res;
 }
 
 int JackDebugClient::SetProcessCallback(JackProcessCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetProcessCallback");
     fProcessTimeCallback = callback;
     fProcessTimeCallbackArg = arg;
     return fClient->SetProcessCallback(TimeCallback, this);
@@ -444,86 +453,86 @@ int JackDebugClient::SetProcessCallback(JackProcessCallback callback, void *arg)
 
 int JackDebugClient::SetXRunCallback(JackXRunCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetXRunCallback");
     return fClient->SetXRunCallback(callback, arg);
 }
 
 int JackDebugClient::SetInitCallback(JackThreadInitCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetInitCallback");
     return fClient->SetInitCallback(callback, arg);
 }
 
 int JackDebugClient::SetGraphOrderCallback(JackGraphOrderCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetGraphOrderCallback");
     return fClient->SetGraphOrderCallback(callback, arg);
 }
 
 int JackDebugClient::SetBufferSizeCallback(JackBufferSizeCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetBufferSizeCallback");
     return fClient->SetBufferSizeCallback(callback, arg);
 }
 
 int JackDebugClient::SetClientRegistrationCallback(JackClientRegistrationCallback callback, void* arg)
 {
-    CheckClient();
+    CheckClient("SetClientRegistrationCallback");
     return fClient->SetClientRegistrationCallback(callback, arg);
 }
 
 int JackDebugClient::SetFreewheelCallback(JackFreewheelCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetFreewheelCallback");
     return fClient->SetFreewheelCallback(callback, arg);
 }
 
 int JackDebugClient::SetPortRegistrationCallback(JackPortRegistrationCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetPortRegistrationCallback");
     return fClient->SetPortRegistrationCallback(callback, arg);
 }
 
 int JackDebugClient::SetPortConnectCallback(JackPortConnectCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetPortConnectCallback");
     return fClient->SetPortConnectCallback(callback, arg);
 }
 
 int JackDebugClient::SetPortRenameCallback(JackPortRenameCallback callback, void *arg)
 {
-    CheckClient();
+    CheckClient("SetPortRenameCallback");
     return fClient->SetPortRenameCallback(callback, arg);
 }
 
 JackClientControl* JackDebugClient::GetClientControl() const
 {
-    CheckClient();
+    CheckClient("GetClientControl");
     return fClient->GetClientControl();
 }
 
 // Internal clients
 char* JackDebugClient::GetInternalClientName(int ref)
 {
-    CheckClient();
+    CheckClient("GetInternalClientName");
     return fClient->GetInternalClientName(ref);
 }
 
 int JackDebugClient::InternalClientHandle(const char* client_name, jack_status_t* status)
 {
-    CheckClient();
+    CheckClient("InternalClientHandle");
     return fClient->InternalClientHandle(client_name, status);
 }
 
 int JackDebugClient::InternalClientLoad(const char* client_name, jack_options_t options, jack_status_t* status, jack_varargs_t* va)
 {
-    CheckClient();
+    CheckClient("InternalClientLoad");
     return fClient->InternalClientLoad(client_name, options, status, va);
 }
 
 void JackDebugClient::InternalClientUnload(int ref, jack_status_t* status)
 {
-    CheckClient();
+    CheckClient("InternalClientUnload");
     fClient->InternalClientUnload(ref, status);
 }
 
diff --git a/common/JackDebugClient.h b/common/JackDebugClient.h
index 0bb21b2..6a31f43 100644
--- a/common/JackDebugClient.h
+++ b/common/JackDebugClient.h
@@ -38,7 +38,7 @@ typedef struct
     jack_port_id_t idport;
     char name[JACK_PORT_NAME_SIZE]; //portname
     int IsConnected;
-    int IsUnregistrated;
+    int IsUnregistered;
 }
 PortFollower;
 
@@ -129,7 +129,7 @@ class JackDebugClient : public JackClient
         void InternalClientUnload(int ref, jack_status_t* status);
 
         JackClientControl* GetClientControl() const;
-        void CheckClient() const;
+        void CheckClient(const char* function_name) const;
 
         static int TimeCallback(jack_nframes_t nframes, void *arg);
 };
diff --git a/common/JackDriver.h b/common/JackDriver.h
index 83f7e25..901e6bf 100644
--- a/common/JackDriver.h
+++ b/common/JackDriver.h
@@ -109,6 +109,10 @@ class SERVER_EXPORT JackDriverClientInterface : public JackDriverInterface, publ
 /*!
  \brief The base class for drivers.
  */
+ 
+#define CaptureDriverFlags  static_cast<JackPortFlags>(JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal | JackPortIsActive)
+#define PlaybackDriverFlags static_cast<JackPortFlags>(JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal | JackPortIsActive)
+#define MonitorDriverFlags static_cast<JackPortFlags>(JackPortIsOutput | JackPortIsActive)
 
 class SERVER_EXPORT JackDriver : public JackDriverClientInterface
 {
diff --git a/common/JackEngine.cpp b/common/JackEngine.cpp
index 537c416..a492873 100644
--- a/common/JackEngine.cpp
+++ b/common/JackEngine.cpp
@@ -35,15 +35,15 @@ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 namespace Jack
 {
 
-#define AssertRefnum(ref) assert(ref >= 0 && ref < CLIENT_NUM);
-
 JackEngine::JackEngine(JackGraphManager* manager,
                        JackSynchro* table,
-                       JackEngineControl* control)
+                       JackEngineControl* control,
+                       JackSelfConnectMode self_connect_mode)
 {
     fGraphManager = manager;
     fSynchroTable = table;
     fEngineControl = control;
+    fSelfConnectMode = self_connect_mode;
     for (int i = 0; i < CLIENT_NUM; i++)
         fClientTable[i] = NULL;
 }
@@ -89,6 +89,11 @@ int JackEngine::Close()
 
     return 0;
 }
+    
+void JackEngine::NotifyQuit()
+{
+    fChannel.NotifyQuit();
+}
 
 //-----------------------------
 // Client ressource management
@@ -208,28 +213,28 @@ void JackEngine::NotifyClient(int refnum, int event, int sync, const char* messa
     JackClientInterface* client = fClientTable[refnum];
 
     // The client may be notified by the RT thread while closing
-    if (!client) {
-        jack_log("JackEngine::NotifyClient: client not available anymore");
-    } else if (client->GetClientControl()->fCallback[event]) {
-        if (client->ClientNotify(refnum, client->GetClientControl()->fName, event, sync, message, value1, value2) < 0)
-            jack_error("NotifyClient fails name = %s event = %ld val1 = %ld val2 = %ld", client->GetClientControl()->fName, event, value1, value2);
-    } else {
-        jack_log("JackEngine::NotifyClient: no callback for event = %ld", event);
+    if (client) {
+    
+        if (client && client->GetClientControl()->fCallback[event]) {
+            /*
+                Important for internal clients : unlock before calling the notification callbacks.
+            */
+            bool res = fMutex.Unlock();
+            if (client->ClientNotify(refnum, client->GetClientControl()->fName, event, sync, message, value1, value2) < 0)
+                jack_error("NotifyClient fails name = %s event = %ld val1 = %ld val2 = %ld", client->GetClientControl()->fName, event, value1, value2);
+            if (res)
+                fMutex.Lock();
+       
+        } else {
+            jack_log("JackEngine::NotifyClient: no callback for event = %ld", event);
+        }
     }
 }
 
-void JackEngine::NotifyClients(int event, int sync, const char*  message, int value1, int value2)
+void JackEngine::NotifyClients(int event, int sync, const char* message, int value1, int value2)
 {
     for (int i = 0; i < CLIENT_NUM; i++) {
-        JackClientInterface* client = fClientTable[i];
-        if (client) {
-            if (client->GetClientControl()->fCallback[event]) {
-                if (client->ClientNotify(i, client->GetClientControl()->fName, event, sync, message, value1, value2) < 0)
-                    jack_error("NotifyClient fails name = %s event = %ld val1 = %ld val2 = %ld", client->GetClientControl()->fName, event, value1, value2);
-            } else {
-                jack_log("JackEngine::NotifyClients: no callback for event = %ld", event);
-            }
-        }
+        NotifyClient(i, event, sync, message, value1, value2);
     }
 }
 
@@ -269,8 +274,7 @@ void JackEngine::NotifyRemoveClient(const char* name, int refnum)
 void JackEngine::NotifyXRun(jack_time_t callback_usecs, float delayed_usecs)
 {
     // Use the audio thread => request thread communication channel
-    fEngineControl->ResetFrameTime(callback_usecs);
-    fEngineControl->NotifyXRun(delayed_usecs);
+    fEngineControl->NotifyXRun(callback_usecs, delayed_usecs);
     fChannel.Notify(ALL_CLIENTS, kXRunCallback, 0);
 }
 
@@ -322,9 +326,9 @@ void JackEngine::NotifyPortRegistation(jack_port_id_t port_index, bool onoff)
     NotifyClients((onoff ? kPortRegistrationOnCallback : kPortRegistrationOffCallback), false, "", port_index, 0);
 }
 
-void JackEngine::NotifyPortRename(jack_port_id_t port)
+void JackEngine::NotifyPortRename(jack_port_id_t port, const char* old_name)
 {
-    NotifyClients(kPortRenameCallback, false, "", port, 0);
+    NotifyClients(kPortRenameCallback, false, old_name, port, 0);
 }
 
 void JackEngine::NotifyPortConnect(jack_port_id_t src, jack_port_id_t dst, bool onoff)
@@ -343,7 +347,6 @@ void JackEngine::NotifyActivate(int refnum)
 
 int JackEngine::GetInternalClientName(int refnum, char* name_res)
 {
-    AssertRefnum(refnum);
     JackClientInterface* client = fClientTable[refnum];
     if (client) {
         strncpy(name_res, client->GetClientControl()->fName, JACK_CLIENT_NAME_SIZE);
@@ -373,7 +376,6 @@ int JackEngine::InternalClientHandle(const char* client_name, int* status, int*
 
 int JackEngine::InternalClientUnload(int refnum, int* status)
 {
-    AssertRefnum(refnum);
     JackClientInterface* client = fClientTable[refnum];
     if (client) {
         int res = client->Close();
@@ -587,7 +589,6 @@ error:
 // Used for external clients
 int JackEngine::ClientExternalClose(int refnum)
 {
-    AssertRefnum(refnum);
     JackClientInterface* client = fClientTable[refnum];
 
     if (client)	{
@@ -604,7 +605,6 @@ int JackEngine::ClientExternalClose(int refnum)
 // Used for server internal clients or drivers when the RT thread is stopped
 int JackEngine::ClientInternalClose(int refnum, bool wait)
 {
-    AssertRefnum(refnum);
     JackClientInterface* client = fClientTable[refnum];
     return (client)	? ClientCloseAux(refnum, client, wait) : -1;
 }
@@ -651,10 +651,8 @@ int JackEngine::ClientCloseAux(int refnum, JackClientInterface* client, bool wai
 
 int JackEngine::ClientActivate(int refnum, bool is_real_time)
 {
-    AssertRefnum(refnum);
     JackClientInterface* client = fClientTable[refnum];
-    assert(fClientTable[refnum]);
-
+ 
     jack_log("JackEngine::ClientActivate ref = %ld name = %s", refnum, client->GetClientControl()->fName);
     if (is_real_time)
         fGraphManager->Activate(refnum);
@@ -664,7 +662,30 @@ int JackEngine::ClientActivate(int refnum, bool is_real_time)
         jack_error("JackEngine::ClientActivate wait error ref = %ld name = %s", refnum, client->GetClientControl()->fName);
         return -1;
     } else {
+        jack_int_t input_ports[PORT_NUM_FOR_CLIENT];
+        jack_int_t output_ports[PORT_NUM_FOR_CLIENT];
+        fGraphManager->GetInputPorts(refnum, input_ports);
+        fGraphManager->GetOutputPorts(refnum, output_ports);
+        
+        // First add port state to JackPortIsActive
+        for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (input_ports[i] != EMPTY); i++) {
+            fGraphManager->ActivatePort(input_ports[i]);
+        }
+        for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (output_ports[i] != EMPTY); i++) {
+            fGraphManager->ActivatePort(output_ports[i]);
+        }
+        
+        // Notify client
         NotifyActivate(refnum);
+        
+        // Then issue port registration notification
+        for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (input_ports[i] != EMPTY); i++) {
+            NotifyPortRegistation(input_ports[i], true);
+        }
+        for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (output_ports[i] != EMPTY); i++) {
+            NotifyPortRegistation(output_ports[i], true);
+        }
+
         return 0;
     }
 }
@@ -672,25 +693,33 @@ int JackEngine::ClientActivate(int refnum, bool is_real_time)
 // May be called without client
 int JackEngine::ClientDeactivate(int refnum)
 {
-    AssertRefnum(refnum);
     JackClientInterface* client = fClientTable[refnum];
     if (client == NULL)
         return -1;
 
     jack_log("JackEngine::ClientDeactivate ref = %ld name = %s", refnum, client->GetClientControl()->fName);
 
-    // Disconnect all ports ==> notifications are sent
-    jack_int_t ports[PORT_NUM_FOR_CLIENT];
-    int i;
+    jack_int_t input_ports[PORT_NUM_FOR_CLIENT];
+    jack_int_t output_ports[PORT_NUM_FOR_CLIENT];
+    fGraphManager->GetInputPorts(refnum, input_ports);
+    fGraphManager->GetOutputPorts(refnum, output_ports);
 
-    fGraphManager->GetInputPorts(refnum, ports);
-    for (i = 0; (i < PORT_NUM_FOR_CLIENT) && (ports[i] != EMPTY) ; i++) {
-        PortDisconnect(refnum, ports[i], ALL_PORTS);
+    // First disconnect all ports and remove their JackPortIsActive state
+    for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (input_ports[i] != EMPTY); i++) {
+        PortDisconnect(refnum, input_ports[i], ALL_PORTS);
+        fGraphManager->DeactivatePort(input_ports[i]);
     }
-
-    fGraphManager->GetOutputPorts(refnum, ports);
-    for (i = 0; (i < PORT_NUM_FOR_CLIENT) && (ports[i] != EMPTY) ; i++) {
-        PortDisconnect(refnum, ports[i], ALL_PORTS);
+    for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (output_ports[i] != EMPTY); i++) {
+        PortDisconnect(refnum, output_ports[i], ALL_PORTS);
+        fGraphManager->DeactivatePort(output_ports[i]);
+    }
+    
+    // Then issue port registration notification
+    for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (input_ports[i] != EMPTY); i++) {
+        NotifyPortRegistation(input_ports[i], false);
+    }
+    for (int i = 0; (i < PORT_NUM_FOR_CLIENT) && (output_ports[i] != EMPTY); i++) {
+        NotifyPortRegistation(output_ports[i], false);
     }
 
     fGraphManager->Deactivate(refnum);
@@ -712,8 +741,9 @@ int JackEngine::ClientDeactivate(int refnum)
 int JackEngine::PortRegister(int refnum, const char* name, const char *type, unsigned int flags, unsigned int buffer_size, jack_port_id_t* port_index)
 {
     jack_log("JackEngine::PortRegister ref = %ld name = %s type = %s flags = %d buffer_size = %d", refnum, name, type, flags, buffer_size);
-    AssertRefnum(refnum);
+
     assert(fClientTable[refnum]);
+    JackClientInterface* client = fClientTable[refnum];
 
     // Check if port name already exists
     if (fGraphManager->GetPort(name) != NO_PORT) {
@@ -723,7 +753,8 @@ int JackEngine::PortRegister(int refnum, const char* name, const char *type, uns
 
     *port_index = fGraphManager->AllocatePort(refnum, name, type, (JackPortFlags)flags, fEngineControl->fBufferSize);
     if (*port_index != NO_PORT) {
-        NotifyPortRegistation(*port_index, true);
+        if (client->GetClientControl()->fActive)
+            NotifyPortRegistation(*port_index, true);
         return 0;
     } else {
         return -1;
@@ -732,25 +763,93 @@ int JackEngine::PortRegister(int refnum, const char* name, const char *type, uns
 
 int JackEngine::PortUnRegister(int refnum, jack_port_id_t port_index)
 {
+    JackLock lock(this);
     jack_log("JackEngine::PortUnRegister ref = %ld port_index = %ld", refnum, port_index);
-    AssertRefnum(refnum);
+
     assert(fClientTable[refnum]);
+    JackClientInterface* client = fClientTable[refnum];
 
     // Disconnect port ==> notification is sent
     PortDisconnect(refnum, port_index, ALL_PORTS);
 
     if (fGraphManager->ReleasePort(refnum, port_index) == 0) {
-        NotifyPortRegistation(port_index, false);
+        if (client->GetClientControl()->fActive)
+            NotifyPortRegistation(port_index, false);
         return 0;
     } else {
         return -1;
     }
 }
 
+// this check is to prevent apps to self connect to other apps
+// TODO: make this work with multiple clients per app
+int JackEngine::CheckPortsConnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
+{
+    JackPort* src_port = fGraphManager->GetPort(src);
+    JackPort* dst_port = fGraphManager->GetPort(dst);
+
+    jack_log("CheckPortsConnect(caller = %d, src = %d, dst = %d)", refnum, src_port->GetRefNum(), dst_port->GetRefNum());
+
+    int src_self = src_port->GetRefNum() == refnum ? 1 : 0;
+    int dst_self = dst_port->GetRefNum() == refnum ? 1 : 0;
+
+    jack_log("src_self is %s", src_self ? "true" : "false");
+    jack_log("dst_self is %s", dst_self ? "true" : "false");
+
+    // 0 means client is connecting other client ports (i.e. control app patchbay functionality)
+    // 1 means client is connecting its own port to port of other client (i.e. self hooking into system app)
+    // 2 means client is connecting its own ports (i.e. for app internal functionality)
+    // TODO: Make this check an engine option and more tweakable (return error or success)
+    // MAYBE: make the engine option changable on the fly and expose it through client or control API
+
+    switch (fSelfConnectMode)
+    {
+    case JackSelfConnectFailExternalOnly:
+        if (src_self + dst_self == 1)
+        {
+            jack_info("rejecting port self connect request to external port (%s -> %s)", src_port->GetName(), dst_port->GetName());
+            return -1;
+        }
+
+        return 1;
+
+    case JackSelfConnectIgnoreExternalOnly:
+        if (src_self + dst_self == 1)
+        {
+            jack_info("ignoring port self connect request to external port (%s -> %s)", src_port->GetName(), dst_port->GetName());
+            return 0;
+        }
+
+        return 1;
+
+    case JackSelfConnectFailAll:
+        if (src_self + dst_self != 0)
+        {
+            jack_info("rejecting port self connect request (%s -> %s)", src_port->GetName(), dst_port->GetName());
+            return -1;
+        }
+
+        return 1;
+
+    case JackSelfConnectIgnoreAll:
+        if (src_self + dst_self != 0)
+        {
+            jack_info("ignoring port self connect request (%s -> %s)", src_port->GetName(), dst_port->GetName());
+            return 0;
+        }
+
+        return 1;
+
+    case JackSelfConnectAllow:  // fix warning
+        return 1;
+    }
+
+    return 1;
+}
+
 int JackEngine::PortConnect(int refnum, const char* src, const char* dst)
 {
     jack_log("JackEngine::PortConnect src = %s dst = %s", src, dst);
-    AssertRefnum(refnum);
     jack_port_id_t port_src, port_dst;
 
     return (fGraphManager->GetTwoPorts(src, dst, &port_src, &port_dst) < 0)
@@ -761,7 +860,6 @@ int JackEngine::PortConnect(int refnum, const char* src, const char* dst)
 int JackEngine::PortConnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
 {
     jack_log("JackEngine::PortConnect src = %d dst = %d", src, dst);
-    AssertRefnum(refnum);
     JackClientInterface* client;
     int ref;
 
@@ -788,7 +886,12 @@ int JackEngine::PortConnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
         return -1;
     }
 
-    int res = fGraphManager->Connect(src, dst);
+    int res = CheckPortsConnect(refnum, src, dst);
+    if (res != 1) {
+        return res;
+    }
+
+    res = fGraphManager->Connect(src, dst);
     if (res == 0)
         NotifyPortConnect(src, dst, true);
     return res;
@@ -797,7 +900,6 @@ int JackEngine::PortConnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
 int JackEngine::PortDisconnect(int refnum, const char* src, const char* dst)
 {
     jack_log("JackEngine::PortDisconnect src = %s dst = %s", src, dst);
-    AssertRefnum(refnum);
     jack_port_id_t port_src, port_dst;
 
     return (fGraphManager->GetTwoPorts(src, dst, &port_src, &port_dst) < 0)
@@ -808,8 +910,7 @@ int JackEngine::PortDisconnect(int refnum, const char* src, const char* dst)
 int JackEngine::PortDisconnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
 {
     jack_log("JackEngine::PortDisconnect src = %d dst = %d", src, dst);
-    AssertRefnum(refnum);
-
+ 
     if (dst == ALL_PORTS) {
 
         jack_int_t connections[CONNECTION_NUM_FOR_PORT];
@@ -832,22 +933,29 @@ int JackEngine::PortDisconnect(int refnum, jack_port_id_t src, jack_port_id_t ds
         }
 
         return ret;
-    } else if (fGraphManager->CheckPorts(src, dst) < 0) {
-        return -1;
-    } else if (fGraphManager->Disconnect(src, dst) == 0) {
-        // Notifications
-        NotifyPortConnect(src, dst, false);
-        return 0;
-    } else {
+    }
+
+    if (fGraphManager->CheckPorts(src, dst) < 0) {
         return -1;
     }
+
+    int res = CheckPortsConnect(refnum, src, dst);
+    if (res != 1) {
+        return res;
+    }
+
+    res = fGraphManager->Disconnect(src, dst);
+    if (res == 0)
+        NotifyPortConnect(src, dst, false);
+    return res;
 }
 
 int JackEngine::PortRename(int refnum, jack_port_id_t port, const char* name)
 {
-    AssertRefnum(refnum);
+    char old_name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
+    strcpy(old_name, fGraphManager->GetPort(port)->GetName());
     fGraphManager->GetPort(port)->SetName(name);
-    NotifyPortRename(port);
+    NotifyPortRename(port, old_name);
     return 0;
 }
 
diff --git a/common/JackEngine.h b/common/JackEngine.h
index 8212daf..2480b2d 100644
--- a/common/JackEngine.h
+++ b/common/JackEngine.h
@@ -23,6 +23,7 @@ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 #include "JackConstants.h"
 #include "JackGraphManager.h"
 #include "JackSynchro.h"
+#include "JackMutex.h"
 #include "JackTransportEngine.h"
 #include "JackPlatformPlug.h"
 
@@ -37,12 +38,15 @@ class JackExternalClient;
 \brief Engine description.
 */
 
-class SERVER_EXPORT JackEngine 
+class SERVER_EXPORT JackEngine : public JackLockAble
 {
+    friend class JackLockedEngine;
+    
     private:
 
         JackGraphManager* fGraphManager;
         JackEngineControl* fEngineControl;
+        JackSelfConnectMode fSelfConnectMode;
         JackClientInterface* fClientTable[CLIENT_NUM];
         JackSynchro* fSynchroTable;
         JackServerNotifyChannel fChannel;              /*! To communicate between the RT thread and server */
@@ -69,17 +73,24 @@ class SERVER_EXPORT JackEngine
     
         void NotifyPortRegistation(jack_port_id_t port_index, bool onoff);
         void NotifyPortConnect(jack_port_id_t src, jack_port_id_t dst, bool onoff);
-        void NotifyPortRename(jack_port_id_t src);
+        void NotifyPortRename(jack_port_id_t src, const char* old_name);
         void NotifyActivate(int refnum);
+        
+        bool CheckClient(int refnum)
+        {
+            return (refnum >= 0 && refnum < CLIENT_NUM && fClientTable[refnum] != NULL);
+        }
+
+        int CheckPortsConnect(int refnum, jack_port_id_t src, jack_port_id_t dst);
 
     public:
 
-        JackEngine(JackGraphManager* manager, JackSynchro* table, JackEngineControl* controler);
+        JackEngine(JackGraphManager* manager, JackSynchro* table, JackEngineControl* controler, JackSelfConnectMode self_connect_mode);
         ~JackEngine();
 
         int Open();
         int Close();
-
+  
         // Client management
         int ClientCheck(const char* name, char* name_res, int protocol, int options, int* status);
         int ClientExternalOpen(const char* name, int pid, int* ref, int* shared_engine, int* shared_client, int* shared_graph_manager);
@@ -122,6 +133,7 @@ class SERVER_EXPORT JackEngine
         void NotifyBufferSize(jack_nframes_t buffer_size);
         void NotifySampleRate(jack_nframes_t sample_rate);
         void NotifyFreewheel(bool onoff);
+        void NotifyQuit();
 };
 
 
diff --git a/common/JackEngineControl.cpp b/common/JackEngineControl.cpp
index 872dcd3..db13ae7 100644
--- a/common/JackEngineControl.cpp
+++ b/common/JackEngineControl.cpp
@@ -81,8 +81,9 @@ void JackEngineControl::ResetRollingUsecs()
     fRollingInterval = int(floor((JACK_ENGINE_ROLLING_INTERVAL * 1000.f) / fPeriodUsecs));
 }
     
-void JackEngineControl::NotifyXRun(float delayed_usecs)
+void JackEngineControl::NotifyXRun(jack_time_t callback_usecs, float delayed_usecs)
 {
+    ResetFrameTime(callback_usecs);
     fXrunDelayedUsecs = delayed_usecs;
     if (delayed_usecs > fMaxDelayedUsecs)
         fMaxDelayedUsecs = delayed_usecs;
diff --git a/common/JackEngineControl.h b/common/JackEngineControl.h
index 326e3b7..3ba54b8 100644
--- a/common/JackEngineControl.h
+++ b/common/JackEngineControl.h
@@ -162,7 +162,7 @@ struct SERVER_EXPORT JackEngineControl : public JackShmMem
     }
     
     // XRun
-    void NotifyXRun(float delayed_usecs);
+    void NotifyXRun(jack_time_t callback_usecs, float delayed_usecs);
     void ResetXRun()
     {
         fMaxDelayedUsecs = 0.f;
diff --git a/common/JackEngineProfiling.cpp b/common/JackEngineProfiling.cpp
index b0a1b44..cfe5d63 100644
--- a/common/JackEngineProfiling.cpp
+++ b/common/JackEngineProfiling.cpp
@@ -25,6 +25,9 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "JackGlobals.h"
 #include "JackTime.h"
 
+#include <iostream>
+#include <fstream>
+
 namespace Jack
 {
 
@@ -38,12 +41,10 @@ JackEngineProfiling::JackEngineProfiling():fAudioCycle(0),fMeasuredClient(0)
 
 JackEngineProfiling::~JackEngineProfiling()
 {
-    FILE* file = fopen("JackEngineProfiling.log", "w");
-    char buffer[1024];
-    
+    std::ofstream fStream("JackEngineProfiling.log", std::ios_base::ate);
     jack_info("Write server and clients timing data...");
 
-    if (file == NULL) {
+    if (!fStream.is_open()) {
         jack_error("JackEngineProfiling::Save cannot open JackEngineProfiling.log file");
     } else {
     
@@ -58,7 +59,7 @@ JackEngineProfiling::~JackEngineProfiling()
                 continue; // Skip non valid cycles
                 
             // Print driver delta and end cycle
-            fprintf(file, "%ld \t %ld \t", d1, d2);
+            fStream << d1 << "\t" << d2 << "\t";
              
             // For each measured client
             for (unsigned int j = 0; j < fMeasuredClient; j++) { 
@@ -71,220 +72,214 @@ JackEngineProfiling::~JackEngineProfiling()
                     long d5 = long(fProfileTable[i].fClientTable[ref].fSignaledAt - fProfileTable[i - 1].fCurCycleBegin);
                     long d6 = long(fProfileTable[i].fClientTable[ref].fAwakeAt - fProfileTable[i - 1].fCurCycleBegin);
                     long d7 = long(fProfileTable[i].fClientTable[ref].fFinishedAt - fProfileTable[i - 1].fCurCycleBegin);
-             
-                    // Print ref, signal, start, end, scheduling, duration, status
-                    fprintf(file, "%d \t %ld \t %ld \t %ld \t %ld \t %ld \t %d \t", 
-                            ref,
-                            ((d5 > 0) ? d5 : 0),
-                            ((d6 > 0) ? d6 : 0),
-                            ((d7 > 0) ? d7 : 0),
-                            ((d6 > 0 && d5 > 0) ? (d6 - d5) : 0),
-                            ((d7 > 0 && d6 > 0) ? (d7 - d6) : 0),
-                            fProfileTable[i].fClientTable[ref].fStatus);
-                } else { // Print tabs
-                     fprintf(file, "\t  \t  \t  \t  \t  \t \t");
+                        
+                     fStream << ref << "\t" ;
+                     fStream << ((d5 > 0) ? d5 : 0) << "\t";
+                     fStream << ((d6 > 0) ? d6 : 0) << "\t" ;
+                     fStream << ((d7 > 0) ? d7 : 0) << "\t";
+                     fStream << ((d6 > 0 && d5 > 0) ? (d6 - d5) : 0) << "\t" ;
+                     fStream << ((d7 > 0 && d6 > 0) ? (d7 - d6) : 0) << "\t" ;
+                     fStream << fProfileTable[i].fClientTable[ref].fStatus << "\t" ;;
+                
+                 } else { // Print tabs
+                     fStream <<  "\t  \t  \t  \t  \t  \t \t";
                 }
             }
             
             // Terminate line
-            fprintf(file, "\n");
+            fStream << std::endl;
         }
     }
     
     // Driver period
-    file = fopen("Timing1.plot", "w");
-
-    if (file == NULL) {
+     std::ofstream fStream1("Timing1.plot", std::ios_base::ate);
+ 
+    if (!fStream1.is_open()) {
         jack_error("JackEngineProfiling::Save cannot open Timing1.log file");
     } else {
         
-        fprintf(file, "set grid\n");
-        fprintf(file, "set title \"Audio driver timing\"\n");
-        fprintf(file, "set xlabel \"audio cycles\"\n");
-        fprintf(file, "set ylabel \"usec\"\n");
-        fprintf(file, "plot \"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines \n");
-    
-        fprintf(file, "set output 'Timing1.pdf\n");
-        fprintf(file, "set terminal pdf\n");
-    
-        fprintf(file, "set grid\n");
-        fprintf(file, "set title \"Audio driver timing\"\n");
-        fprintf(file, "set xlabel \"audio cycles\"\n");
-        fprintf(file, "set ylabel \"usec\"\n");
-        fprintf(file, "plot \"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines \n");
-    
-        fclose(file);
+        fStream1 << "set grid\n";
+        fStream1 <<  "set title \"Audio driver timing\"\n";
+        fStream1 <<  "set xlabel \"audio cycles\"\n";
+        fStream1 <<  "set ylabel \"usec\"\n";
+        fStream1 <<  "plot \"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines \n";
+        
+        fStream1 <<  "set output 'Timing1.pdf\n";
+        fStream1 <<  "set terminal pdf\n";
+        
+        fStream1 <<  "set grid\n";
+        fStream1 <<  "set title \"Audio driver timing\"\n";
+        fStream1 <<  "set xlabel \"audio cycles\"\n";
+        fStream1 <<  "set ylabel \"usec\"\n";
+        fStream1 <<  "plot \"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines \n";
     }
     
     // Driver end date
-    file = fopen("Timing2.plot", "w");
-
-    if (file == NULL) {
+    std::ofstream fStream2("Timing2.plot", std::ios_base::ate);
+  
+    if (!fStream2.is_open()) {
         jack_error("JackEngineProfiling::Save cannot open Timing2.log file");
     } else {
    
-        fprintf(file, "set grid\n");
-        fprintf(file, "set title \"Driver end date\"\n");
-        fprintf(file, "set xlabel \"audio cycles\"\n");
-        fprintf(file, "set ylabel \"usec\"\n");
-        fprintf(file, "plot  \"JackEngineProfiling.log\" using 2 title \"Driver end date\" with lines \n");
-    
-        fprintf(file, "set output 'Timing2.pdf\n");
-        fprintf(file, "set terminal pdf\n");
+        fStream2 << "set grid\n";
+        fStream2 <<  "set title \"Driver end date\"\n";
+        fStream2 <<  "set xlabel \"audio cycles\"\n";
+        fStream2 <<  "set ylabel \"usec\"\n";
+        fStream2 <<  "plot  \"JackEngineProfiling.log\" using 2 title \"Driver end date\" with lines \n";
     
-        fprintf(file, "set grid\n");
-        fprintf(file, "set title \"Driver end date\"\n");
-        fprintf(file, "set xlabel \"audio cycles\"\n");
-        fprintf(file, "set ylabel \"usec\"\n");
-        fprintf(file, "plot  \"JackEngineProfiling.log\" using 2 title \"Driver end date\" with lines \n");
+        fStream2 <<  "set output 'Timing2.pdf\n";
+        fStream2 <<  "set terminal pdf\n";
     
-        fclose(file);
+        fStream2 <<  "set grid\n";
+        fStream2 <<  "set title \"Driver end date\"\n";
+        fStream2 <<  "set xlabel \"audio cycles\"\n";
+        fStream2 <<  "set ylabel \"usec\"\n";
+        fStream2 <<  "plot  \"JackEngineProfiling.log\" using 2 title \"Driver end date\" with lines \n";
     }
         
     // Clients end date
     if (fMeasuredClient > 0) {
-        file = fopen("Timing3.plot", "w");
-        if (file == NULL) {
+        std::ofstream fStream3("Timing3.plot", std::ios_base::ate);
+        
+        if (!fStream3.is_open()) {
             jack_error("JackEngineProfiling::Save cannot open Timing3.log file");
         } else {
         
-            fprintf(file, "set multiplot\n");
-            fprintf(file, "set grid\n");
-            fprintf(file, "set title \"Clients end date\"\n");
-            fprintf(file, "set xlabel \"audio cycles\"\n");
-            fprintf(file, "set ylabel \"usec\"\n");
-            fprintf(file, "plot ");
+            fStream3 << "set multiplot\n";
+            fStream3 << "set grid\n";
+            fStream3 << "set title \"Clients end date\"\n";
+            fStream3 << "set xlabel \"audio cycles\"\n";
+            fStream3 << "set ylabel \"usec\"\n";
+            fStream3 << "plot ";
             for (unsigned int i = 0; i < fMeasuredClient; i++) {
                 if (i == 0) {
                     if (i + 1 == fMeasuredClient) { // Last client
-                        sprintf(buffer, "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using %d title \"%s\" with lines", 
-                        ((i + 1) * 7) - 1 , fIntervalTable[i].fName);
-                    } else {
-                        sprintf(buffer, "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", 
-                        ((i + 1) * 7) - 1 , fIntervalTable[i].fName);
+                        fStream3 << "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using ";
+                        fStream3 <<  ((i + 1) * 7) - 1;
+                        fStream3 << " title \"" << fIntervalTable[i].fName << "\"with lines";
+                     } else {
+                        fStream3 << "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using ";
+                        fStream3 <<  ((i + 1) * 7) - 1;
+                        fStream3 << " title \"" << fIntervalTable[i].fName << "\"with lines,";
                     }
                 } else if (i + 1 == fMeasuredClient) { // Last client
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines", ((i + 1) * 7) - 1 , fIntervalTable[i].fName);
+                    fStream3 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) - 1  << " title \"" << fIntervalTable[i].fName << "\" with lines";
                 } else {
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", ((i + 1) * 7) - 1, fIntervalTable[i].fName);
+                    fStream3 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) - 1  << " title \"" << fIntervalTable[i].fName << "\" with lines,";
                 }
-                fprintf(file, buffer);
             }
         
-            fprintf(file, "\n unset multiplot\n");  
-            fprintf(file, "set output 'Timing3.pdf\n");
-            fprintf(file, "set terminal pdf\n");
+            fStream3 << "\n unset multiplot\n";  
+            fStream3 << "set output 'Timing3.pdf\n";
+            fStream3 << "set terminal pdf\n";
         
-            fprintf(file, "set multiplot\n");
-            fprintf(file, "set grid\n");
-            fprintf(file, "set title \"Clients end date\"\n");
-            fprintf(file, "set xlabel \"audio cycles\"\n");
-            fprintf(file, "set ylabel \"usec\"\n");
-            fprintf(file, "plot ");
+            fStream3 << "set multiplot\n";
+            fStream3 << "set grid\n";
+            fStream3 << "set title \"Clients end date\"\n";
+            fStream3 << "set xlabel \"audio cycles\"\n";
+            fStream3 << "set ylabel \"usec\"\n";
+            fStream3 << "plot ";
             for (unsigned int i = 0; i < fMeasuredClient; i++) {
                 if (i == 0) {
                     if ((i + 1) == fMeasuredClient) { // Last client
-                        sprintf(buffer, "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using %d title \"%s\" with lines", 
-                        ((i + 1) * 7) - 1 , fIntervalTable[i].fName);
+                        fStream3 << "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using ";
+                        fStream3 <<  ((i + 1) * 7) - 1;
+                        fStream3 << " title \"" << fIntervalTable[i].fName << "\"with lines";
                     } else {
-                        sprintf(buffer, "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", 
-                        ((i + 1) * 7) - 1 , fIntervalTable[i].fName);
+                        fStream3 << "\"JackEngineProfiling.log\" using 1 title \"Audio period\" with lines,\"JackEngineProfiling.log\" using ";
+                        fStream3 <<  ((i + 1) * 7) - 1;
+                        fStream3 << " title \"" << fIntervalTable[i].fName << "\"with lines,";
                     }
                 } else if ((i + 1) == fMeasuredClient) { // Last client
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines", ((i + 1) * 7) - 1 , fIntervalTable[i].fName);
+                    fStream3 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) - 1  << " title \"" << fIntervalTable[i].fName << "\" with lines";
                 } else {
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", ((i + 1) * 7) - 1, fIntervalTable[i].fName);
+                    fStream3 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) - 1  << " title \"" << fIntervalTable[i].fName << "\" with lines,";
                 }
-                fprintf(file, buffer);
             }
-             
-            fclose(file);
         }
     }
 
     // Clients scheduling
     if (fMeasuredClient > 0) {
-        file = fopen("Timing4.plot", "w");
-
-        if (file == NULL) {
+        std::ofstream fStream4("Timing4.plot", std::ios_base::ate);
+        
+        if (!fStream4.is_open()) {
             jack_error("JackEngineProfiling::Save cannot open Timing4.log file");
         } else {
         
-            fprintf(file, "set multiplot\n");
-            fprintf(file, "set grid\n");
-            fprintf(file, "set title \"Clients scheduling latency\"\n");
-            fprintf(file, "set xlabel \"audio cycles\"\n");
-            fprintf(file, "set ylabel \"usec\"\n");
-            fprintf(file, "plot ");
+            fStream4 << "set multiplot\n";
+            fStream4 << "set grid\n";
+            fStream4 << "set title \"Clients scheduling latency\"\n";
+            fStream4 << "set xlabel \"audio cycles\"\n";
+            fStream4 << "set ylabel \"usec\"\n";
+            fStream4 << "plot ";
             for (unsigned int i = 0; i < fMeasuredClient; i++) {
-                if ((i + 1) == fMeasuredClient) // Last client
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines", ((i + 1) * 7), fIntervalTable[i].fName);
-                else
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", ((i + 1) * 7), fIntervalTable[i].fName);
-                fprintf(file, buffer);
+                if ((i + 1) == fMeasuredClient) { // Last client
+                    fStream4 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7)  << " title \"" << fIntervalTable[i].fName << "\" with lines";
+                 } else {
+                     fStream4 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7)  << " title \"" << fIntervalTable[i].fName << "\" with lines,";
+                }
             }
             
-            fprintf(file, "\n unset multiplot\n");  
-            fprintf(file, "set output 'Timing4.pdf\n");
-            fprintf(file, "set terminal pdf\n");
+            fStream4 << "\n unset multiplot\n";  
+            fStream4 << "set output 'Timing4.pdf\n";
+            fStream4 << "set terminal pdf\n";
             
-            fprintf(file, "set multiplot\n");
-            fprintf(file, "set grid\n");
-            fprintf(file, "set title \"Clients scheduling latency\"\n");
-            fprintf(file, "set xlabel \"audio cycles\"\n");
-            fprintf(file, "set ylabel \"usec\"\n");
-            fprintf(file, "plot ");
+            fStream4 << "set multiplot\n";
+            fStream4 << "set grid\n";
+            fStream4 << "set title \"Clients scheduling latency\"\n";
+            fStream4 << "set xlabel \"audio cycles\"\n";
+            fStream4 << "set ylabel \"usec\"\n";
+            fStream4 << "plot ";
             for (unsigned int i = 0; i < fMeasuredClient; i++) {
-                if ((i + 1) == fMeasuredClient) // Last client
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines", ((i + 1) * 7), fIntervalTable[i].fName);
-                else
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", ((i + 1) * 7), fIntervalTable[i].fName);
-                fprintf(file, buffer);
+                if ((i + 1) == fMeasuredClient) { // Last client
+                    fStream4 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7)  << " title \"" << fIntervalTable[i].fName << "\" with lines";
+                } else {
+                     fStream4 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7)  << " title \"" << fIntervalTable[i].fName << "\" with lines,";
+                }
             }
-            fclose(file);
         }
     }
     
      // Clients duration
     if (fMeasuredClient > 0) {
-        file = fopen("Timing5.plot", "w");
+        std::ofstream fStream5("Timing5.plot", std::ios_base::ate);
 
-        if (file == NULL) {
+        if (!fStream5.is_open()) {
             jack_error("JackEngineProfiling::Save cannot open Timing5.log file");
         } else {
         
-            fprintf(file, "set multiplot\n");
-            fprintf(file, "set grid\n");
-            fprintf(file, "set title \"Clients duration\"\n");
-            fprintf(file, "set xlabel \"audio cycles\"\n");
-            fprintf(file, "set ylabel \"usec\"\n");
-            fprintf(file, "plot ");
+            fStream5 << "set multiplot\n";
+            fStream5 << "set grid\n";
+            fStream5 << "set title \"Clients duration\"\n";
+            fStream5 << "set xlabel \"audio cycles\"\n";
+            fStream5 << "set ylabel \"usec\"\n";
+            fStream5 << "plot ";
             for (unsigned int i = 0; i < fMeasuredClient; i++) {
-                if ((i + 1) == fMeasuredClient) // Last client
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines", ((i + 1) * 7) + 1, fIntervalTable[i].fName);
-                else
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", ((i + 1) * 7) + 1, fIntervalTable[i].fName);
-                fprintf(file, buffer);
+                if ((i + 1) == fMeasuredClient) { // Last client
+                    fStream5 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) + 1  << " title \"" << fIntervalTable[i].fName << "\" with lines";
+                } else {
+                    fStream5 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) + 1  << " title \"" << fIntervalTable[i].fName << "\" with lines,";
+                }
             }
             
-            fprintf(file, "\n unset multiplot\n");  
-            fprintf(file, "set output 'Timing5.pdf\n");
-            fprintf(file, "set terminal pdf\n");
+            fStream5 << "\n unset multiplot\n";  
+            fStream5 << "set output 'Timing5.pdf\n";
+            fStream5 << "set terminal pdf\n";
             
-            fprintf(file, "set multiplot\n");
-            fprintf(file, "set grid\n");
-            fprintf(file, "set title \"Clients duration\"\n");
-            fprintf(file, "set xlabel \"audio cycles\"\n");
-            fprintf(file, "set ylabel \"usec\"\n");
-            fprintf(file, "plot ");
+            fStream5 << "set multiplot\n";
+            fStream5 << "set grid\n";
+            fStream5 << "set title \"Clients duration\"\n";
+            fStream5 << "set xlabel \"audio cycles\"\n";
+            fStream5 << "set ylabel \"usec\"\n";
+            fStream5 << "plot ";
             for (unsigned int i = 0; i < fMeasuredClient; i++) {
-                if ((i + 1) == fMeasuredClient) // Last client
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines", ((i + 1) * 7) + 1, fIntervalTable[i].fName);
-                else
-                    sprintf(buffer, "\"JackEngineProfiling.log\" using %d title \"%s\" with lines,", ((i + 1) * 7) + 1, fIntervalTable[i].fName);
-                fprintf(file, buffer);
+                if ((i + 1) == fMeasuredClient) {// Last client
+                    fStream5 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) + 1  << " title \"" << fIntervalTable[i].fName << "\" with lines";
+                } else {
+                    fStream5 << "\"JackEngineProfiling.log\" using " << ((i + 1) * 7) + 1  << " title \"" << fIntervalTable[i].fName << "\" with lines,";
+                }
             }
-            fclose(file);
         }
     }
 }
diff --git a/common/JackException.h b/common/JackException.h
index 3270f20..58a9a23 100644
--- a/common/JackException.h
+++ b/common/JackException.h
@@ -76,6 +76,24 @@ class SERVER_EXPORT JackTemporaryException : public JackException {
 };
     
 /*!
+ \brief 
+ */
+
+class SERVER_EXPORT JackQuitException : public JackException {
+    
+    public:
+        
+        JackQuitException(const std::string& msg) : JackException(msg)
+        {}
+        JackQuitException(char* msg) : JackException(msg)
+        {}
+        JackQuitException(const char* msg) : JackException(msg)
+        {}
+        JackQuitException() : JackException("")
+        {}
+};
+    
+/*!
 \brief Exception possibly thrown by Net slaves.
 */
 
diff --git a/common/JackGlobals.cpp b/common/JackGlobals.cpp
index c8c4054..2314c84 100644
--- a/common/JackGlobals.cpp
+++ b/common/JackGlobals.cpp
@@ -37,5 +37,28 @@ JackClient* JackGlobals::fClientTable[CLIENT_NUM] = {};
 #ifndef WIN32
 jack_thread_creator_t JackGlobals::fJackThreadCreator = pthread_create;
 #endif
+    
+#ifdef __CLIENTDEBUG__
+std::ofstream* JackGlobals::fStream = NULL;
+
+void JackGlobals::CheckContext(const char* name)
+{
+    if (JackGlobals::fStream == NULL) {
+        char provstr[256];
+        char buffer[256];
+        time_t curtime;
+        struct tm *loctime;
+        /* Get the current time. */
+        curtime = time (NULL);
+        /* Convert it to local time representation. */
+        loctime = localtime (&curtime);
+        strftime (buffer, 256, "%I-%M", loctime);
+        sprintf(provstr, "JackAPICall-%s.log", buffer);
+        JackGlobals::fStream = new std::ofstream(provstr, std::ios_base::ate);
+        JackGlobals::fStream->is_open();
+    }
+    (*fStream) << "JACK API call : " << name << ", calling thread : " << pthread_self() << std::endl;
+}
+#endif    
 
 } // end of namespace
diff --git a/common/JackGlobals.h b/common/JackGlobals.h
index 7586708..63dc9ab 100644
--- a/common/JackGlobals.h
+++ b/common/JackGlobals.h
@@ -23,6 +23,13 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "JackPlatformPlug.h"
 #include "JackConstants.h"
 
+#ifdef __CLIENTDEBUG__ 
+#include <iostream>
+#include <fstream>
+#include <string>
+#include <time.h>
+#endif 
+
 namespace Jack
 {
 
@@ -38,6 +45,11 @@ struct JackGlobals {
 #ifndef WIN32
     static jack_thread_creator_t fJackThreadCreator;
 #endif
+    
+#ifdef __CLIENTDEBUG__
+    static std::ofstream* fStream;
+    static void CheckContext(const char* name);
+#endif
 };
 
 // Each "side" server and client will implement this to get the shared graph manager, engine control and inter-process synchro table.
diff --git a/common/JackGraphManager.cpp b/common/JackGraphManager.cpp
index d16becd..36e2943 100644
--- a/common/JackGraphManager.cpp
+++ b/common/JackGraphManager.cpp
@@ -29,13 +29,6 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 namespace Jack
 {
 
-static void AssertPort(jack_port_id_t port_index)
-{
-    if (port_index >= PORT_NUM) {
-        jack_log("JackGraphManager::AssertPort port_index = %ld", port_index);
-        assert(port_index < PORT_NUM);
-    }
-}
 
 static void AssertBufferSize(jack_nframes_t buffer_size)
 {
@@ -44,7 +37,40 @@ static void AssertBufferSize(jack_nframes_t buffer_size)
         assert(buffer_size <= BUFFER_SIZE_MAX);
     }
 }
+  
+void JackGraphManager::AssertPort(jack_port_id_t port_index)
+{
+    if (port_index >= fPortMax) {
+        jack_log("JackGraphManager::AssertPort port_index = %ld", port_index);
+        assert(port_index < fPortMax);
+    }
+}
+    
+JackGraphManager* JackGraphManager::Allocate(int port_max)
+{
+    // Using "Placement" new
+    void* shared_ptr = JackShmMem::operator new(sizeof(JackGraphManager) + port_max * sizeof(JackPort));
+    return new(shared_ptr) JackGraphManager(port_max);
+}
 
+void JackGraphManager::Destroy(JackGraphManager* manager)
+{
+    // "Placement" new was used
+    manager->~JackGraphManager();
+    JackShmMem::operator delete(manager);
+}
+    
+JackGraphManager::JackGraphManager(int port_max) 
+{
+    assert(port_max <= PORT_NUM_MAX);
+    
+    for (int i = 0; i < port_max; i++) {
+        fPortArray[i].Release();
+    }
+            
+    fPortMax = port_max;
+}
+        
 JackPort* JackGraphManager::GetPort(jack_port_id_t port_index)
 {
     AssertPort(port_index);
@@ -262,7 +288,7 @@ int JackGraphManager::ComputeTotalLatency(jack_port_id_t port_index)
 int JackGraphManager::ComputeTotalLatencies()
 {
     jack_port_id_t port_index;
-    for (port_index = FIRST_AVAILABLE_PORT; port_index < PORT_NUM; port_index++) {
+    for (port_index = FIRST_AVAILABLE_PORT; port_index < fPortMax; port_index++) {
         JackPort* port = GetPort(port_index);
         if (port->IsUsed())
             ComputeTotalLatency(port_index);
@@ -276,7 +302,7 @@ void JackGraphManager::SetBufferSize(jack_nframes_t buffer_size)
     jack_log("JackGraphManager::SetBufferSize size = %ld", buffer_size);
 
     jack_port_id_t port_index;
-    for (port_index = FIRST_AVAILABLE_PORT; port_index < PORT_NUM; port_index++) {
+    for (port_index = FIRST_AVAILABLE_PORT; port_index < fPortMax; port_index++) {
         JackPort* port = GetPort(port_index);
         if (port->IsUsed())
             port->ClearBuffer(buffer_size);
@@ -289,7 +315,7 @@ jack_port_id_t JackGraphManager::AllocatePortAux(int refnum, const char* port_na
     jack_port_id_t port_index;
 
     // Available ports start at FIRST_AVAILABLE_PORT (= 1), otherwise a port_index of 0 is "seen" as a NULL port by the external API...
-    for (port_index = FIRST_AVAILABLE_PORT; port_index < PORT_NUM; port_index++) {
+    for (port_index = FIRST_AVAILABLE_PORT; port_index < fPortMax; port_index++) {
         JackPort* port = GetPort(port_index);
         if (!port->IsUsed()) {
             jack_log("JackGraphManager::AllocatePortAux port_index = %ld name = %s type = %s", port_index, port_name, port_type);
@@ -299,7 +325,7 @@ jack_port_id_t JackGraphManager::AllocatePortAux(int refnum, const char* port_na
         }
     }
 
-    return (port_index < PORT_NUM) ? port_index : NO_PORT;
+    return (port_index < fPortMax) ? port_index : NO_PORT;
 }
 
 // Server
@@ -350,6 +376,18 @@ int JackGraphManager::ReleasePort(int refnum, jack_port_id_t port_index)
     return res;
 }
 
+void JackGraphManager::ActivatePort(jack_port_id_t port_index)
+{
+    JackPort* port = GetPort(port_index);
+    port->fFlags = (JackPortFlags)(port->fFlags | JackPortIsActive);
+}
+
+void JackGraphManager::DeactivatePort(jack_port_id_t port_index)
+{
+    JackPort* port = GetPort(port_index);
+    port->fFlags = (JackPortFlags)(port->fFlags | ~JackPortIsActive);
+}
+
 void JackGraphManager::GetInputPorts(int refnum, jack_int_t* res)
 {
     JackConnectionManager* manager = WriteNextStateStart();
@@ -424,7 +462,7 @@ void JackGraphManager::DisconnectAllInput(jack_port_id_t port_index)
     jack_log("JackGraphManager::DisconnectAllInput port_index = %ld", port_index);
     JackConnectionManager* manager = WriteNextStateStart();
 
-    for (int i = 0; i < PORT_NUM; i++) {
+    for (unsigned int i = 0; i < fPortMax; i++) {
         if (manager->IsConnected(i, port_index)) {
             jack_log("JackGraphManager::Disconnect i = %ld  port_index = %ld", i, port_index);
             Disconnect(i, port_index);
@@ -661,7 +699,7 @@ int JackGraphManager::GetTwoPorts(const char* src_name, const char* dst_name, ja
 // Client : port array
 jack_port_id_t JackGraphManager::GetPort(const char* name)
 {
-    for (int i = 0; i < PORT_NUM; i++) {
+    for (unsigned int i = 0; i < fPortMax; i++) {
         JackPort* port = GetPort(i);
         if (port->IsUsed() && port->NameEquals(name))
             return i;
@@ -734,9 +772,9 @@ void JackGraphManager::GetPortsAux(const char** matching_ports, const char* port
     }
 
     // Cleanup port array
-    memset(matching_ports, 0, sizeof(char*) * PORT_NUM);
+    memset(matching_ports, 0, sizeof(char*) * fPortMax);
 
-    for (int i = 0; i < PORT_NUM; i++) {
+    for (unsigned int i = 0; i < fPortMax; i++) {
         bool matching = true;
         JackPort* port = GetPort(i);
 
@@ -783,7 +821,7 @@ void JackGraphManager::GetPortsAux(const char** matching_ports, const char* port
 */
 const char** JackGraphManager::GetPorts(const char* port_name_pattern, const char* type_name_pattern, unsigned long flags)
 {
-    const char** res = (const char**)malloc(sizeof(char*) * PORT_NUM);
+    const char** res = (const char**)malloc(sizeof(char*) * fPortMax);
     UInt16 cur_index, next_index;
     
     if (!res)
diff --git a/common/JackGraphManager.h b/common/JackGraphManager.h
index 0fdd3c8..93b09ff 100644
--- a/common/JackGraphManager.h
+++ b/common/JackGraphManager.h
@@ -42,9 +42,11 @@ class SERVER_EXPORT JackGraphManager : public JackShmMem, public JackAtomicState
 
     private:
 
-		JackPort fPortArray[PORT_NUM];
+        unsigned int fPortMax;
         JackClientTiming fClientTiming[CLIENT_NUM];
+        JackPort fPortArray[0];    // The actual size depends of port_max, it will be dynamically computed and allocated using "placement" new
 
+        void AssertPort(jack_port_id_t port_index);
         jack_port_id_t AllocatePortAux(int refnum, const char* port_name, const char* port_type, JackPortFlags flags);
         void GetConnectionsAux(JackConnectionManager* manager, const char** res, jack_port_id_t port_index);
         void GetPortsAux(const char** matching_ports, const char* port_name_pattern, const char* type_name_pattern, unsigned long flags);
@@ -54,8 +56,7 @@ class SERVER_EXPORT JackGraphManager : public JackShmMem, public JackAtomicState
 
     public:
 
-        JackGraphManager()
-        {}
+        JackGraphManager(int port_max);
         ~JackGraphManager()
         {}
 
@@ -64,6 +65,8 @@ class SERVER_EXPORT JackGraphManager : public JackShmMem, public JackAtomicState
         // Ports management
         jack_port_id_t AllocatePort(int refnum, const char* port_name, const char* port_type, JackPortFlags flags, jack_nframes_t buffer_size);
         int ReleasePort(int refnum, jack_port_id_t port_index);
+        void ActivatePort(jack_port_id_t port_index);
+        void DeactivatePort(jack_port_id_t port_index);
         void GetInputPorts(int refnum, jack_int_t* res);
         void GetOutputPorts(int refnum, jack_int_t* res);
         void RemoveAllPorts(int refnum);
@@ -74,7 +77,7 @@ class SERVER_EXPORT JackGraphManager : public JackShmMem, public JackAtomicState
         int ComputeTotalLatency(jack_port_id_t port_index);
         int ComputeTotalLatencies();
         int RequestMonitor(jack_port_id_t port_index, bool onoff);
-
+   
         // Connections management
         int Connect(jack_port_id_t src_index, jack_port_id_t dst_index);
         int Disconnect(jack_port_id_t src_index, jack_port_id_t dst_index);
@@ -127,6 +130,9 @@ class SERVER_EXPORT JackGraphManager : public JackShmMem, public JackAtomicState
 
         void Save(JackConnectionManager* dst);
         void Restore(JackConnectionManager* src);
+    
+        static JackGraphManager* Allocate(int port_max);
+        static void Destroy(JackGraphManager* manager);
 
 } POST_PACKED_STRUCTURE;
 
diff --git a/common/JackLibAPI.cpp b/common/JackLibAPI.cpp
index b2cce06..45649c2 100644
--- a/common/JackLibAPI.cpp
+++ b/common/JackLibAPI.cpp
@@ -112,6 +112,9 @@ EXPORT jack_client_t* jack_client_open_aux(const char* client_name, jack_options
 EXPORT jack_client_t* jack_client_open(const char* ext_client_name, jack_options_t options, jack_status_t* status, ...)
 {
     try {
+#ifdef __CLIENTDEBUG__
+        JackGlobals::CheckContext("jack_client_open");
+#endif
         assert(JackGlobals::fOpenMutex);
         JackGlobals::fOpenMutex->Lock();
         va_list ap;
@@ -131,6 +134,9 @@ EXPORT jack_client_t* jack_client_open(const char* ext_client_name, jack_options
 
 EXPORT int jack_client_close(jack_client_t* ext_client)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_close");
+#endif
     assert(JackGlobals::fOpenMutex);
     JackGlobals::fOpenMutex->Lock();
     int res = -1;
diff --git a/common/JackLibClient.cpp b/common/JackLibClient.cpp
index 4c92e9e..effdfc6 100644
--- a/common/JackLibClient.cpp
+++ b/common/JackLibClient.cpp
@@ -103,6 +103,9 @@ int JackLibClient::Open(const char* server_name, const char* name, jack_options_
     } catch (int n) {
         jack_error("Map shared memory segments exception %d", n);
         goto error;
+    } catch (...) {
+        jack_error("Unknown error...");
+        goto error;
     }
 
     SetupDriverSync(false);
diff --git a/common/JackLibGlobals.h b/common/JackLibGlobals.h
index f109b66..5ef8b9e 100644
--- a/common/JackLibGlobals.h
+++ b/common/JackLibGlobals.h
@@ -31,6 +31,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "JackError.h"
 #include <assert.h>
 #include <signal.h>
+ 
 
 namespace Jack
 {
@@ -123,13 +124,6 @@ struct JackLibGlobals
         }
     }
 
-    static void CheckContext()
-    {
-        if (!(fClientCount > 0 && fGlobals)) {
-            jack_error("Error !!! : client accessing an already desallocated library context");
-        }
-    }
-
 };
 
 } // end of namespace
diff --git a/common/JackLockedEngine.h b/common/JackLockedEngine.h
index c2de851..fe646e9 100644
--- a/common/JackLockedEngine.h
+++ b/common/JackLockedEngine.h
@@ -31,6 +31,15 @@ namespace Jack
 #define TRY_CALL    \
     try {           \
 
+/*
+See : http://groups.google.com/group/comp.programming.threads/browse_thread/thread/652bcf186fbbf697/f63757846514e5e5
+
+catch (...) {
+    // Assuming thread cancellation, must rethrow
+    throw;
+}
+*/
+
 #define CATCH_EXCEPTION_RETURN                      \
     } catch(std::bad_alloc& e) {                    \
         jack_error("Memory allocation error...");   \
@@ -41,21 +50,23 @@ namespace Jack
         return -1;                                  \
     } catch (...) {                                 \
         jack_error("Unknown error...");             \
-        return -1;                                  \
+        throw;                                      \
     }                                               \
 
-#define CATCH_ENGINE_EXCEPTION                      \
+#define CATCH_EXCEPTION                      \
     } catch(std::bad_alloc& e) {                    \
         jack_error("Memory allocation error...");   \
     } catch (...) {                                 \
         jack_error("Unknown error...");             \
+        throw;                                      \
     }                                               \
 
+
 /*!
 \brief Locked Engine, access to methods is serialized using a mutex.
 */
 
-class SERVER_EXPORT JackLockedEngine : public JackLockAble
+class SERVER_EXPORT JackLockedEngine 
 {
     private:
 
@@ -63,8 +74,8 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
 
     public:
 
-        JackLockedEngine(JackGraphManager* manager, JackSynchro* table, JackEngineControl* controler):
-            fEngine(manager, table, controler)
+        JackLockedEngine(JackGraphManager* manager, JackSynchro* table, JackEngineControl* controler, JackSelfConnectMode self_connect_mode):
+            fEngine(manager, table, controler, self_connect_mode)
         {}
         ~JackLockedEngine()
         {}
@@ -83,26 +94,26 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
             return fEngine.Close();
             CATCH_EXCEPTION_RETURN
         }
-
+    
         // Client management
         int ClientCheck(const char* name, char* name_res, int protocol, int options, int* status)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.ClientCheck(name, name_res, protocol, options, status);
             CATCH_EXCEPTION_RETURN
         }
         int ClientExternalOpen(const char* name, int pid, int* ref, int* shared_engine, int* shared_client, int* shared_graph_manager)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.ClientExternalOpen(name, pid, ref, shared_engine, shared_client, shared_graph_manager);
             CATCH_EXCEPTION_RETURN
         }
         int ClientInternalOpen(const char* name, int* ref, JackEngineControl** shared_engine, JackGraphManager** shared_manager, JackClientInterface* client, bool wait)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.ClientInternalOpen(name, ref, shared_engine, shared_manager, client, wait);
             CATCH_EXCEPTION_RETURN
         }
@@ -110,30 +121,30 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
         int ClientExternalClose(int refnum)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.ClientExternalClose(refnum);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.ClientExternalClose(refnum) : - 1;
             CATCH_EXCEPTION_RETURN
         }
         int ClientInternalClose(int refnum, bool wait)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.ClientInternalClose(refnum, wait);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.ClientInternalClose(refnum, wait) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
         int ClientActivate(int refnum, bool is_real_time)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.ClientActivate(refnum, is_real_time);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.ClientActivate(refnum, is_real_time) : -1;
             CATCH_EXCEPTION_RETURN
         }
         int ClientDeactivate(int refnum)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.ClientDeactivate(refnum);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.ClientDeactivate(refnum) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
@@ -141,22 +152,22 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
         int GetInternalClientName(int int_ref, char* name_res)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.GetInternalClientName(int_ref, name_res);
             CATCH_EXCEPTION_RETURN
         }
         int InternalClientHandle(const char* client_name, int* status, int* int_ref)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.InternalClientHandle(client_name, status, int_ref);
             CATCH_EXCEPTION_RETURN
         }
         int InternalClientUnload(int refnum, int* status)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.InternalClientUnload(refnum, status);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.InternalClientUnload(refnum, status) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
@@ -164,53 +175,53 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
         int PortRegister(int refnum, const char* name, const char *type, unsigned int flags, unsigned int buffer_size, jack_port_id_t* port)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortRegister(refnum, name, type, flags, buffer_size, port);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortRegister(refnum, name, type, flags, buffer_size, port) : -1;
             CATCH_EXCEPTION_RETURN
         }
         int PortUnRegister(int refnum, jack_port_id_t port)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortUnRegister(refnum, port);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortUnRegister(refnum, port) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
         int PortConnect(int refnum, const char* src, const char* dst)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortConnect(refnum, src, dst);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortConnect(refnum, src, dst) : -1;
             CATCH_EXCEPTION_RETURN
         }
         int PortDisconnect(int refnum, const char* src, const char* dst)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortDisconnect(refnum, src, dst);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortDisconnect(refnum, src, dst) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
         int PortConnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortConnect(refnum, src, dst);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortConnect(refnum, src, dst) : -1;
             CATCH_EXCEPTION_RETURN
         }
         int PortDisconnect(int refnum, jack_port_id_t src, jack_port_id_t dst)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortDisconnect(refnum, src, dst);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortDisconnect(refnum, src, dst) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
         int PortRename(int refnum, jack_port_id_t port, const char* name)
         {
             TRY_CALL
-            JackLock lock(this);
-            return fEngine.PortRename(refnum, port, name);
+            JackLock lock(&fEngine);
+            return (fEngine.CheckClient(refnum)) ? fEngine.PortRename(refnum, port, name) : -1;
             CATCH_EXCEPTION_RETURN
         }
 
@@ -230,52 +241,51 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
 
         void NotifyXRun(int refnum)
         {
-            TRY_CALL
-            JackLock lock(this);
+            // RT : no lock
             fEngine.NotifyXRun(refnum);
-            CATCH_ENGINE_EXCEPTION
         }
+        
         void NotifyGraphReorder()
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             fEngine.NotifyGraphReorder();
-            CATCH_ENGINE_EXCEPTION
+            CATCH_EXCEPTION
         }
         void NotifyBufferSize(jack_nframes_t buffer_size)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             fEngine.NotifyBufferSize(buffer_size);
-            CATCH_ENGINE_EXCEPTION
+            CATCH_EXCEPTION
         }
         void NotifySampleRate(jack_nframes_t sample_rate)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             fEngine.NotifySampleRate(sample_rate);
-            CATCH_ENGINE_EXCEPTION
+            CATCH_EXCEPTION
         }
         void NotifyFreewheel(bool onoff)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             fEngine.NotifyFreewheel(onoff);
-            CATCH_ENGINE_EXCEPTION
+            CATCH_EXCEPTION
         }
 
         void NotifyFailure(int code, const char* reason)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             fEngine.NotifyFailure(code, reason);
-            CATCH_ENGINE_EXCEPTION
+            CATCH_EXCEPTION
         }
 
         int GetClientPID(const char* name)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.GetClientPID(name);
             CATCH_EXCEPTION_RETURN
         }
@@ -283,11 +293,19 @@ class SERVER_EXPORT JackLockedEngine : public JackLockAble
         int GetClientRefNum(const char* name)
         {
             TRY_CALL
-            JackLock lock(this);
+            JackLock lock(&fEngine);
             return fEngine.GetClientRefNum(name);
             CATCH_EXCEPTION_RETURN
         }
-
+    
+        void NotifyQuit()
+        {
+            TRY_CALL
+            JackLock lock(&fEngine);
+            return fEngine.NotifyQuit();
+            CATCH_EXCEPTION
+        }
+ 
 };
 
 } // end of namespace
diff --git a/common/JackMessageBuffer.cpp b/common/JackMessageBuffer.cpp
index 8dacfe6..b9f2846 100644
--- a/common/JackMessageBuffer.cpp
+++ b/common/JackMessageBuffer.cpp
@@ -29,7 +29,7 @@ namespace Jack
 JackMessageBuffer* JackMessageBuffer::fInstance = NULL;
 
 JackMessageBuffer::JackMessageBuffer()
-    :fThread(this),fInBuffer(0),fOutBuffer(0),fOverruns(0),fRunning(false)
+    :fInit(NULL),fInitArg(NULL),fThread(this),fInBuffer(0),fOutBuffer(0),fOverruns(0),fRunning(false)
 {}
 
 JackMessageBuffer::~JackMessageBuffer()
@@ -82,6 +82,15 @@ bool JackMessageBuffer::Execute()
     while (fRunning) {
         fGuard.Lock();
         fGuard.Wait();
+        /* the client asked for all threads to run a thread
+        initialization callback, which includes us.
+        */
+        if (fInit) {
+            fInit(fInitArg);
+            fInit = NULL;
+            /* and we're done */
+            fGuard.Signal();
+        }
         Flush();
         fGuard.Unlock();
     }
@@ -115,5 +124,20 @@ void JackMessageBufferAdd(int level, const char *message)
     }
 }
 
+void JackMessageBuffer::SetInitCallback(JackThreadInitCallback callback, void *arg)
+{
+    fGuard.Lock();
+    /* set up the callback */
+    fInitArg = arg;
+    fInit = callback;
+    /* wake msg buffer thread */
+    fGuard.Signal();
+    /* wait for it to be done */
+    fGuard.Wait();
+    /* and we're done */
+    fGuard.Unlock();
+}
+    
+
 };
 
diff --git a/common/JackMessageBuffer.h b/common/JackMessageBuffer.h
index 5e3472a..ec13a5d 100644
--- a/common/JackMessageBuffer.h
+++ b/common/JackMessageBuffer.h
@@ -57,6 +57,8 @@ class JackMessageBuffer : public JackRunnableInterface
 
     private:
     
+        JackThreadInitCallback fInit;
+        void* fInitArg;
         JackMessage fBuffers[MB_BUFFERS];
         JackThread fThread;
         JackProcessSync fGuard;
@@ -82,6 +84,7 @@ class JackMessageBuffer : public JackRunnableInterface
 	    void static Destroy();
 
         void AddMessage(int level, const char *message);
+        void SetInitCallback(JackThreadInitCallback callback, void *arg);
 
 	    static JackMessageBuffer* fInstance;
 };
diff --git a/common/JackMidiDriver.cpp b/common/JackMidiDriver.cpp
index b5bfd4c..4ddf417 100644
--- a/common/JackMidiDriver.cpp
+++ b/common/JackMidiDriver.cpp
@@ -74,7 +74,6 @@ int JackMidiDriver::Attach()
     jack_port_id_t port_index;
     char name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
     char alias[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
-    unsigned long port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
     int i;
 
     jack_log("JackMidiDriver::Attach fBufferSize = %ld fSampleRate = %ld", fEngineControl->fBufferSize, fEngineControl->fSampleRate);
@@ -82,7 +81,7 @@ int JackMidiDriver::Attach()
     for (i = 0; i < fCaptureChannels; i++) {
         snprintf(alias, sizeof(alias) - 1, "%s:%s:out%d", fAliasName, fCaptureDriverName, i + 1);
         snprintf(name, sizeof(name) - 1, "%s:capture_%d", fClientControl.fName, i + 1);
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, CaptureDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
@@ -92,12 +91,10 @@ int JackMidiDriver::Attach()
         jack_log("JackMidiDriver::Attach fCapturePortList[i] port_index = %ld", port_index);
     }
 
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     for (i = 0; i < fPlaybackChannels; i++) {
         snprintf(alias, sizeof(alias) - 1, "%s:%s:in%d", fAliasName, fPlaybackDriverName, i + 1);
         snprintf(name, sizeof(name) - 1, "%s:playback_%d", fClientControl.fName, i + 1);
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, PlaybackDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
diff --git a/common/JackMutex.h b/common/JackMutex.h
index e2472ad..0a2600d 100644
--- a/common/JackMutex.h
+++ b/common/JackMutex.h
@@ -36,11 +36,9 @@ namespace Jack
 class JackLockAble
 {
 
-    private:
-
-        JackMutex fMutex;
-
     protected:
+    
+        JackMutex fMutex;
 
         JackLockAble()
         {}
diff --git a/common/JackNetInterface.cpp b/common/JackNetInterface.cpp
index 5131c98..b794e8b 100644
--- a/common/JackNetInterface.cpp
+++ b/common/JackNetInterface.cpp
@@ -227,6 +227,7 @@ namespace Jack
         do
         {
             session_params_t net_params;
+            memset(&net_params, 0, sizeof ( session_params_t ));
             SetPacketType ( &fParams, SLAVE_SETUP );
             SessionParamsHToN(&fParams, &net_params);
             
@@ -316,6 +317,7 @@ namespace Jack
         JackNetSocket mcast_socket ( fMulticastIP, fSocket.GetPort() );
         
         session_params_t net_params;
+        memset(&net_params, 0, sizeof ( session_params_t ));
         SessionParamsHToN(&fParams, &net_params);
 
         if ( mcast_socket.NewSocket() == SOCKET_ERROR )
@@ -706,6 +708,7 @@ namespace Jack
         {
             //send 'available'
             session_params_t net_params;
+            memset(&net_params, 0, sizeof ( session_params_t ));
             SessionParamsHToN(&fParams, &net_params);
             if ( fSocket.SendTo ( &net_params, sizeof ( session_params_t ), 0, fMulticastIP ) == SOCKET_ERROR )
                 jack_error ( "Error in data send : %s", StrError ( NET_ERROR_CODE ) );
@@ -746,6 +749,7 @@ namespace Jack
 
         //tell the master to start
         session_params_t net_params;
+        memset(&net_params, 0, sizeof ( session_params_t ));
         SetPacketType ( &fParams, START_MASTER );
         SessionParamsHToN(&fParams, &net_params);
         if ( fSocket.Send ( &net_params, sizeof ( session_params_t ), 0 ) == SOCKET_ERROR )
diff --git a/common/JackNetOneDriver.cpp b/common/JackNetOneDriver.cpp
index bc0160b..5ee20a6 100644
--- a/common/JackNetOneDriver.cpp
+++ b/common/JackNetOneDriver.cpp
@@ -140,19 +140,15 @@ namespace Jack
 	jack_port_id_t port_id;
 	char buf[64];
 	unsigned int chn;
-	int port_flags;
-
 
 	//if (netj.handle_transport_sync)
 	//    jack_set_sync_callback(netj.client, (JackSyncCallback) net_driver_sync_cb, NULL);
 
-	port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
-
 	for (chn = 0; chn < netj.capture_channels_audio; chn++) {
 	    snprintf (buf, sizeof(buf) - 1, "system:capture_%u", chn + 1);
 
             if ( ( port_id = fGraphManager->AllocatePort ( fClientControl.fRefNum, buf, JACK_DEFAULT_AUDIO_TYPE,
-                             static_cast<JackPortFlags> ( port_flags ), fEngineControl->fBufferSize ) ) == NO_PORT )
+                             CaptureDriverFlags, fEngineControl->fBufferSize ) ) == NO_PORT )
             {
                 jack_error ( "driver: cannot register port for %s", buf );
                 return -1;
@@ -186,7 +182,7 @@ namespace Jack
 	    snprintf (buf, sizeof(buf) - 1, "system:capture_%u", chn + 1);
 
             if ( ( port_id = fGraphManager->AllocatePort ( fClientControl.fRefNum, buf, JACK_DEFAULT_MIDI_TYPE,
-                             static_cast<JackPortFlags> ( port_flags ), fEngineControl->fBufferSize ) ) == NO_PORT )
+                             CaptureDriverFlags, fEngineControl->fBufferSize ) ) == NO_PORT )
             {
                 jack_error ( "driver: cannot register port for %s", buf );
                 return -1;
@@ -197,13 +193,11 @@ namespace Jack
 		jack_slist_append (netj.capture_ports, (void *)(intptr_t)port_id);
 	}
 
-	port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
 	for (chn = 0; chn < netj.playback_channels_audio; chn++) {
 	    snprintf (buf, sizeof(buf) - 1, "system:playback_%u", chn + 1);
 
             if ( ( port_id = fGraphManager->AllocatePort ( fClientControl.fRefNum, buf, JACK_DEFAULT_AUDIO_TYPE,
-                             static_cast<JackPortFlags> ( port_flags ), fEngineControl->fBufferSize ) ) == NO_PORT )
+                             PlaybackDriverFlags, fEngineControl->fBufferSize ) ) == NO_PORT )
             {
                 jack_error ( "driver: cannot register port for %s", buf );
                 return -1;
@@ -233,7 +227,7 @@ namespace Jack
 	    snprintf (buf, sizeof(buf) - 1, "system:playback_%u", chn + 1);
 
             if ( ( port_id = fGraphManager->AllocatePort ( fClientControl.fRefNum, buf, JACK_DEFAULT_MIDI_TYPE,
-                             static_cast<JackPortFlags> ( port_flags ), fEngineControl->fBufferSize ) ) == NO_PORT )
+                             PlaybackDriverFlags, fEngineControl->fBufferSize ) ) == NO_PORT )
             {
                 jack_error ( "driver: cannot register port for %s", buf );
                 return -1;
diff --git a/common/JackNotification.h b/common/JackNotification.h
index 43611a4..be0c89f 100644
--- a/common/JackNotification.h
+++ b/common/JackNotification.h
@@ -44,6 +44,7 @@ enum NotificationType {
     kPortRenameCallback = 13,
     kRealTimeCallback = 14,
     kShutDownCallback = 15,
+    kQUIT = 16,
     kMaxNotification
 };
 
diff --git a/common/JackPhysicalMidiInput.cpp b/common/JackPhysicalMidiInput.cpp
new file mode 100644
index 0000000..311dad0
--- /dev/null
+++ b/common/JackPhysicalMidiInput.cpp
@@ -0,0 +1,287 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#include <cassert>
+#include <cstring>
+#include <new>
+
+#include "JackError.h"
+#include "JackPhysicalMidiInput.h"
+
+namespace Jack {
+
+JackPhysicalMidiInput::JackPhysicalMidiInput(size_t buffer_size)
+{
+    size_t datum_size = sizeof(jack_midi_data_t);
+    assert(buffer_size > 0);
+    input_ring = jack_ringbuffer_create((buffer_size + 1) * datum_size);
+    if (! input_ring) {
+        throw std::bad_alloc();
+    }
+    jack_ringbuffer_mlock(input_ring);
+    Clear();
+    expected_data_bytes = 0;
+    status_byte = 0;
+}
+
+JackPhysicalMidiInput::~JackPhysicalMidiInput()
+{
+    jack_ringbuffer_free(input_ring);
+}
+
+void
+JackPhysicalMidiInput::Clear()
+{
+    jack_ringbuffer_reset(input_ring);
+    buffered_bytes = 0;
+    unbuffered_bytes = 0;
+}
+
+void
+JackPhysicalMidiInput::HandleBufferFailure(size_t unbuffered_bytes,
+                                           size_t total_bytes)
+{
+    jack_error("%d MIDI byte(s) of a %d byte message could not be buffered - "
+               "message dropped", unbuffered_bytes, total_bytes);
+}
+
+void
+JackPhysicalMidiInput::HandleIncompleteMessage(size_t bytes)
+{
+    jack_error("Discarding %d MIDI byte(s) - incomplete message (cable "
+               "unplugged?)", bytes);
+}
+
+void
+JackPhysicalMidiInput::HandleInvalidStatusByte(jack_midi_data_t status)
+{
+    jack_error("Dropping invalid MIDI status byte '%x'",
+               (unsigned int) status);
+}
+
+void
+JackPhysicalMidiInput::HandleUnexpectedSysexEnd(size_t bytes)
+{
+    jack_error("Discarding %d MIDI byte(s) - received sysex end without sysex "
+               "start (cable unplugged?)", bytes);
+}
+
+void
+JackPhysicalMidiInput::HandleWriteFailure(size_t bytes)
+{
+    jack_error("Failed to write a %d byte MIDI message to the port buffer",
+               bytes);
+}
+
+void
+JackPhysicalMidiInput::Process(jack_nframes_t frames)
+{
+    assert(port_buffer);
+    port_buffer->Reset(frames);
+    jack_nframes_t current_frame = 0;
+    size_t datum_size = sizeof(jack_midi_data_t);
+    for (;;) {
+        jack_midi_data_t datum;
+        current_frame = Receive(&datum, current_frame, frames);
+        if (current_frame >= frames) {
+            break;
+        }
+
+        jack_log("JackPhysicalMidiInput::Process (%d) - Received '%x' byte",
+                 current_frame, (unsigned int) datum);
+
+        if (datum >= 0xf8) {
+            // Realtime
+            if (datum == 0xfd) {
+                HandleInvalidStatusByte(datum);
+            } else {
+
+                jack_log("JackPhysicalMidiInput::Process - Writing realtime "
+                         "event.");
+
+                WriteByteEvent(current_frame, datum);
+            }
+            continue;
+        }
+        if (datum == 0xf7) {
+            // Sysex end
+            if (status_byte != 0xf0) {
+                HandleUnexpectedSysexEnd(buffered_bytes + unbuffered_bytes);
+                Clear();
+                expected_data_bytes = 0;
+                status_byte = 0;
+            } else {
+
+                jack_log("JackPhysicalMidiInput::Process - Writing sysex "
+                         "event.");
+
+                WriteBufferedSysexEvent(current_frame);
+            }
+            continue;
+        }
+        if (datum >= 0x80) {
+
+            // We're handling a non-realtime status byte
+
+            jack_log("JackPhysicalMidiInput::Process - Handling non-realtime "
+                     "status byte.");
+
+            if (buffered_bytes || unbuffered_bytes) {
+                HandleIncompleteMessage(buffered_bytes + unbuffered_bytes + 1);
+                Clear();
+            }
+            status_byte = datum;
+            switch (datum & 0xf0) {
+            case 0x80:
+            case 0x90:
+            case 0xa0:
+            case 0xb0:
+            case 0xe0:
+                // Note On, Note Off, Aftertouch, Control Change, Pitch Wheel
+                expected_data_bytes = 2;
+                break;
+            case 0xc0:
+            case 0xd0:
+                // Program Change, Channel Pressure
+                expected_data_bytes = 1;
+                break;
+            case 0xf0:
+                switch (datum) {
+                case 0xf0:
+                    // Sysex message
+                    expected_data_bytes = 0;
+                    break;
+                case 0xf1:
+                case 0xf3:
+                    // MTC Quarter frame, Song Select
+                    expected_data_bytes = 1;
+                    break;
+                case 0xf2:
+                    // Song Position
+                    expected_data_bytes = 2;
+                    break;
+                case 0xf4:
+                case 0xf5:
+                    // Undefined
+                    HandleInvalidStatusByte(datum);
+                    expected_data_bytes = 0;
+                    status_byte = 0;
+                    break;
+                case 0xf6:
+                    // Tune Request
+                    WriteByteEvent(current_frame, datum);
+                    expected_data_bytes = 0;
+                    status_byte = 0;
+                }
+                break;
+            }
+            continue;
+        }
+
+        // We're handling a data byte
+
+        jack_log("JackPhysicalMidiInput::Process - Buffering data byte.");
+
+        if (jack_ringbuffer_write(input_ring, (const char *) &datum,
+                                  datum_size) == datum_size) {
+            buffered_bytes++;
+        } else {
+            unbuffered_bytes++;
+        }
+        unsigned long total_bytes = buffered_bytes + unbuffered_bytes;
+        assert((! expected_data_bytes) ||
+               (total_bytes <= expected_data_bytes));
+        if (total_bytes == expected_data_bytes) {
+            if (! unbuffered_bytes) {
+
+                jack_log("JackPhysicalMidiInput::Process - Writing buffered "
+                         "event.");
+
+                WriteBufferedEvent(current_frame);
+            } else {
+                HandleBufferFailure(unbuffered_bytes, total_bytes);
+                Clear();
+            }
+            if (status_byte >= 0xf0) {
+                expected_data_bytes = 0;
+                status_byte = 0;
+            }
+        }
+    }
+}
+
+void
+JackPhysicalMidiInput::WriteBufferedEvent(jack_nframes_t frame)
+{
+    assert(port_buffer && port_buffer->IsValid());
+    size_t space = jack_ringbuffer_read_space(input_ring);
+    jack_midi_data_t *event = port_buffer->ReserveEvent(frame, space + 1);
+    if (event) {
+        jack_ringbuffer_data_t vector[2];
+        jack_ringbuffer_get_read_vector(input_ring, vector);
+        event[0] = status_byte;
+        size_t data_length_1 = vector[0].len;
+        memcpy(event + 1, vector[0].buf, data_length_1);
+        size_t data_length_2 = vector[1].len;
+        if (data_length_2) {
+            memcpy(event + data_length_1 + 1, vector[1].buf, data_length_2);
+        }
+    } else {
+        HandleWriteFailure(space + 1);
+    }
+    Clear();
+}
+
+void
+JackPhysicalMidiInput::WriteBufferedSysexEvent(jack_nframes_t frame)
+{
+    assert(port_buffer && port_buffer->IsValid());
+    size_t space = jack_ringbuffer_read_space(input_ring);
+    jack_midi_data_t *event = port_buffer->ReserveEvent(frame, space + 2);
+    if (event) {
+        jack_ringbuffer_data_t vector[2];
+        jack_ringbuffer_get_read_vector(input_ring, vector);
+        event[0] = status_byte;
+        size_t data_length_1 = vector[0].len;
+        memcpy(event + 1, vector[0].buf, data_length_1);
+        size_t data_length_2 = vector[1].len;
+        if (data_length_2) {
+            memcpy(event + data_length_1 + 1, vector[1].buf, data_length_2);
+        }
+        event[data_length_1 + data_length_2 + 1] = 0xf7;
+    } else {
+        HandleWriteFailure(space + 2);
+    }
+    Clear();
+}
+
+void
+JackPhysicalMidiInput::WriteByteEvent(jack_nframes_t frame,
+                                      jack_midi_data_t datum)
+{
+    assert(port_buffer && port_buffer->IsValid());
+    jack_midi_data_t *event = port_buffer->ReserveEvent(frame, 1);
+    if (event) {
+        event[0] = datum;
+    } else {
+        HandleWriteFailure(1);
+    }
+}
+
+}
diff --git a/common/JackPhysicalMidiInput.h b/common/JackPhysicalMidiInput.h
new file mode 100644
index 0000000..6ba3b47
--- /dev/null
+++ b/common/JackPhysicalMidiInput.h
@@ -0,0 +1,146 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#ifndef __JackPhysicalMidiInput__
+#define __JackPhysicalMidiInput__
+
+#include "JackMidiPort.h"
+#include "ringbuffer.h"
+
+namespace Jack {
+
+    class JackPhysicalMidiInput {
+
+    private:
+
+        size_t buffered_bytes;
+        size_t expected_data_bytes;
+        jack_ringbuffer_t *input_ring;
+        JackMidiBuffer *port_buffer;
+        jack_midi_data_t status_byte;
+        size_t unbuffered_bytes;
+
+        void
+        Clear();
+
+        void
+        WriteBufferedEvent(jack_nframes_t);
+
+        void
+        WriteBufferedSysexEvent(jack_nframes_t);
+
+        void
+        WriteByteEvent(jack_nframes_t, jack_midi_data_t);
+
+    protected:
+
+        /**
+         * Override to specify how to react when 1 or more bytes of a MIDI
+         * message are lost because there wasn't enough room in the input
+         * buffer.  The first argument is the amount of bytes that couldn't be
+         * buffered, and the second argument is the total amount of bytes in
+         * the MIDI message.  The default implementation calls 'jack_error'
+         * with a basic error message.
+         */
+
+        virtual void
+        HandleBufferFailure(size_t, size_t);
+
+        /**
+         * Override to specify how to react when a new status byte is received
+         * before all of the data bytes in a message are received.  The
+         * argument is the number of bytes being discarded.  The default
+         * implementation calls 'jack_error' with a basic error message.
+         */
+
+        virtual void
+        HandleIncompleteMessage(size_t);
+
+        /**
+         * Override to specify how to react when an invalid status byte (0xf4,
+         * 0xf5, 0xfd) is received.  The argument contains the invalid status
+         * byte.  The default implementation calls 'jack_error' with a basic
+         * error message.
+         */
+
+        virtual void
+        HandleInvalidStatusByte(jack_midi_data_t);
+
+        /**
+         * Override to specify how to react when a sysex end byte (0xf7) is
+         * received without first receiving a sysex start byte (0xf0).  The
+         * argument contains the amount of bytes that will be discarded.  The
+         * default implementation calls 'jack_error' with a basic error
+         * message.
+         */
+
+        virtual void
+        HandleUnexpectedSysexEnd(size_t);
+
+        /**
+         * Override to specify how to react when a MIDI message can not be
+         * written to the port buffer.  The argument specifies the length of
+         * the MIDI message.  The default implementation calls 'jack_error'
+         * with a basic error message.
+         */
+
+        virtual void
+        HandleWriteFailure(size_t);
+
+        /**
+         * This method *must* be overridden to handle receiving MIDI bytes.
+         * The first argument is a pointer to the memory location at which the
+         * MIDI byte should be stored.  The second argument is the last frame
+         * at which a MIDI byte was received, except at the beginning of the
+         * period when the value is 0.  The third argument is the total number
+         * of frames in the period.  The return value is the frame at which the
+         * MIDI byte is received at, or the value of the third argument is no
+         * more MIDI bytes can be received in this period.
+         */
+
+        virtual jack_nframes_t
+        Receive(jack_midi_data_t *, jack_nframes_t, jack_nframes_t) = 0;
+
+    public:
+
+        JackPhysicalMidiInput(size_t buffer_size=1024);
+        ~JackPhysicalMidiInput();
+
+        /**
+         * Called to process MIDI data during a period.
+         */
+
+        void
+        Process(jack_nframes_t);
+
+        /**
+         * Set the MIDI buffer that will receive incoming messages.
+         */
+
+        inline void
+        SetPortBuffer(JackMidiBuffer *port_buffer)
+        {
+            this->port_buffer = port_buffer;
+        }
+
+    };
+
+}
+
+#endif
diff --git a/common/JackPhysicalMidiOutput.cpp b/common/JackPhysicalMidiOutput.cpp
new file mode 100644
index 0000000..8f41d44
--- /dev/null
+++ b/common/JackPhysicalMidiOutput.cpp
@@ -0,0 +1,320 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#include <cassert>
+
+#include "JackError.h"
+#include "JackPhysicalMidiOutput.h"
+
+namespace Jack {
+
+JackPhysicalMidiOutput::JackPhysicalMidiOutput(size_t non_rt_buffer_size,
+                                               size_t rt_buffer_size)
+{
+    size_t datum_size = sizeof(jack_midi_data_t);
+    assert(non_rt_buffer_size > 0);
+    assert(rt_buffer_size > 0);
+    output_ring = jack_ringbuffer_create((non_rt_buffer_size + 1) *
+                                         datum_size);
+    if (! output_ring) {
+        throw std::bad_alloc();
+    }
+    rt_output_ring = jack_ringbuffer_create((rt_buffer_size + 1) *
+                                            datum_size);
+    if (! rt_output_ring) {
+        jack_ringbuffer_free(output_ring);
+        throw std::bad_alloc();
+    }
+    jack_ringbuffer_mlock(output_ring);
+    jack_ringbuffer_mlock(rt_output_ring);
+    running_status = 0;
+}
+
+JackPhysicalMidiOutput::~JackPhysicalMidiOutput()
+{
+    jack_ringbuffer_free(output_ring);
+    jack_ringbuffer_free(rt_output_ring);
+}
+
+jack_nframes_t
+JackPhysicalMidiOutput::Advance(jack_nframes_t frame)
+{
+    return frame;
+}
+
+inline jack_midi_data_t
+JackPhysicalMidiOutput::ApplyRunningStatus(jack_midi_data_t **buffer,
+                                           size_t *size)
+{
+
+    // Stolen and modified from alsa/midi_pack.h
+
+    jack_midi_data_t status = (*buffer)[0];
+    if ((status >= 0x80) && (status < 0xf0)) {
+        if (status == running_status) {
+            (*buffer)++;
+            (*size)--;
+        } else {
+            running_status = status;
+        }
+    } else if (status < 0xf8) {
+        running_status = 0;
+    }
+    return status;
+}
+
+void
+JackPhysicalMidiOutput::HandleEventLoss(JackMidiEvent *event)
+{
+    jack_error("%d byte MIDI event lost", event->size);
+}
+
+void
+JackPhysicalMidiOutput::Process(jack_nframes_t frames)
+{
+    assert(port_buffer);
+    jack_nframes_t current_frame = Advance(0);
+    jack_nframes_t current_midi_event = 0;
+    jack_midi_data_t datum;
+    size_t datum_size = sizeof(jack_midi_data_t);
+    JackMidiEvent *midi_event;
+    jack_midi_data_t *midi_event_buffer;
+    size_t midi_event_size;
+    jack_nframes_t midi_events = port_buffer->event_count;
+
+    // First, send any realtime MIDI data that's left from last cycle.
+
+    if ((current_frame < frames) &&
+        jack_ringbuffer_read_space(rt_output_ring)) {
+
+        jack_log("JackPhysicalMidiOutput::Process (%d) - Sending buffered "
+                 "realtime data from last period.", current_frame);
+
+        current_frame = SendBufferedData(rt_output_ring, current_frame,
+                                         frames);
+
+        jack_log("JackPhysicalMidiOutput::Process (%d) - Sent", current_frame);
+
+    }
+
+    // Iterate through the events in this cycle.
+
+    for (; (current_midi_event < midi_events) && (current_frame < frames);
+         current_midi_event++) {
+
+        // Once we're inside this loop, we know that the realtime buffer
+        // is empty.  As long as we don't find a realtime message, we can
+        // concentrate on sending non-realtime data.
+
+        midi_event = &(port_buffer->events[current_midi_event]);
+        jack_nframes_t midi_event_time = midi_event->time;
+        midi_event_buffer = midi_event->GetData(port_buffer);
+        midi_event_size = midi_event->size;
+        datum = ApplyRunningStatus(&midi_event_buffer, &midi_event_size);
+        if (current_frame < midi_event_time) {
+
+            // We have time before this event is scheduled to be sent.
+            // Send data in the non-realtime buffer.
+
+            if (jack_ringbuffer_read_space(output_ring)) {
+
+                jack_log("JackPhysicalMidiOutput::Process (%d) - Sending "
+                         "buffered non-realtime data from last period.",
+                         current_frame);
+
+                current_frame = SendBufferedData(output_ring, current_frame,
+                                                 midi_event_time);
+
+                jack_log("JackPhysicalMidiOutput::Process (%d) - Sent",
+                         current_frame);
+
+            }
+            if (current_frame < midi_event_time) {
+
+                // We _still_ have time before this event is scheduled to
+                // be sent.  Let's send as much of this event as we can
+                // (save for one byte, which will need to be sent at or
+                // after its scheduled time).  First though, we need to
+                // make sure that we can buffer this data if we need to.
+                // Otherwise, we might start sending a message that we
+                // can't finish.
+
+                if (midi_event_size > 1) {
+                    if (jack_ringbuffer_write_space(output_ring) <
+                        ((midi_event_size - 1) * datum_size)) {
+                        HandleEventLoss(midi_event);
+                        continue;
+                    }
+
+                    // Send as much of the event as possible (save for one
+                    // byte).
+
+                    do {
+
+                        jack_log("JackPhysicalMidiOutput::Process (%d) - "
+                                 "Sending unbuffered event byte early.",
+                                 current_frame);
+
+                        current_frame = Send(current_frame,
+                                             *midi_event_buffer);
+
+                        jack_log("JackPhysicalMidiOutput::Process (%d) - "
+                                 "Sent.", current_frame);
+
+                        midi_event_buffer++;
+                        midi_event_size--;
+                        if (current_frame >= midi_event_time) {
+
+                            // The event we're processing must be a
+                            // non-realtime event.  It has more than one
+                            // byte.
+
+                            goto buffer_non_realtime_data;
+                        }
+                    } while (midi_event_size > 1);
+                }
+
+                jack_log("JackPhysicalMidiOutput::Process (%d) - Advancing to "
+                         ">= %d", current_frame, midi_event_time);
+
+                current_frame = Advance(midi_event_time);
+
+                jack_log("JackPhysicalMidiOutput::Process (%d) - Advanced.",
+                         current_frame);
+
+            }
+        }
+
+        // If the event is realtime, then we'll send the event now.
+        // Otherwise, we attempt to put the rest of the event bytes in the
+        // non-realtime buffer.
+
+        if (datum >= 0xf8) {
+
+            jack_log("JackPhysicalMidiOutput::Process (%d) - Sending "
+                     "unbuffered realtime event.", current_frame);
+
+            current_frame = Send(current_frame, datum);
+
+            jack_log("JackPhysicalMidiOutput::Process (%d) - Sent.",
+                     current_frame);
+
+        } else if (jack_ringbuffer_write_space(output_ring) >=
+                   (midi_event_size * datum_size)) {
+        buffer_non_realtime_data:
+
+            jack_log("JackPhysicalMidiOutput::Process (%d) - Buffering %d "
+                     "byte(s) of non-realtime data.", current_frame,
+                     midi_event_size);
+
+            jack_ringbuffer_write(output_ring,
+                                  (const char *) midi_event_buffer,
+                                  midi_event_size);
+        } else {
+            HandleEventLoss(midi_event);
+        }
+    }
+
+    if (current_frame < frames) {
+
+        // If we have time left to send data, then we know that all of the
+        // data in the realtime buffer has been sent, and that all of the
+        // non-realtime messages have either been sent, or buffered.  We
+        // use whatever time is left to send data in the non-realtime
+        // buffer.
+
+        if (jack_ringbuffer_read_space(output_ring)) {
+
+            jack_log("JackPhysicalMidiOutput::Process (%d) - All events "
+                     "processed.  Sending buffered non-realtime data.",
+                     current_frame);
+
+            current_frame = SendBufferedData(output_ring, current_frame,
+                                             frames);
+
+            jack_log("JackPhysicalMidiOutput::Process (%d) - Sent.",
+                     current_frame);
+
+        }
+    } else {
+
+        // Since we have no time left, we need to put all remaining midi
+        // events in their appropriate buffers, and send them next period.
+
+        for (; current_midi_event < midi_events; current_midi_event++) {
+            midi_event = &(port_buffer->events[current_midi_event]);
+            midi_event_buffer = midi_event->GetData(port_buffer);
+            midi_event_size = midi_event->size;
+            datum = ApplyRunningStatus(&midi_event_buffer, &midi_event_size);
+            if (datum >= 0xf8) {
+
+                // Realtime.
+
+                if (jack_ringbuffer_write_space(rt_output_ring) >=
+                    datum_size) {
+
+                    jack_log("JackPhysicalMidiOutput::Process - Buffering "
+                             "realtime event for next period.");
+
+                    jack_ringbuffer_write(rt_output_ring,
+                                          (const char *) &datum, datum_size);
+                    continue;
+                }
+            } else {
+
+                // Non-realtime.
+
+                if (jack_ringbuffer_write_space(output_ring) >=
+                    (midi_event_size * datum_size)) {
+
+                    jack_log("JackPhysicalMidiOutput::Process - Buffering "
+                             "non-realtime event for next period.");
+
+                    jack_ringbuffer_write(output_ring,
+                                          (const char *) midi_event_buffer,
+                                          midi_event_size * datum_size);
+                    continue;
+                }
+            }
+            HandleEventLoss(midi_event);
+        }
+    }
+}
+
+jack_nframes_t
+JackPhysicalMidiOutput::SendBufferedData(jack_ringbuffer_t *buffer,
+                                         jack_nframes_t current_frame,
+                                         jack_nframes_t boundary)
+{
+    assert(buffer);
+    assert(current_frame < boundary);
+    size_t datum_size = sizeof(jack_midi_data_t);
+    size_t data_length = jack_ringbuffer_read_space(buffer) / datum_size;
+    for (size_t i = 0; i < data_length; i++) {
+        jack_midi_data_t datum;
+        jack_ringbuffer_read(buffer, (char *) &datum, datum_size);
+        current_frame = Send(current_frame, datum);
+        if (current_frame >= boundary) {
+            break;
+        }
+    }
+    return current_frame;
+}
+
+}
diff --git a/common/JackPhysicalMidiOutput.h b/common/JackPhysicalMidiOutput.h
new file mode 100644
index 0000000..f76a233
--- /dev/null
+++ b/common/JackPhysicalMidiOutput.h
@@ -0,0 +1,118 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#ifndef __JackPhysicalMidiOutput__
+#define __JackPhysicalMidiOutput__
+
+#include "JackMidiPort.h"
+#include "ringbuffer.h"
+
+namespace Jack {
+
+    class JackPhysicalMidiOutput {
+
+    private:
+
+        jack_midi_data_t
+        ApplyRunningStatus(jack_midi_data_t **, size_t *);
+
+        jack_ringbuffer_t *output_ring;
+        JackMidiBuffer *port_buffer;
+        jack_ringbuffer_t *rt_output_ring;
+        jack_midi_data_t running_status;
+
+    protected:
+
+        /**
+         * Override to specify the next frame at which a midi byte can be sent.
+         * The returned frame must be greater than or equal to the frame
+         * argument.  The default returns the frame passed to it.
+         */
+
+        virtual jack_nframes_t
+        Advance(jack_nframes_t);
+
+        /**
+         * Override to customize how to react when a MIDI event can't be
+         * buffered and can't be sent immediately.  The default calls
+         * 'jack_error' and specifies the number of bytes lost.
+         */
+
+        virtual void
+        HandleEventLoss(JackMidiEvent *);
+
+        /**
+         * This method *must* be overridden to specify what happens when a MIDI
+         * byte is sent at the specfied frame.  The frame argument specifies
+         * the frame at which the MIDI byte should be sent, and the second
+         * argument specifies the byte itself. The return value is the next
+         * frame at which a MIDI byte can be sent, and must be greater than or
+         * equal to the frame argument.
+         */
+
+        virtual jack_nframes_t
+        Send(jack_nframes_t, jack_midi_data_t) = 0;
+
+        /**
+         * Override to optimize behavior when sending MIDI data that's in the
+         * ringbuffer.  The first frame argument is the current frame, and the
+         * second frame argument is the boundary frame.  The function returns
+         * the next frame at which MIDI data can be sent, regardless of whether
+         * or not the boundary is reached.  The default implementation calls
+         * 'Send' with each byte in the ringbuffer until either the ringbuffer
+         * is empty, or a frame beyond the boundary frame is returned by
+         * 'Send'.
+         */
+
+        virtual jack_nframes_t
+        SendBufferedData(jack_ringbuffer_t *, jack_nframes_t, jack_nframes_t);
+
+    public:
+
+        /**
+         * The non-realtime buffer size and the realtime buffer size are both
+         * optional arguments.
+         */
+
+        JackPhysicalMidiOutput(size_t non_rt_buffer_size=1024,
+                               size_t rt_buffer_size=64);
+        ~JackPhysicalMidiOutput();
+
+        /**
+         * Called to process MIDI data during a period.
+         */
+
+        void
+        Process(jack_nframes_t);
+
+        /**
+         * Set the MIDI buffer that will contain the outgoing MIDI messages.
+         */
+
+        inline void
+        SetPortBuffer(JackMidiBuffer *port_buffer)
+        {
+            this->port_buffer = port_buffer;
+        }
+
+    };
+
+}
+
+#endif
diff --git a/common/JackPort.cpp b/common/JackPort.cpp
index 42b5fb2..f8c62d6 100644
--- a/common/JackPort.cpp
+++ b/common/JackPort.cpp
@@ -28,15 +28,9 @@ namespace Jack
 {
 
 JackPort::JackPort()
-        : fTypeId(0),
-        fFlags(JackPortIsInput), 
-        fRefNum( -1), 
-        fLatency(0), 
-        fTotalLatency(0), 
-        fMonitorRequests(0), 
-        fInUse(false), 
-        fTied(NO_PORT)
-{}
+{
+    Release();
+}
 
 bool JackPort::Allocate(int refnum, const char* port_name, const char* port_type, JackPortFlags flags)
 {
@@ -68,6 +62,7 @@ void JackPort::Release()
     fInUse = false;
     fLatency = 0;
     fTotalLatency = 0;
+    fMonitorRequests = 0;
     fTied = NO_PORT;
     fAlias1[0] = '\0';
     fAlias2[0] = '\0';
diff --git a/common/JackServer.cpp b/common/JackServer.cpp
index a260b47..848a09f 100644
--- a/common/JackServer.cpp
+++ b/common/JackServer.cpp
@@ -38,17 +38,17 @@ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 namespace Jack
 {
 
-JackServer::JackServer(bool sync, bool temporary, long timeout, bool rt, long priority, bool verbose, jack_timer_type_t clock, const char* server_name)
+JackServer::JackServer(bool sync, bool temporary, int timeout, bool rt, int priority, int port_max, bool verbose, jack_timer_type_t clock, JackSelfConnectMode self_connect_mode, const char* server_name)
 {
     if (rt) {
         jack_info("JACK server starting in realtime mode with priority %ld", priority);
     } else {
         jack_info("JACK server starting in non-realtime mode");
     }
-
-    fGraphManager = new JackGraphManager();
+    
+    fGraphManager = JackGraphManager::Allocate(port_max);
     fEngineControl = new JackEngineControl(sync, temporary, timeout, rt, priority, verbose, clock, server_name);
-    fEngine = new JackLockedEngine(fGraphManager, GetSynchroTable(), fEngineControl);
+    fEngine = new JackLockedEngine(fGraphManager, GetSynchroTable(), fEngineControl, self_connect_mode);
     fFreewheelDriver = new JackThreadedDriver(new JackFreewheelDriver(fEngine, GetSynchroTable()));
     fDriverInfo = new JackDriverInfo();
     fAudioDriver = NULL;
@@ -60,7 +60,7 @@ JackServer::JackServer(bool sync, bool temporary, long timeout, bool rt, long pr
 
 JackServer::~JackServer()
 {
-    delete fGraphManager;
+    JackGraphManager::Destroy(fGraphManager);
     delete fAudioDriver;
     delete fDriverInfo;
     delete fFreewheelDriver;
@@ -125,6 +125,7 @@ fail_close1:
 int JackServer::Close()
 {
     jack_log("JackServer::Close");
+    fEngine->NotifyQuit();
     fChannel.Close();
     fAudioDriver->Detach();
     fAudioDriver->Close();
diff --git a/common/JackServer.h b/common/JackServer.h
index 325237d..4b3b65d 100644
--- a/common/JackServer.h
+++ b/common/JackServer.h
@@ -62,7 +62,7 @@ class SERVER_EXPORT JackServer
 
     public:
 
-        JackServer(bool sync, bool temporary, long timeout, bool rt, long priority, bool verbose, jack_timer_type_t clock, const char* server_name);
+        JackServer(bool sync, bool temporary, int timeout, bool rt, int priority, int port_max, bool verbose, jack_timer_type_t clock, JackSelfConnectMode self_connect_mode, const char* server_name);
         ~JackServer();
 
         int Open(jack_driver_desc_t* driver_desc, JSList* driver_params);
diff --git a/common/JackServerAPI.cpp b/common/JackServerAPI.cpp
index e8e6c02..a9755fe 100644
--- a/common/JackServerAPI.cpp
+++ b/common/JackServerAPI.cpp
@@ -105,6 +105,9 @@ EXPORT jack_client_t* jack_client_open_aux(const char* client_name, jack_options
 
 EXPORT jack_client_t* jack_client_open(const char* ext_client_name, jack_options_t options, jack_status_t* status, ...)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_open");
+#endif
     try {
         assert(JackGlobals::fOpenMutex);
         JackGlobals::fOpenMutex->Lock();
@@ -125,6 +128,9 @@ EXPORT jack_client_t* jack_client_open(const char* ext_client_name, jack_options
 
 EXPORT int jack_client_close(jack_client_t* ext_client)
 {
+#ifdef __CLIENTDEBUG__
+    JackGlobals::CheckContext("jack_client_close");
+#endif    
     assert(JackGlobals::fOpenMutex);
     JackGlobals::fOpenMutex->Lock();
     int res = -1;
diff --git a/common/JackServerGlobals.cpp b/common/JackServerGlobals.cpp
index 7698c64..831a2d2 100644
--- a/common/JackServerGlobals.cpp
+++ b/common/JackServerGlobals.cpp
@@ -41,11 +41,13 @@ int JackServerGlobals::Start(const char* server_name,
                              int time_out_ms,
                              int rt,
                              int priority,
+                             int port_max,
                              int verbose,
-                            jack_timer_type_t clock)
+                             jack_timer_type_t clock,
+                             JackSelfConnectMode self_connect_mode)
 {
     jack_log("Jackdmp: sync = %ld timeout = %ld rt = %ld priority = %ld verbose = %ld ", sync, time_out_ms, rt, priority, verbose);
-    new JackServer(sync, temporary, time_out_ms, rt, priority, verbose, clock, server_name);  // Will setup fInstance and fUserCount globals
+    new JackServer(sync, temporary, time_out_ms, rt, priority, port_max, verbose, clock, self_connect_mode, server_name);  // Will setup fInstance and fUserCount globals
     int res = fInstance->Open(driver_desc, driver_params);
     return (res < 0) ? res : fInstance->Start();
 }
@@ -291,7 +293,7 @@ bool JackServerGlobals::Init()
             free(argv[i]);
         }
 
-        int res = Start(server_name, driver_desc, driver_params, sync, temporary, client_timeout, realtime, realtime_priority, verbose_aux, clock_source);
+        int res = Start(server_name, driver_desc, driver_params, sync, temporary, client_timeout, realtime, realtime_priority, port_max, verbose_aux, clock_source, JACK_DEFAULT_SELF_CONNECT_MODE);
         if (res < 0) {
             jack_error("Cannot start server... exit");
             Delete();
diff --git a/common/JackServerGlobals.h b/common/JackServerGlobals.h
index 00d8b0f..2ae093d 100644
--- a/common/JackServerGlobals.h
+++ b/common/JackServerGlobals.h
@@ -54,8 +54,10 @@ struct SERVER_EXPORT JackServerGlobals
                      int time_out_ms,
                      int rt,
                      int priority,
+                     int port_max,
                      int verbose,
-                    jack_timer_type_t clock);
+                     jack_timer_type_t clock,
+                     JackSelfConnectMode self_connect_mode);
     static void Stop();
     static void Delete();
 };
diff --git a/common/JackTypes.h b/common/JackTypes.h
index 234be17..433fe93 100644
--- a/common/JackTypes.h
+++ b/common/JackTypes.h
@@ -49,4 +49,14 @@ typedef enum {
     Finished,
 } jack_client_state_t;
 
+
+enum JackSelfConnectMode
+{
+    JackSelfConnectAllow,
+    JackSelfConnectFailExternalOnly,
+    JackSelfConnectIgnoreExternalOnly,
+    JackSelfConnectFailAll,
+    JackSelfConnectIgnoreAll,
+};
+
 #endif
diff --git a/common/Jackdmp.cpp b/common/Jackdmp.cpp
index ddf978c..fe7fda2 100644
--- a/common/Jackdmp.cpp
+++ b/common/Jackdmp.cpp
@@ -100,6 +100,7 @@ static void usage(FILE* file)
             "               [ --name OR -n server-name ]\n"
             "               [ --timeout OR -t client-timeout-in-msecs ]\n"
             "               [ --loopback OR -L loopback-port-number ]\n"
+            "               [ --port-max OR -p maximum-number-of-ports]\n"
             "               [ --midi OR -X midi-driver ]\n"
             "               [ --verbose OR -v ]\n"
 #ifdef __linux__
@@ -118,7 +119,7 @@ static void usage(FILE* file)
             "               Available backends may include: portaudio, dummy or net.\n\n"
 #endif 
 #ifdef __linux__
-            "               Available backends may include: alsa, dummy, freebob, firewire, net, oss or sun.\n\n"
+            "               Available backends may include: alsa, dummy, freebob, firewire or net\n\n"
 #endif
 #if defined(__sun__) || defined(sun)
             "               Available backends may include: boomer, oss, dummy or net.\n\n"
@@ -179,6 +180,7 @@ int main(int argc, char* argv[])
     int replace_registry = 0;
     
     const char *options = "-d:X:P:uvshVrRL:STFl:t:mn:p:"
+        "a:"
 #ifdef __linux__
         "c:"
 #endif
@@ -207,6 +209,7 @@ int main(int argc, char* argv[])
                                        { "version", 0, 0, 'V' },
                                        { "silent", 0, 0, 's' },
                                        { "sync", 0, 0, 'S' },
+                                       { "autoconnect", 1, 0, 'a' },
                                        { 0, 0, 0, 0 }
                                    };
 
@@ -220,7 +223,6 @@ int main(int argc, char* argv[])
     char *midi_driver_name = NULL;
     char **midi_driver_args = NULL;
     int midi_driver_nargs = 1;
-    int port_max = 512;
     int do_mlock = 1;
     int do_unlock = 0;
     int loopback = 0;
@@ -276,6 +278,26 @@ int main(int argc, char* argv[])
                 break;
         #endif
 
+            case 'a':
+                param = jackctl_get_parameter(server_parameters, "self-connect-mode");
+                if (param != NULL) {
+                    bool value_valid = false;
+                    for (int k=0; k<jackctl_parameter_get_enum_constraints_count( param ); k++ ) {
+                        value = jackctl_parameter_get_enum_constraint_value( param, k );
+                        if( value.c == optarg[0] )
+                            value_valid = true;
+                    }
+
+                    if( value_valid ) {
+                        value.c = optarg[0];
+                        jackctl_parameter_set_value(param, &value);
+                    } else {
+                        usage(stdout);
+                        goto fail_free1;
+                    }
+                }
+                break;
+
             case 'd':
                 seen_audio_driver = true;
                 audio_driver_name = optarg;
@@ -291,7 +313,11 @@ int main(int argc, char* argv[])
                 break;
 
             case 'p':
-                port_max = (unsigned int)atol(optarg);
+                param = jackctl_get_parameter(server_parameters, "port-max");
+                if (param != NULL) {
+                    value.ui = atoi(optarg);
+                    jackctl_parameter_set_value(param, &value);
+                }
                 break;
 
             case 'm':
@@ -408,7 +434,7 @@ int main(int argc, char* argv[])
     // Audio driver
     audio_driver_ctl = jackctl_server_get_driver(server_ctl, audio_driver_name);
     if (audio_driver_ctl == NULL) {
-        fprintf(stderr, "Unkown driver \"%s\"\n", audio_driver_name);
+        fprintf(stderr, "Unknown driver \"%s\"\n", audio_driver_name);
         goto fail_free1;
     }
 
@@ -446,7 +472,7 @@ int main(int argc, char* argv[])
 
         midi_driver_ctl = jackctl_server_get_driver(server_ctl, midi_driver_name);
         if (midi_driver_ctl == NULL) {
-            fprintf(stderr, "Unkown driver \"%s\"\n", midi_driver_name);
+            fprintf(stderr, "Unknown driver \"%s\"\n", midi_driver_name);
             goto fail_free2;
         }
 
diff --git a/common/jack/jack.h b/common/jack/jack.h
index a5dc3ae..74c8b3c 100644
--- a/common/jack/jack.h
+++ b/common/jack/jack.h
@@ -48,7 +48,8 @@ extern "C"
    require linker arguments in the client as well.
 */
 #define JACK_WEAK_EXPORT __attribute__((weak))
-#else
+#else
+#define JACK_WEAK_EXPORT
 /* Add other things here for non-gcc platforms */
 #endif
 #endif
@@ -430,8 +431,8 @@ int jack_set_sample_rate_callback (jack_client_t *client,
                                    void *arg);
 
 /**
- * Tell the JACK server to call @a registration_callback whenever a
- * port is registered or unregistered, passing @a arg as a parameter.
+ * Tell the JACK server to call @a client_registration_callback whenever a
+ * client is registered or unregistered, passing @a arg as a parameter.
  *
  * All "notification events" are received in a seperated non RT thread,
  * the code in the supplied function does not need to be
diff --git a/common/jack/types.h b/common/jack/types.h
index fd71cea..3722d7f 100644
--- a/common/jack/types.h
+++ b/common/jack/types.h
@@ -202,7 +202,7 @@ typedef void (*JackPortConnectCallback)(jack_port_id_t a, jack_port_id_t b, int
  *
  * @return zero on success, non-zero on error
  */
-typedef int (*JackPortRenameCallback)(jack_port_id_t port, const char* new_name, void *arg);
+typedef int (*JackPortRenameCallback)(jack_port_id_t port, const char* old_name, const char* new_name, void *arg);
 
 /**
  * Prototype for the client supplied function that is called
@@ -295,7 +295,15 @@ enum JackPortFlags {
      * systems are examples of clients that would set this flag for
      * their ports.
      */
-    JackPortIsTerminal = 0x10
+    JackPortIsTerminal = 0x10,
+    
+    /**
+     * JackPortIsActive means the port has been registered and the 
+     * client is "active", that is jack_activate has been called
+     * 
+     * JackPortIsActive is on between jack_activate and jack_deactivate.
+     */
+    JackPortIsActive = 0x20
 };
 
 /**
diff --git a/common/netjack_packet.c b/common/netjack_packet.c
index 4edbb2a..17a9b92 100644
--- a/common/netjack_packet.c
+++ b/common/netjack_packet.c
@@ -50,6 +50,7 @@
 
 #ifdef WIN32
 #include <winsock2.h>
+#define socklen_t int
 #include <malloc.h>
 #else
 #include <sys/socket.h>
diff --git a/common/ringbuffer.c b/common/ringbuffer.c
index f209663..b60000c 100644
--- a/common/ringbuffer.c
+++ b/common/ringbuffer.c
@@ -400,4 +400,5 @@ jack_ringbuffer_get_write_vector (const jack_ringbuffer_t * rb,
 		vec[0].len = free_cnt;
 		vec[1].len = 0;
 	}
-}
\ No newline at end of file
+}
+
diff --git a/common/shm.c b/common/shm.c
index fdd3b15..e74a213 100644
--- a/common/shm.c
+++ b/common/shm.c
@@ -18,23 +18,23 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
-
-/* This module provides a set of abstract shared memory interfaces
- * with support using both System V and POSIX shared memory
- * implementations.  The code is divided into three sections:
- *
- *	- common (interface-independent) code
- *	- POSIX implementation
- *	- System V implementation
- *
- * The implementation used is determined by whether USE_POSIX_SHM was
- * set in the ./configure step.
- */
+
+/* This module provides a set of abstract shared memory interfaces
+ * with support using both System V and POSIX shared memory
+ * implementations.  The code is divided into three sections:
+ *
+ *	- common (interface-independent) code
+ *	- POSIX implementation
+ *	- System V implementation
+ *
+ * The implementation used is determined by whether USE_POSIX_SHM was
+ * set in the ./configure step.
+ */
 
 #include "JackConstants.h"
 
 #ifdef WIN32
-#include <process.h>
+#include <process.h>
 #include <stdio.h>
 #else
 
@@ -145,23 +145,22 @@ static int semid = -1;
 
 #ifdef WIN32
 
-static void
-semaphore_init () {}
+static int
+semaphore_init () {return 0;}
 
-static  void
-semaphore_add (int value) {}
+static  int
+semaphore_add (int value) {return 0;}
 
 #else
 /* all semaphore errors are fatal -- issue message, but do not return */
 static void
 semaphore_error (char *msg)
 {
-	jack_error ("Fatal JACK semaphore error: %s (%s)",
+	jack_error ("JACK semaphore error: %s (%s)",
 		    msg, strerror (errno));
-	abort ();
 }
 
-static void
+static int
 semaphore_init ()
 {
 	key_t semkey = JACK_SEMAPHORE_KEY;
@@ -180,21 +179,26 @@ semaphore_init ()
 			sbuf.sem_op = 1;
 			sbuf.sem_flg = 0;
 			if (semop(semid, &sbuf, 1) == -1) {
-				semaphore_error ("semop");
+                semaphore_error ("semop");
+                return -1;
 			}
 
 		} else if (errno == EEXIST) {
 			if ((semid = semget(semkey, 0, 0)) == -1) {
-				semaphore_error ("semget");
+                semaphore_error ("semget");
+                return -1;
 			}
 
 		} else {
-			semaphore_error ("semget creation");
+            semaphore_error ("semget creation");
+            return -1;
 		}
 	}
+
+    return 0;
 }
 
-static inline void
+static inline int
 semaphore_add (int value)
 {
 	struct sembuf sbuf;
@@ -202,20 +206,26 @@ semaphore_add (int value)
 	sbuf.sem_num = 0;
 	sbuf.sem_op = value;
 	sbuf.sem_flg = SEM_UNDO;
+
 	if (semop(semid, &sbuf, 1) == -1) {
 		semaphore_error ("semop");
+        return -1;
 	}
+
+    return 0;
 }
 
 #endif
 
-static void
+static int
 jack_shm_lock_registry (void)
 {
-	if (semid == -1)
-		semaphore_init ();
+	if (semid == -1) {
+        if (semaphore_init () < 0)
+            return -1;
+    }
 
-	semaphore_add (-1);
+	return semaphore_add (-1);
 }
 
 static void
@@ -297,7 +307,10 @@ jack_server_initialize_shm (int new_registry)
 	if (jack_shm_header)
 		return 0;		/* already initialized */
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	rc = jack_access_registry (&registry_info);
 
@@ -353,7 +366,11 @@ jack_initialize_shm (const char *server_name)
 
 	jack_set_server_prefix (server_name);
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
+
 	if ((rc = jack_access_registry (&registry_info)) == 0) {
 		if ((rc = jack_shm_validate_registry ()) != 0) {
 			jack_error ("Incompatible shm registry, "
@@ -412,15 +429,20 @@ jack_release_shm_entry (jack_shm_registry_index_t index)
 		sizeof (jack_shm_registry[index].id));
 }
 
-void
+int
 jack_release_shm_info (jack_shm_registry_index_t index)
 {
 	/* must NOT have the registry locked */
 	if (jack_shm_registry[index].allocator == GetPID()) {
-		jack_shm_lock_registry ();
+		if (jack_shm_lock_registry () < 0) {
+            jack_error ("jack_shm_lock_registry fails...");
+            return -1;
+        }
 		jack_release_shm_entry (index);
 		jack_shm_unlock_registry ();
 	}
+
+    return 0;
 }
 
 /* Claim server_name for this process.
@@ -440,7 +462,10 @@ jack_register_server (const char *server_name, int new_registry)
 	if (jack_server_initialize_shm (new_registry))
 		return ENOMEM;
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	/* See if server_name already registered.  Since server names
 	 * are per-user, we register the unique server prefix string.
@@ -493,11 +518,14 @@ jack_register_server (const char *server_name, int new_registry)
 }
 
 /* release server_name registration */
-void
+int
 jack_unregister_server (const char *server_name /* unused */)
 {
 	int i;
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	for (i = 0; i < MAX_SERVERS; i++) {
 		if (jack_shm_header->server[i].pid == GetPID()) {
@@ -506,7 +534,8 @@ jack_unregister_server (const char *server_name /* unused */)
 		}
 	}
 
-	jack_shm_unlock_registry ();
+	jack_shm_unlock_registry ();
+	return 0;
 }
 
 /* called for server startup and termination */
@@ -517,7 +546,10 @@ jack_cleanup_shm ()
 	int destroy;
 	jack_shm_info_t copy;
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	for (i = 0; i < MAX_SHM_ID; i++) {
 		jack_shm_registry_t* r;
@@ -741,7 +773,10 @@ jack_shmalloc (const char *shm_name, jack_shmsize_t size, jack_shm_info_t* si)
 	int rc = -1;
 	char name[SHM_NAME_MAX+1];
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	if ((registry = jack_get_free_shm_info ()) == NULL) {
 		jack_error ("shm registry full");
@@ -780,7 +815,7 @@ jack_shmalloc (const char *shm_name, jack_shmsize_t size, jack_shm_info_t* si)
 	close (shm_fd);
 	registry->size = size;
 	strncpy (registry->id, name, sizeof (registry->id));
-	registry->allocator = getpid();
+	registry->allocator = GetPID();
 	si->index = registry->index;
 	si->ptr.attached_at = MAP_FAILED;	/* not attached */
 	rc = 0;				/* success */
@@ -936,7 +971,10 @@ jack_shmalloc (const char *shm_name, jack_shmsize_t size, jack_shm_info_t* si)
 	int rc = -1;
 	char name[SHM_NAME_MAX+1];
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	if ((registry = jack_get_free_shm_info ()) == NULL) {
 		jack_error ("shm registry full");
@@ -1133,7 +1171,10 @@ jack_shmalloc (const char* name_not_used, jack_shmsize_t size,
 	int rc = -1;
 	jack_shm_registry_t* registry;
 
-	jack_shm_lock_registry ();
+	if (jack_shm_lock_registry () < 0) {
+        jack_error ("jack_shm_lock_registry fails...");
+        return -1;
+    }
 
 	if ((registry = jack_get_free_shm_info ())) {
 
diff --git a/common/shm.h b/common/shm.h
index 4a7d15c..ed5a953 100644
--- a/common/shm.h
+++ b/common/shm.h
@@ -115,33 +115,33 @@ extern "C"
      * indicating where the shared memory has been
      * attached to the address space.
      */
-     
+
     typedef struct _jack_shm_info {
         jack_shm_registry_index_t index;       /* offset into the registry */
         uint32_t size;
         union {
             void *attached_at;  /* address where attached */
-            char ptr_size[8];   
-        } ptr;  /* a "pointer" that has the same 8 bytes size when compling in 32 or 64 bits */ 
+            char ptr_size[8];
+        } ptr;  /* a "pointer" that has the same 8 bytes size when compling in 32 or 64 bits */
     }
     POST_PACKED_STRUCTURE jack_shm_info_t;
 
     /* utility functions used only within JACK */
-      
+
     void jack_shm_copy_from_registry (jack_shm_info_t*,
                 jack_shm_registry_index_t);
     void jack_shm_copy_to_registry (jack_shm_info_t*,
                                                jack_shm_registry_index_t*);
-    void jack_release_shm_info (jack_shm_registry_index_t);
-    char* jack_shm_addr (jack_shm_info_t* si);  
+    int jack_release_shm_info (jack_shm_registry_index_t);
+    char* jack_shm_addr (jack_shm_info_t* si);
 
-    // here begin the API 
+    // here begin the API
     int jack_register_server (const char *server_name, int new_registry);
-    void jack_unregister_server (const char *server_name);
+    int jack_unregister_server (const char *server_name);
 
     int jack_initialize_shm (const char *server_name);
-    int jack_initialize_shm_server (void); 
-    int jack_initialize_shm_client (void);  
+    int jack_initialize_shm_server (void);
+    int jack_initialize_shm_client (void);
     int jack_cleanup_shm (void);
 
     int jack_shmalloc (const char *shm_name, jack_shmsize_t size,
@@ -149,7 +149,7 @@ extern "C"
     void jack_release_shm (jack_shm_info_t*);
     void jack_destroy_shm (jack_shm_info_t*);
     int jack_attach_shm (jack_shm_info_t*);
-    int jack_attach_shm_read (jack_shm_info_t*); 
+    int jack_attach_shm_read (jack_shm_info_t*);
     int jack_resize_shm (jack_shm_info_t*, jack_shmsize_t size);
 
 #ifdef __cplusplus
diff --git a/common/wscript b/common/wscript
index 6089ff8..da3ab93 100644
--- a/common/wscript
+++ b/common/wscript
@@ -130,7 +130,8 @@ def build(bld):
         'JackNetTool.cpp',
         'JackNetInterface.cpp',
         'JackArgParser.cpp',
-        'JackDummyDriver.cpp',
+        'JackPhysicalMidiInput.cpp',
+        'JackPhysicalMidiOutput.cpp',
         ]
 
     if bld.env['IS_LINUX']:
diff --git a/dbus/controller_iface_control.c b/dbus/controller_iface_control.c
index 768c192..ca3ab03 100644
--- a/dbus/controller_iface_control.c
+++ b/dbus/controller_iface_control.c
@@ -283,8 +283,11 @@ jack_control_run_method(
     return true;
 
 not_started:
-    jack_dbus_error (call, JACK_DBUS_ERROR_SERVER_NOT_RUNNING,
-                     "Can't execute method '%s' with stopped JACK server", call->method_name);
+    jack_dbus_only_error(
+        call,
+        JACK_DBUS_ERROR_SERVER_NOT_RUNNING,
+        "Can't execute method '%s' with stopped JACK server",
+        call->method_name);
 
 exit:
     return true;
diff --git a/dbus/controller_iface_patchbay.c b/dbus/controller_iface_patchbay.c
index 9adb7cf..ed477d7 100644
--- a/dbus/controller_iface_patchbay.c
+++ b/dbus/controller_iface_patchbay.c
@@ -281,6 +281,35 @@ jack_controller_patchbay_send_signal_ports_disconnected(
         DBUS_TYPE_INVALID);
 }
 
+void
+jack_controller_patchbay_send_signal_port_renamed(
+    dbus_uint64_t new_graph_version,
+    dbus_uint64_t client_id,
+    const char * client_name,
+    dbus_uint64_t port_id,
+    const char * port_old_name,
+    const char * port_new_name)
+{
+
+    jack_dbus_send_signal(
+        JACK_CONTROLLER_OBJECT_PATH,
+        JACK_DBUS_IFACE_NAME,
+        "PortRenamed",
+        DBUS_TYPE_UINT64,
+        &new_graph_version,
+        DBUS_TYPE_UINT64,
+        &client_id,
+        DBUS_TYPE_STRING,
+        &client_name,
+        DBUS_TYPE_UINT64,
+        &port_id,
+        DBUS_TYPE_STRING,
+        &port_old_name,
+        DBUS_TYPE_STRING,
+        &port_new_name,
+        DBUS_TYPE_INVALID);
+}
+
 static
 struct jack_graph_client *
 jack_controller_patchbay_find_client(
@@ -1618,6 +1647,65 @@ jack_controller_port_connect_callback(
     }
 }
 
+int jack_controller_port_rename_callback(jack_port_id_t port, const char * old_name, const char * new_name, void * context)
+{
+    struct jack_graph_port * port_ptr;
+    const char * port_new_short_name;
+    const char * port_old_short_name;
+    char * name_buffer;
+
+    jack_info("port renamed: '%s' -> '%s'", old_name, new_name);
+
+    port_new_short_name = strchr(new_name, ':');
+    if (port_new_short_name == NULL)
+    {
+        jack_error("renamed port new name '%s' does not contain ':' separator char", new_name);
+        return -1;
+    }
+
+    port_new_short_name++;      /* skip ':' separator char */
+
+    port_old_short_name = strchr(old_name, ':');
+    if (port_old_short_name == NULL)
+    {
+        jack_error("renamed port old name '%s' does not contain ':' separator char", old_name);
+        return -1;
+    }
+
+    port_old_short_name++;      /* skip ':' separator char */
+
+    port_ptr = jack_controller_patchbay_find_port_by_full_name(patchbay_ptr, old_name);
+    if (port_ptr == NULL)
+    {
+        jack_error("renamed port '%s' not found", old_name);
+        return -1;
+    }
+
+    name_buffer = strdup(port_new_short_name);
+    if (name_buffer == NULL)
+    {
+        jack_error("strdup() call for port name '%s' failed.", port_new_short_name);
+        return 1;
+    }
+
+    free(port_ptr->name);
+    port_ptr->name = name_buffer;
+
+    pthread_mutex_lock(&patchbay_ptr->lock);
+    patchbay_ptr->graph.version++;
+    jack_controller_patchbay_send_signal_port_renamed(
+        patchbay_ptr->graph.version,
+        port_ptr->client->id,
+        port_ptr->client->name,
+        port_ptr->id,
+        port_old_short_name,
+        port_ptr->name);
+    jack_controller_patchbay_send_signal_graph_changed(patchbay_ptr->graph.version);
+    pthread_mutex_unlock(&patchbay_ptr->lock);
+
+    return 0;
+}
+
 #undef controller_ptr
 
 void
@@ -1714,6 +1802,13 @@ jack_controller_patchbay_init(
         goto fail_uninit_mutex;
     }
 
+    ret = jack_set_port_rename_callback(controller_ptr->client, jack_controller_port_rename_callback, controller_ptr);
+    if (ret != 0)
+    {
+        jack_error("jack_set_port_rename_callback() failed with error %d", ret);
+        goto fail_uninit_mutex;
+    }
+
     return true;
 
 fail_uninit_mutex:
@@ -1838,6 +1933,15 @@ JACK_DBUS_SIGNAL_ARGUMENTS_BEGIN(PortsDisconnected)
     JACK_DBUS_SIGNAL_ARGUMENT("connection_id", DBUS_TYPE_UINT64_AS_STRING)
 JACK_DBUS_SIGNAL_ARGUMENTS_END
 
+JACK_DBUS_SIGNAL_ARGUMENTS_BEGIN(PortRenamed)
+    JACK_DBUS_SIGNAL_ARGUMENT("new_graph_version", DBUS_TYPE_UINT64_AS_STRING)
+    JACK_DBUS_SIGNAL_ARGUMENT("port_id", DBUS_TYPE_UINT64_AS_STRING)
+    JACK_DBUS_SIGNAL_ARGUMENT("client_id", DBUS_TYPE_UINT64_AS_STRING)
+    JACK_DBUS_SIGNAL_ARGUMENT("client_name", DBUS_TYPE_STRING_AS_STRING)
+    JACK_DBUS_SIGNAL_ARGUMENT("port_old_name", DBUS_TYPE_STRING_AS_STRING)
+    JACK_DBUS_SIGNAL_ARGUMENT("port_new_name", DBUS_TYPE_STRING_AS_STRING)
+JACK_DBUS_SIGNAL_ARGUMENTS_END
+
 JACK_DBUS_SIGNALS_BEGIN
     JACK_DBUS_SIGNAL_DESCRIBE(GraphChanged)
     JACK_DBUS_SIGNAL_DESCRIBE(ClientAppeared)
@@ -1846,6 +1950,7 @@ JACK_DBUS_SIGNALS_BEGIN
     JACK_DBUS_SIGNAL_DESCRIBE(PortDisappeared)
     JACK_DBUS_SIGNAL_DESCRIBE(PortsConnected)
     JACK_DBUS_SIGNAL_DESCRIBE(PortsDisconnected)
+    JACK_DBUS_SIGNAL_DESCRIBE(PortRenamed)
 JACK_DBUS_SIGNALS_END
 
 JACK_DBUS_IFACE_BEGIN(g_jack_controller_iface_patchbay, JACK_DBUS_IFACE_NAME)
diff --git a/dbus/jackdbus.c b/dbus/jackdbus.c
index ef03680..eb86308 100644
--- a/dbus/jackdbus.c
+++ b/dbus/jackdbus.c
@@ -765,6 +765,34 @@ jack_dbus_error(
     va_end(ap);
 }
 
+void
+jack_dbus_only_error(
+    void *dbus_call_context_ptr,
+    const char *error_name,
+    const char *format,
+    ...)
+{
+    va_list ap;
+    char buffer[300];
+
+    va_start(ap, format);
+
+    vsnprintf(buffer, sizeof(buffer), format, ap);
+
+    if (((struct jack_dbus_method_call *)dbus_call_context_ptr)->reply != NULL)
+    {
+        dbus_message_unref(((struct jack_dbus_method_call *)dbus_call_context_ptr)->reply);
+        ((struct jack_dbus_method_call *)dbus_call_context_ptr)->reply = NULL;
+    }
+
+    ((struct jack_dbus_method_call *)dbus_call_context_ptr)->reply = dbus_message_new_error(
+        ((struct jack_dbus_method_call *)dbus_call_context_ptr)->message,
+        error_name,
+        buffer);
+
+    va_end(ap);
+}
+
 int
 main (int argc, char **argv)
 {
diff --git a/dbus/jackdbus.h b/dbus/jackdbus.h
index d94bc33..d920cf0 100644
--- a/dbus/jackdbus.h
+++ b/dbus/jackdbus.h
@@ -257,6 +257,13 @@ jack_dbus_error(
     const char *format,
     ...);
 
+void
+jack_dbus_only_error(
+    void *dbus_call_context_ptr,
+    const char *error_name,
+    const char *format,
+    ...);
+
 bool
 jack_dbus_get_method_args(
     struct jack_dbus_method_call *call,
diff --git a/dbus/wscript b/dbus/wscript
index e23e67b..a4066b5 100644
--- a/dbus/wscript
+++ b/dbus/wscript
@@ -10,11 +10,15 @@ def set_options(opt):
     opt.add_option('--enable-pkg-config-dbus-service-dir', action='store_true', default=False, help='force D-Bus service install dir to be one returned by pkg-config')
 
 def configure(conf):
-    if not conf.check_cfg(package='dbus-1', atleast_version='1.0.0', args='--cflags --libs'):
+    conf.env['BUILD_JACKDBUS'] = False
+
+    if not conf.check_cfg(package='dbus-1', atleast_version='1.0.0', args='--cflags --libs') or not conf.is_defined('HAVE_DBUS_1'):
+        print Logs.colors.RED + 'WARNING !! jackdbus will not be built because libdbus-dev is missing' + Logs.colors.NORMAL
         return
 
     dbus_dir = conf.check_cfg(package='dbus-1', args='--variable=session_bus_services_dir')
     if not dbus_dir:
+        print Logs.colors.RED + 'WARNING !! jackdbus will not be built because service dir is unknown' + Logs.colors.NORMAL
         return
 
     dbus_dir = dbus_dir.strip()
@@ -31,15 +35,13 @@ def configure(conf):
 
     if conf.is_defined('HAVE_EXPAT'):
         conf.env['LIB_EXPAT'] = ['expat']
+    else:
+        print Logs.colors.RED + 'WARNING !! jackdbus will not be built because of expat is missing' + Logs.colors.NORMAL
+        return
 
-    conf.env['BUILD_JACKDBUS1'] = conf.is_defined('HAVE_EXPAT') and conf.is_defined('HAVE_DBUS_1')
-
+    conf.env['BUILD_JACKDBUS'] = True
 
 def build(bld):
-
-    if bld.env['BUILD_JACKDBUS1'] != True:
-        return
-
     obj = bld.new_task_gen('cc', 'program')
     if bld.env['IS_LINUX']:
         sysdeps_dbus_include = ['../linux', '../posix']
diff --git a/doxyfile b/doxyfile
index 0ba53fc..bc5116a 100644
--- a/doxyfile
+++ b/doxyfile
@@ -23,7 +23,7 @@ PROJECT_NAME           = "Jack2"
 # This could be handy for archiving the generated documentation or 
 # if some version control system is used.
 
-PROJECT_NUMBER         = 1.9.4
+PROJECT_NUMBER         = 1.9.5
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) 
 # base path where the generated documentation will be put. 
diff --git a/example-clients/alsa_in.c b/example-clients/alsa_in.c
index 2a8b78c..a04271e 100644
--- a/example-clients/alsa_in.c
+++ b/example-clients/alsa_in.c
@@ -184,7 +184,7 @@ static int set_hwparams(snd_pcm_t *handle, snd_pcm_hw_params_t *params, snd_pcm_
 	}
 	/* set the buffer time */
 
-	buffer_time = 1000000*period*nperiods/rate;
+	buffer_time = 1000000*(uint64_t)period*nperiods/rate;
 	err = snd_pcm_hw_params_set_buffer_time_near(handle, params, &buffer_time, &dir);
 	if (err < 0) {
 		printf("Unable to set buffer time %i for playback: %s\n",  1000000*period*nperiods/rate, snd_strerror(err));
@@ -199,7 +199,7 @@ static int set_hwparams(snd_pcm_t *handle, snd_pcm_hw_params_t *params, snd_pcm_
 	    printf( "WARNING: buffer size does not match: (requested %d, got %d)\n", nperiods * period, (int) real_buffer_size );
 	}
 	/* set the period time */
-	period_time = 1000000*period/rate;
+	period_time = 1000000*(uint64_t)period/rate;
 	err = snd_pcm_hw_params_set_period_time_near(handle, params, &period_time, &dir);
 	if (err < 0) {
 		printf("Unable to set period time %i for playback: %s\n", 1000000*period/rate, snd_strerror(err));
diff --git a/example-clients/alsa_out.c b/example-clients/alsa_out.c
index 2d34cd1..852e978 100644
--- a/example-clients/alsa_out.c
+++ b/example-clients/alsa_out.c
@@ -183,7 +183,7 @@ static int set_hwparams(snd_pcm_t *handle, snd_pcm_hw_params_t *params, snd_pcm_
 	}
 	/* set the buffer time */
 
-	buffer_time = 1000000*period*nperiods/rate;
+	buffer_time = 1000000*(uint64_t)period*nperiods/rate;
 	err = snd_pcm_hw_params_set_buffer_time_near(handle, params, &buffer_time, &dir);
 	if (err < 0) {
 		printf("Unable to set buffer time %i for playback: %s\n",  1000000*period*nperiods/rate, snd_strerror(err));
@@ -198,7 +198,7 @@ static int set_hwparams(snd_pcm_t *handle, snd_pcm_hw_params_t *params, snd_pcm_
 	    printf( "WARNING: buffer size does not match: (requested %d, got %d)\n", nperiods * period, (int) real_buffer_size );
 	}
 	/* set the period time */
-	period_time = 1000000*period/rate;
+	period_time = 1000000*(uint64_t)period/rate;
 	err = snd_pcm_hw_params_set_period_time_near(handle, params, &period_time, &dir);
 	if (err < 0) {
 		printf("Unable to set period time %i for playback: %s\n", 1000000*period/rate, snd_strerror(err));
diff --git a/example-clients/lsp.c b/example-clients/lsp.c
index db8b454..5a3362f 100644
--- a/example-clients/lsp.c
+++ b/example-clients/lsp.c
@@ -208,6 +208,12 @@ main (int argc, char *argv[])
 				if (flags & JackPortIsTerminal) {
 					fputs ("terminal,", stdout);
 				}
+                
+                if (flags & JackPortIsActive) {
+                    fputs ("active,", stdout);
+                } else {
+                    fputs ("non-active,", stdout);
+                }
 				putc ('\n', stdout);
 			}
 		}
diff --git a/example-clients/netsource.c b/example-clients/netsource.c
index ed4c1af..32b06fc 100644
--- a/example-clients/netsource.c
+++ b/example-clients/netsource.c
@@ -36,6 +36,7 @@ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
 #ifdef WIN32
 #include <winsock2.h>
+#define socklen_t int
 #include <malloc.h>
 #else
 #include <netinet/in.h>
diff --git a/linux/alsa/JackAlsaDriver.cpp b/linux/alsa/JackAlsaDriver.cpp
index 45486f5..fff7aea 100644
--- a/linux/alsa/JackAlsaDriver.cpp
+++ b/linux/alsa/JackAlsaDriver.cpp
@@ -263,102 +263,106 @@ JackAlsaDriver::alsa_driver_hw_specific (alsa_driver_t *driver, int hw_monitorin
 void
 JackAlsaDriver::alsa_driver_setup_io_function_pointers (alsa_driver_t *driver)
 {
-	if (SND_PCM_FORMAT_FLOAT_LE == driver->playback_sample_format) {
-		if (driver->playback_interleaved) {
-			driver->channel_copy = memcpy_interleave_d32_s32;
-		} else {
-			driver->channel_copy = memcpy_fake;
-		}
-		driver->read_via_copy = sample_move_floatLE_sSs;
-		driver->write_via_copy = sample_move_dS_floatLE;
-	} else {
-
-		switch (driver->playback_sample_bytes) {
-		case 2:
+	if (driver->playback_handle) {
+		if (SND_PCM_FORMAT_FLOAT_LE == driver->playback_sample_format) {
 			if (driver->playback_interleaved) {
-				driver->channel_copy = memcpy_interleave_d16_s16;
+				driver->channel_copy = memcpy_interleave_d32_s32;
 			} else {
 				driver->channel_copy = memcpy_fake;
 			}
+			driver->read_via_copy = sample_move_floatLE_sSs;
+			driver->write_via_copy = sample_move_dS_floatLE;
+		} else {
+
+			switch (driver->playback_sample_bytes) {
+			case 2:
+				if (driver->playback_interleaved) {
+					driver->channel_copy = memcpy_interleave_d16_s16;
+				} else {
+					driver->channel_copy = memcpy_fake;
+				}
 			
-			switch (driver->dither) {
-			case Rectangular:
-				jack_info("Rectangular dithering at 16 bits");
-				driver->write_via_copy = driver->quirk_bswap?
-                                        sample_move_dither_rect_d16_sSs:
-                                        sample_move_dither_rect_d16_sS;
-				break;
+				switch (driver->dither) {
+				case Rectangular:
+					jack_info("Rectangular dithering at 16 bits");
+					driver->write_via_copy = driver->quirk_bswap?
+        	                                sample_move_dither_rect_d16_sSs:
+        	                                sample_move_dither_rect_d16_sS;
+					break;
 				
-			case Triangular:
-				jack_info("Triangular dithering at 16 bits");
-				driver->write_via_copy = driver->quirk_bswap?
-                                        sample_move_dither_tri_d16_sSs:
-                                        sample_move_dither_tri_d16_sS;
-				break;
+				case Triangular:
+					jack_info("Triangular dithering at 16 bits");
+					driver->write_via_copy = driver->quirk_bswap?
+        	                                sample_move_dither_tri_d16_sSs:
+        	                                sample_move_dither_tri_d16_sS;
+					break;
 				
-			case Shaped:
-				jack_info("Noise-shaped dithering at 16 bits");
-				driver->write_via_copy = driver->quirk_bswap?
-                                        sample_move_dither_shaped_d16_sSs:
-                                        sample_move_dither_shaped_d16_sS;
-				break;
+				case Shaped:
+					jack_info("Noise-shaped dithering at 16 bits");
+					driver->write_via_copy = driver->quirk_bswap?
+        	                                sample_move_dither_shaped_d16_sSs:
+        	                                sample_move_dither_shaped_d16_sS;
+					break;
 				
-			default:
-				driver->write_via_copy = driver->quirk_bswap?
-                                        sample_move_d16_sSs : 
-        				sample_move_d16_sS;
+				default:
+					driver->write_via_copy = driver->quirk_bswap?
+        	                                sample_move_d16_sSs : 
+        					sample_move_d16_sS;
+					break;
+				}
 				break;
-			}
-			break;
 			
-		case 3: /* NO DITHER */
-			if (driver->playback_interleaved) {
-				driver->channel_copy = memcpy_interleave_d24_s24;
-			} else {
-				driver->channel_copy = memcpy_fake;
-			}
+			case 3: /* NO DITHER */
+				if (driver->playback_interleaved) {
+					driver->channel_copy = memcpy_interleave_d24_s24;
+				} else {
+					driver->channel_copy = memcpy_fake;
+				}
 			
-			driver->write_via_copy = driver->quirk_bswap?
-				sample_move_d24_sSs: 
-				sample_move_d24_sS;
+				driver->write_via_copy = driver->quirk_bswap?
+					sample_move_d24_sSs: 
+					sample_move_d24_sS;
 
-			break;
+				break;
 									
-	 	case 4: /* NO DITHER */
-			if (driver->playback_interleaved) {
-				driver->channel_copy = memcpy_interleave_d32_s32;
-			} else {
-				driver->channel_copy = memcpy_fake;
-			}
+		 	case 4: /* NO DITHER */
+				if (driver->playback_interleaved) {
+					driver->channel_copy = memcpy_interleave_d32_s32;
+				} else {
+					driver->channel_copy = memcpy_fake;
+				}
 
-			driver->write_via_copy = driver->quirk_bswap?
-				sample_move_d32u24_sSs: 
-				sample_move_d32u24_sS;
-		    break;
+				driver->write_via_copy = driver->quirk_bswap?
+					sample_move_d32u24_sSs: 
+					sample_move_d32u24_sS;
+			    break;
 
-		default:
-			jack_error ("impossible sample width (%d) discovered!",
-				    driver->playback_sample_bytes);
-			exit (1);
+			default:
+				jack_error ("impossible sample width (%d) discovered!",
+					    driver->playback_sample_bytes);
+				exit (1);
+			}
 		}
 	}
 	
-	switch (driver->capture_sample_bytes) {
-	case 2:
-		driver->read_via_copy = driver->quirk_bswap?
-			sample_move_dS_s16s: 
-		        sample_move_dS_s16;
-		break;
-	case 3:
-		driver->read_via_copy = driver->quirk_bswap?
-			sample_move_dS_s24s: 
-		        sample_move_dS_s24;
-		break;
-	case 4:
-		driver->read_via_copy = driver->quirk_bswap?
-		 	sample_move_dS_s32u24s: 
-		        sample_move_dS_s32u24;
-		break;
+	if (driver->capture_handle) {
+		switch (driver->capture_sample_bytes) {
+		case 2:
+			driver->read_via_copy = driver->quirk_bswap?
+				sample_move_dS_s16s: 
+			        sample_move_dS_s16;
+			break;
+		case 3:
+			driver->read_via_copy = driver->quirk_bswap?
+				sample_move_dS_s24s: 
+			        sample_move_dS_s24;
+			break;
+		case 4:
+			driver->read_via_copy = driver->quirk_bswap?
+			 	sample_move_dS_s32u24s: 
+			        sample_move_dS_s32u24;
+			break;
+		}
 	}
 }
 
@@ -2083,7 +2087,7 @@ int JackAlsaDriver::Attach()
     assert(fCaptureChannels < DRIVER_PORT_NUM);
     assert(fPlaybackChannels < DRIVER_PORT_NUM);
 
-    port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
+    port_flags = (unsigned long)CaptureDriverFlags;
 
     alsa_driver_t* alsa_driver = (alsa_driver_t*)fDriver;
 
@@ -2110,7 +2114,7 @@ int JackAlsaDriver::Attach()
         jack_log("JackAudioDriver::Attach fCapturePortList[i] %ld ", port_index);
     }
 
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
+    port_flags = (unsigned long)PlaybackDriverFlags;
 
     for (int i = 0; i < fPlaybackChannels; i++) {
         snprintf(alias, sizeof(alias) - 1, "%s:playback_%u", fAliasName, i + 1);
@@ -2131,7 +2135,7 @@ int JackAlsaDriver::Attach()
         if (fWithMonitorPorts) {
             jack_log("Create monitor port ");
             snprintf(name, sizeof(name) - 1, "%s:monitor_%d", fClientControl.fName, i + 1);
-            if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, fEngineControl->fBufferSize)) == NO_PORT) {
+            if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, MonitorDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error ("ALSA: cannot register monitor port for %s", name);
             } else {
                 port = fGraphManager->GetPort(port_index);
diff --git a/linux/alsa/alsa_rawmidi.c b/linux/alsa/alsa_rawmidi.c
index 13d7f31..62e18cd 100644
--- a/linux/alsa/alsa_rawmidi.c
+++ b/linux/alsa/alsa_rawmidi.c
@@ -432,7 +432,7 @@ inline int midi_port_open_jack(alsa_rawmidi_t *midi, midi_port_t *port, int type
 		snprintf(name, sizeof(name) - 1, "system:midi_playback_%d", ++midi->midi_out_cnt);
 
 	port->jack = jack_port_register(midi->client, name, JACK_DEFAULT_MIDI_TYPE,
-		type | JackPortIsPhysical|JackPortIsTerminal, 0);
+		type | JackPortIsPhysical | JackPortIsTerminal | JackPortIsActive, 0);
 		
 	if (port->jack) 
 		jack_port_set_alias(port->jack, alias);
diff --git a/linux/alsa/alsa_seqmidi.c b/linux/alsa/alsa_seqmidi.c
index f079703..0abc52a 100644
--- a/linux/alsa/alsa_seqmidi.c
+++ b/linux/alsa/alsa_seqmidi.c
@@ -488,7 +488,7 @@ port_t* port_create(alsa_seqmidi_t *self, int type, snd_seq_addr_t addr, const s
 	/* mark anything that looks like a hardware port as physical&terminal */
 
 	if (snd_seq_port_info_get_type (info) & (SND_SEQ_PORT_TYPE_HARDWARE|SND_SEQ_PORT_TYPE_PORT|SND_SEQ_PORT_TYPE_SPECIFIC)) {
-		jack_caps |= (JackPortIsPhysical|JackPortIsTerminal);
+		jack_caps |= (JackPortIsPhysical | JackPortIsTerminal | JackPortIsActive);
 	}
 
 	if (jack_caps & JackPortIsOutput)
diff --git a/linux/firewire/JackFFADODriver.cpp b/linux/firewire/JackFFADODriver.cpp
index b6080d6..7c05370 100644
--- a/linux/firewire/JackFFADODriver.cpp
+++ b/linux/firewire/JackFFADODriver.cpp
@@ -2,6 +2,7 @@
 Copyright (C) 2001 Paul Davis
 Copyright (C) 2004 Grame
 Copyright (C) 2007 Pieter Palmers
+Copyright (C) 2009 Devin Anderson
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -35,6 +36,8 @@ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 #include <string.h>
 
 #include "JackFFADODriver.h"
+#include "JackFFADOMidiInput.h"
+#include "JackFFADOMidiOutput.h"
 #include "JackEngineControl.h"
 #include "JackClientControl.h"
 #include "JackPort.h"
@@ -91,29 +94,14 @@ JackFFADODriver::ffado_driver_read (ffado_driver_t * driver, jack_nframes_t nfra
     /* process the midi data */
     for (chn = 0; chn < driver->capture_nchannels; chn++) {
         if (driver->capture_channels[chn].stream_type == ffado_stream_type_midi) {
-            jack_nframes_t i;
-            int done;
-            uint32_t *midi_buffer = driver->capture_channels[chn].midi_buffer;
-            midi_unpack_t *midi_unpack = &driver->capture_channels[chn].midi_unpack;
-            buf = (jack_default_audio_sample_t*)fGraphManager->GetBuffer(fCapturePortList[chn],  nframes);
-            jack_midi_clear_buffer(buf);
-
-            /* if the returned buffer is invalid, discard the midi data */
-            if (!buf) continue;
-            /* else unpack
-               note that libffado guarantees that midi bytes are on 8-byte aligned indexes
-             */
-            for (i = 0; i < nframes; i += 8) {
-                if (midi_buffer[i] & 0xFF000000) {
-                    done = midi_unpack_buf(midi_unpack, (unsigned char *)(midi_buffer + i), 1, buf, i);
-                    if (done != 1) {
-                        printError("buffer overflow in channel %d\n", chn);
-                        break;
-                    }
-
-                    printMessage("MIDI IN: %08X (i=%d)", midi_buffer[i], i);
-                }
+            JackFFADOMidiInput *midi_input = (JackFFADOMidiInput *) driver->capture_channels[chn].midi_input;
+            JackMidiBuffer *buffer = (JackMidiBuffer *) fGraphManager->GetBuffer(fCapturePortList[chn], nframes);
+            if (! buffer) {
+                continue;
             }
+            midi_input->SetInputBuffer(driver->capture_channels[chn].midi_buffer);
+            midi_input->SetPortBuffer(buffer);
+            midi_input->Process(nframes);
         }
     }
 
@@ -146,80 +134,20 @@ JackFFADODriver::ffado_driver_write (ffado_driver_t * driver, jack_nframes_t nfr
                 ffado_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(buf));
                 ffado_streaming_playback_stream_onoff(driver->dev, chn, 1);
             } else if (driver->playback_channels[chn].stream_type == ffado_stream_type_midi) {
-                jack_nframes_t nevents;
-                jack_nframes_t i;
-                midi_pack_t *midi_pack = &driver->playback_channels[chn].midi_pack;
                 uint32_t *midi_buffer = driver->playback_channels[chn].midi_buffer;
-                buf = (jack_default_audio_sample_t*)fGraphManager->GetBuffer(fPlaybackPortList[chn], nframes);
-                jack_nframes_t min_next_pos = 0;
-
                 memset(midi_buffer, 0, nframes * sizeof(uint32_t));
+                buf = (jack_default_audio_sample_t *) fGraphManager->GetBuffer(fPlaybackPortList[chn], nframes);
                 ffado_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(midi_buffer));
-
                 /* if the returned buffer is invalid, continue */
                 if (!buf) {
                     ffado_streaming_playback_stream_onoff(driver->dev, chn, 0);
                     continue;
                 }
                 ffado_streaming_playback_stream_onoff(driver->dev, chn, 1);
-
-                // check if we still have to process bytes from the previous period
-                if (driver->playback_channels[chn].nb_overflow_bytes) {
-                    printMessage("have to process %d bytes from previous period", driver->playback_channels[chn].nb_overflow_bytes);
-                }
-                for (i = 0; i < driver->playback_channels[chn].nb_overflow_bytes; ++i) {
-                    midi_buffer[min_next_pos] = 0x01000000 | (driver->playback_channels[chn].overflow_buffer[i] & 0xFF);
-                    min_next_pos += 8;
-                }
-                driver->playback_channels[chn].nb_overflow_bytes = 0;
-
-                // process the events in this period
-                nevents = jack_midi_get_event_count(buf);
-                //if (nevents)
-                //  printMessage("MIDI: %d events in ch %d", nevents, chn);
-
-                for (i = 0; i < nevents; ++i) {
-                    size_t j;
-                    jack_midi_event_t event;
-                    jack_midi_event_get(&event, buf, i);
-
-                    midi_pack_event(midi_pack, &event);
-
-                    // floor the initial position to be a multiple of 8
-                    jack_nframes_t pos = event.time & 0xFFFFFFF8;
-                    for (j = 0; j < event.size; j++) {
-                        // make sure we don't overwrite a previous byte
-                        while (pos < min_next_pos && pos < nframes) {
-                            pos += 8;
-                            printMessage("have to correct pos to %d", pos);
-                        }
-
-                        if (pos >= nframes) {
-                            unsigned int f;
-                            printMessage("midi message crosses period boundary");
-                            driver->playback_channels[chn].nb_overflow_bytes = event.size - j;
-                            if (driver->playback_channels[chn].nb_overflow_bytes > MIDI_OVERFLOW_BUFFER_SIZE) {
-                                printError("too much midi bytes cross period boundary");
-                                driver->playback_channels[chn].nb_overflow_bytes = MIDI_OVERFLOW_BUFFER_SIZE;
-                            }
-                            // save the bytes that still have to be transmitted in the next period
-                            for (f = 0; f < driver->playback_channels[chn].nb_overflow_bytes; f++) {
-                                driver->playback_channels[chn].overflow_buffer[f] = event.buffer[j+f];
-                            }
-                            // exit since we can't transmit anything anymore.
-                            // the rate should be controlled
-                            if (i < nevents - 1) {
-                                printError("%d midi events lost due to period crossing", nevents - i - 1);
-                            }
-                            break;
-                        } else {
-                            midi_buffer[pos] = 0x01000000 | (event.buffer[j] & 0xFF);
-                            pos += 8;
-                            min_next_pos = pos;
-                        }
-                    }
-                    //printMessage("MIDI: sent %d-byte event at %ld", (int)event.size, (long)event.time);
-                }
+                JackFFADOMidiOutput *midi_output = (JackFFADOMidiOutput *) driver->playback_channels[chn].midi_output;
+                midi_output->SetPortBuffer((JackMidiBuffer *) buf);
+                midi_output->SetOutputBuffer(midi_buffer);
+                midi_output->Process(nframes);
 
             } else { // always have a valid buffer
                 ffado_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(driver->nullbuffer));
@@ -279,16 +207,21 @@ JackFFADODriver::ffado_driver_wait (ffado_driver_t *driver, int extra_fd, int *s
     } else if (response == ffado_wait_error) {
         // an error happened (unhandled xrun)
         // this should be fatal
+        jack_error("JackFFADODriver::ffado_driver_wait - unhandled xrun");
         *status = -1;
         return 0;
     } else if (response == ffado_wait_shutdown) {
         // ffado requested shutdown (e.g. device unplugged)
         // this should be fatal
+        jack_error("JackFFADODriver::ffado_driver_wait - shutdown requested "
+                   "(device unplugged?)");
         *status = -1;
         return 0;
     } else {
         // unknown response code. should be fatal
         // this should be fatal
+        jack_error("JackFFADODriver::ffado_driver_wait - unexpected error "
+                   "code '%d' returned from 'ffado_streaming_wait'", response);
         *status = -1;
         return 0;
     }
@@ -426,8 +359,6 @@ int JackFFADODriver::Attach()
 {
     JackPort* port;
     int port_index;
-    unsigned long port_flags;
-
     char buf[JACK_PORT_NAME_SIZE];
     char portname[JACK_PORT_NAME_SIZE];
 
@@ -485,8 +416,6 @@ int JackFFADODriver::Attach()
     /* ports */
 
     // capture
-    port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
-
     driver->capture_nchannels = ffado_streaming_get_nb_capture_streams(driver->dev);
     driver->capture_channels = (ffado_capture_channel_t *)calloc(driver->capture_nchannels, sizeof(ffado_capture_channel_t));
     if (driver->capture_channels == NULL) {
@@ -504,7 +433,7 @@ int JackFFADODriver::Attach()
             printMessage ("Registering audio capture port %s", buf);
             if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, buf,
                               JACK_DEFAULT_AUDIO_TYPE,
-                              (JackPortFlags)port_flags,
+                              CaptureDriverFlags,
                               fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("driver: cannot register port for %s", buf);
                 return -1;
@@ -527,7 +456,7 @@ int JackFFADODriver::Attach()
             printMessage ("Registering midi capture port %s", buf);
             if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, buf,
                               JACK_DEFAULT_MIDI_TYPE,
-                              (JackPortFlags)port_flags,
+                              CaptureDriverFlags,
                               fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("driver: cannot register port for %s", buf);
                 return -1;
@@ -541,9 +470,7 @@ int JackFFADODriver::Attach()
                 printError(" cannot enable port %s", buf);
             }
 
-            // setup midi unpacker
-            midi_unpack_init(&driver->capture_channels[chn].midi_unpack);
-            midi_unpack_reset(&driver->capture_channels[chn].midi_unpack);
+            driver->capture_channels[chn].midi_input = new JackFFADOMidiInput();
             // setup the midi buffer
             driver->capture_channels[chn].midi_buffer = (uint32_t *)calloc(driver->period_size, sizeof(uint32_t));
 
@@ -558,8 +485,6 @@ int JackFFADODriver::Attach()
     }
 
     // playback
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     driver->playback_nchannels = ffado_streaming_get_nb_playback_streams(driver->dev);
     driver->playback_channels = (ffado_playback_channel_t *)calloc(driver->playback_nchannels, sizeof(ffado_playback_channel_t));
     if (driver->playback_channels == NULL) {
@@ -578,7 +503,7 @@ int JackFFADODriver::Attach()
             printMessage ("Registering audio playback port %s", buf);
             if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, buf,
                               JACK_DEFAULT_AUDIO_TYPE,
-                              (JackPortFlags)port_flags,
+                              PlaybackDriverFlags,
                               fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("driver: cannot register port for %s", buf);
                 return -1;
@@ -603,7 +528,7 @@ int JackFFADODriver::Attach()
             printMessage ("Registering midi playback port %s", buf);
             if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, buf,
                               JACK_DEFAULT_MIDI_TYPE,
-                              (JackPortFlags)port_flags,
+                              PlaybackDriverFlags,
                               fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("driver: cannot register port for %s", buf);
                 return -1;
@@ -616,9 +541,13 @@ int JackFFADODriver::Attach()
             if (ffado_streaming_playback_stream_onoff(driver->dev, chn, 0)) {
                 printError(" cannot enable port %s", buf);
             }
-            // setup midi packer
-            midi_pack_reset(&driver->playback_channels[chn].midi_pack);
             // setup the midi buffer
+            
+            // This constructor optionally accepts arguments for the
+            // non-realtime buffer size and the realtime buffer size.  Ideally,
+            // these would become command-line options for the FFADO driver.
+            driver->playback_channels[chn].midi_output = new JackFFADOMidiOutput();
+
             driver->playback_channels[chn].midi_buffer = (uint32_t *)calloc(driver->period_size, sizeof(uint32_t));
 
             port = fGraphManager->GetPort(port_index);
@@ -658,12 +587,16 @@ int JackFFADODriver::Detach()
     for (chn = 0; chn < driver->capture_nchannels; chn++) {
         if (driver->capture_channels[chn].midi_buffer)
             free(driver->capture_channels[chn].midi_buffer);
+        if (driver->capture_channels[chn].midi_input)
+            delete ((JackFFADOMidiInput *) (driver->capture_channels[chn].midi_input));
     }
     free(driver->capture_channels);
 
     for (chn = 0; chn < driver->playback_nchannels; chn++) {
         if (driver->playback_channels[chn].midi_buffer)
             free(driver->playback_channels[chn].midi_buffer);
+        if (driver->playback_channels[chn].midi_output)
+            delete ((JackFFADOMidiOutput *) (driver->playback_channels[chn].midi_output));
     }
     free(driver->playback_channels);
 
diff --git a/linux/firewire/JackFFADOMidiInput.cpp b/linux/firewire/JackFFADOMidiInput.cpp
new file mode 100644
index 0000000..38ed539
--- /dev/null
+++ b/linux/firewire/JackFFADOMidiInput.cpp
@@ -0,0 +1,59 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#include <cassert>
+
+#include "JackFFADOMidiInput.h"
+
+namespace Jack {
+
+JackFFADOMidiInput::JackFFADOMidiInput(size_t buffer_size):
+    JackPhysicalMidiInput(buffer_size)
+{
+    new_period = true;
+}
+
+JackFFADOMidiInput::~JackFFADOMidiInput()
+{
+    // Empty
+}
+
+jack_nframes_t
+JackFFADOMidiInput::Receive(jack_midi_data_t *datum,
+                            jack_nframes_t current_frame,
+                            jack_nframes_t total_frames)
+{
+    assert(input_buffer);
+    if (! new_period) {
+        current_frame += 8;
+    } else {
+        new_period = false;
+    }
+    for (; current_frame < total_frames; current_frame += 8) {
+        uint32_t data = input_buffer[current_frame];
+        if (data & 0xff000000) {
+            *datum = (jack_midi_data_t) (data & 0xff);
+            return current_frame;
+        }
+    }
+    new_period = true;
+    return total_frames;
+}
+
+}
diff --git a/linux/firewire/JackFFADOMidiInput.h b/linux/firewire/JackFFADOMidiInput.h
new file mode 100644
index 0000000..12dc043
--- /dev/null
+++ b/linux/firewire/JackFFADOMidiInput.h
@@ -0,0 +1,54 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#ifndef __JackFFADOMidiInput__
+#define __JackFFADOMidiInput__
+
+#include "JackPhysicalMidiInput.h"
+
+namespace Jack {
+
+    class JackFFADOMidiInput: public JackPhysicalMidiInput {
+
+    private:
+
+        uint32_t *input_buffer;
+        bool new_period;
+
+    protected:
+
+        jack_nframes_t
+        Receive(jack_midi_data_t *, jack_nframes_t, jack_nframes_t);
+
+    public:
+
+        JackFFADOMidiInput(size_t buffer_size=1024);
+        ~JackFFADOMidiInput();
+
+        inline void
+        SetInputBuffer(uint32_t *input_buffer)
+        {
+            this->input_buffer = input_buffer;
+        }
+
+    };
+
+}
+
+#endif
diff --git a/linux/firewire/JackFFADOMidiOutput.cpp b/linux/firewire/JackFFADOMidiOutput.cpp
new file mode 100644
index 0000000..995f2d2
--- /dev/null
+++ b/linux/firewire/JackFFADOMidiOutput.cpp
@@ -0,0 +1,60 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#include <cassert>
+
+#include "JackError.h"
+#include "JackFFADOMidiOutput.h"
+
+namespace Jack {
+
+JackFFADOMidiOutput::JackFFADOMidiOutput(size_t non_rt_buffer_size,
+                                         size_t rt_buffer_size):
+    JackPhysicalMidiOutput(non_rt_buffer_size, rt_buffer_size)
+{
+    // Empty
+}
+
+JackFFADOMidiOutput::~JackFFADOMidiOutput()
+{
+    // Empty
+}
+
+jack_nframes_t
+JackFFADOMidiOutput::Advance(jack_nframes_t current_frame)
+{
+    if (current_frame % 8) {
+        current_frame = (current_frame & (~ ((jack_nframes_t) 7))) + 8;
+    }
+    return current_frame;
+}
+
+jack_nframes_t
+JackFFADOMidiOutput::Send(jack_nframes_t current_frame, jack_midi_data_t datum)
+{
+    assert(output_buffer);
+
+    jack_log("JackFFADOMidiOutput::Send (%d) - Sending '%x' byte.",
+             current_frame, (unsigned int) datum);
+
+    output_buffer[current_frame] = 0x01000000 | ((uint32_t) datum);
+    return current_frame + 8;
+}
+
+}
diff --git a/linux/firewire/JackFFADOMidiOutput.h b/linux/firewire/JackFFADOMidiOutput.h
new file mode 100644
index 0000000..309e7f6
--- /dev/null
+++ b/linux/firewire/JackFFADOMidiOutput.h
@@ -0,0 +1,57 @@
+/*
+Copyright (C) 2009 Devin Anderson
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+#ifndef __JackFFADOMidiOutput__
+#define __JackFFADOMidiOutput__
+
+#include "JackPhysicalMidiOutput.h"
+
+namespace Jack {
+
+    class JackFFADOMidiOutput: public JackPhysicalMidiOutput {
+
+    private:
+
+        uint32_t *output_buffer;
+
+    protected:
+
+        jack_nframes_t
+        Advance(jack_nframes_t);
+
+        jack_nframes_t
+        Send(jack_nframes_t, jack_midi_data_t);
+
+    public:
+
+        JackFFADOMidiOutput(size_t non_rt_buffer_size=1024,
+                            size_t rt_buffer_size=64);
+        ~JackFFADOMidiOutput();
+
+        inline void
+        SetOutputBuffer(uint32_t *output_buffer)
+        {
+            this->output_buffer = output_buffer;
+        }
+
+    };
+
+}
+
+#endif
diff --git a/linux/firewire/ffado_driver.h b/linux/firewire/ffado_driver.h
index a851d84..a06c136 100644
--- a/linux/firewire/ffado_driver.h
+++ b/linux/firewire/ffado_driver.h
@@ -7,6 +7,7 @@
  *   http://www.jackaudio.org
  *
  *   Copyright (C) 2005-2007 Pieter Palmers
+ *   Copyright (C) 2009 Devin Anderson
  *
  *   adapted for JackMP by Pieter Palmers
  *
@@ -51,9 +52,7 @@
 #include <types.h>
 
 #include <assert.h>
-#include <jack/midiport.h>
-#include "../alsa/midi_pack.h"
-#include "../alsa/midi_unpack.h"
+//#include <jack/midiport.h>
 
 // debug print control flags
 #define DEBUG_LEVEL_BUFFERS           	(1<<0)
@@ -143,21 +142,16 @@ struct _ffado_jack_settings
 typedef struct _ffado_capture_channel
 {
     ffado_streaming_stream_type stream_type;
-    midi_unpack_t midi_unpack;
     uint32_t *midi_buffer;
+    void *midi_input;
 }
 ffado_capture_channel_t;
 
-#define MIDI_OVERFLOW_BUFFER_SIZE 4
 typedef struct _ffado_playback_channel
 {
     ffado_streaming_stream_type stream_type;
-    midi_pack_t midi_pack;
     uint32_t *midi_buffer;
-    // to hold the midi bytes that couldn't be transferred
-    // during the previous period
-    char overflow_buffer[MIDI_OVERFLOW_BUFFER_SIZE];
-    unsigned int nb_overflow_bytes;
+    void *midi_output;
 }
 ffado_playback_channel_t;
 
diff --git a/linux/freebob/JackFreebobDriver.cpp b/linux/freebob/JackFreebobDriver.cpp
index c5d5770..348e463 100644
--- a/linux/freebob/JackFreebobDriver.cpp
+++ b/linux/freebob/JackFreebobDriver.cpp
@@ -667,8 +667,7 @@ int JackFreebobDriver::Attach()
 {
     JackPort* port;
     int port_index;
-    unsigned long port_flags;
-
+  
     char buf[JACK_PORT_NAME_SIZE];
     char portname[JACK_PORT_NAME_SIZE];
 
@@ -717,8 +716,6 @@ int JackFreebobDriver::Attach()
     /* ports */
 
     // capture
-    port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
-
     driver->capture_nchannels = freebob_streaming_get_nb_capture_streams(driver->dev);
     driver->capture_nchannels_audio = 0;
 
@@ -734,7 +731,7 @@ int JackFreebobDriver::Attach()
 
             if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, buf,
                               JACK_DEFAULT_AUDIO_TYPE,
-                              (JackPortFlags)port_flags,
+                              CaptureDriverFlags,
                               fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("driver: cannot register port for %s", buf);
                 return -1;
@@ -748,8 +745,6 @@ int JackFreebobDriver::Attach()
     }
 
     // playback
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     driver->playback_nchannels = freebob_streaming_get_nb_playback_streams(driver->dev);
     driver->playback_nchannels_audio = 0;
 
@@ -764,7 +759,7 @@ int JackFreebobDriver::Attach()
             printMessage ("Registering playback port %s", buf);
             if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, buf,
                               JACK_DEFAULT_AUDIO_TYPE,
-                              (JackPortFlags)port_flags,
+                              PlaybackDriverFlags,
                               fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("driver: cannot register port for %s", buf);
                 return -1;
diff --git a/linux/wscript b/linux/wscript
index 56a7733..20695a9 100644
--- a/linux/wscript
+++ b/linux/wscript
@@ -55,6 +55,13 @@ def build(bld):
                        'alsa/ice1712.c'
                        ]
 
+    ffado_driver_src = ['firewire/JackFFADODriver.cpp',
+                        'firewire/JackFFADOMidiInput.cpp',
+                        'firewire/JackFFADOMidiOutput.cpp',
+                        '../common/JackPhysicalMidiInput.cpp',
+                        '../common/JackPhysicalMidiOutput.cpp'
+                       ]
+
     if bld.env['BUILD_DRIVER_ALSA'] == True:
         create_jack_driver_obj(bld, 'alsa', alsa_driver_src, "ALSA")
 
@@ -62,7 +69,7 @@ def build(bld):
         create_jack_driver_obj(bld, 'freebob', 'freebob/JackFreebobDriver.cpp', "LIBFREEBOB")
 
     if bld.env['BUILD_DRIVER_FFADO'] == True:
-        create_jack_driver_obj(bld, 'firewire', 'firewire/JackFFADODriver.cpp', "LIBFFADO")
+        create_jack_driver_obj(bld, 'firewire', ffado_driver_src, "LIBFFADO")
 
     create_jack_driver_obj(bld, 'net', '../common/JackNetDriver.cpp')
 
diff --git a/macosx/Jack-Info.plist b/macosx/Jack-Info.plist
index 1e5eb07..8b6a61d 100644
--- a/macosx/Jack-Info.plist
+++ b/macosx/Jack-Info.plist
@@ -7,7 +7,7 @@
 	<key>CFBundleExecutable</key>
 	<string>Jackservermp</string>
 	<key>CFBundleGetInfoString</key>
-	<string>Jackdmp 1.9.4, @03-09 Paul Davis, Grame</string>
+	<string>Jackdmp 1.9.5, @03-09 Paul Davis, Grame</string>
 	<key>CFBundleIdentifier</key>
 	<string>com.grame.Jackmp</string>
 	<key>CFBundleInfoDictionaryVersion</key>
@@ -19,6 +19,6 @@
 	<key>CFBundleSignature</key>
 	<string>????</string>
 	<key>CFBundleVersion</key>
-	<string>1.9.4</string>
+	<string>1.9.5</string>
 </dict>
 </plist>
diff --git a/macosx/JackMacEngineRPC.cpp b/macosx/JackMacEngineRPC.cpp
index 4ddb0b1..fb95621 100644
--- a/macosx/JackMacEngineRPC.cpp
+++ b/macosx/JackMacEngineRPC.cpp
@@ -18,9 +18,11 @@ This program is free software; you can redistribute it and/or modify
 */
 
 #include "JackServer.h"
+#include "JackNotification.h"
 #include "JackLockedEngine.h"
 #include "JackRPCEngine.h"
 #include "JackMachServerChannel.h"
+#include "JackException.h"
 #include <assert.h>
 
 using namespace Jack;
@@ -238,6 +240,11 @@ rpc_type server_rpc_jack_client_rt_notify(mach_port_t server_port, int refnum, i
     JackMachServerChannel* channel = JackMachServerChannel::fPortTable[server_port];
     assert(channel);
     assert(channel->GetServer());
-    channel->GetServer()->Notify(refnum, notify, value);
-    return KERN_SUCCESS;
+    
+    if (notify == kQUIT) {
+        throw JackQuitException();
+    } else {
+        channel->GetServer()->Notify(refnum, notify, value);
+        return KERN_SUCCESS;
+    }
 }
diff --git a/macosx/JackMachClientChannel.cpp b/macosx/JackMachClientChannel.cpp
index c666bbb..f5f8850 100644
--- a/macosx/JackMachClientChannel.cpp
+++ b/macosx/JackMachClientChannel.cpp
@@ -23,7 +23,6 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "JackRPCClientServer.c"
 #include "JackError.h"
 #include "JackLibClient.h"
-#include "JackLibGlobals.h"
 #include "JackMachThread.h"
 #include "JackConstants.h"
 
diff --git a/macosx/JackMachServerChannel.cpp b/macosx/JackMachServerChannel.cpp
index 19295f7..fcf4fe8 100644
--- a/macosx/JackMachServerChannel.cpp
+++ b/macosx/JackMachServerChannel.cpp
@@ -58,7 +58,12 @@ int JackMachServerChannel::Open(const char* server_name, JackServer* server)
 void JackMachServerChannel::Close()
 {
     jack_log("JackMachServerChannel::Close");
+ #ifdef MAC_OS_X_VERSION_10_5
+    // Exception does not work in this case on pre Snow Loopard systems, see JackMachServerNotifyChannel::NotifyQuit()
     fThread.Kill();
+ #else
+    fThread.Stop();
+ #endif
     fServerPort.DestroyPort();
 }
     
@@ -149,12 +154,19 @@ boolean_t JackMachServerChannel::MessageHandler(mach_msg_header_t* Request, mach
 
 bool JackMachServerChannel::Execute()
 {
-    kern_return_t res;
-    if ((res = mach_msg_server(MessageHandler, 1024, fServerPort.GetPortSet(), 0)) != KERN_SUCCESS) {
-        jack_log("JackMachServerChannel::Execute: err = %s", mach_error_string(res));
+    try {
+        
+        kern_return_t res;
+        if ((res = mach_msg_server(MessageHandler, 1024, fServerPort.GetPortSet(), 0)) != KERN_SUCCESS) {
+            jack_log("JackMachServerChannel::Execute: err = %s", mach_error_string(res));
+            return false;
+        }
+        return true;
+        
+    } catch (JackQuitException& e) {
+        jack_log("JackMachServerChannel::Execute JackQuitException");
+        return false;
     }
-    //return (res == KERN_SUCCESS);  mach_msg_server can fail if the client reply port is not valid anymore (crashed client)
-    return true;
 }
 
 } // end of namespace
diff --git a/macosx/JackMachServerNotifyChannel.cpp b/macosx/JackMachServerNotifyChannel.cpp
index 2e1c9ab..f55ce09 100644
--- a/macosx/JackMachServerNotifyChannel.cpp
+++ b/macosx/JackMachServerNotifyChannel.cpp
@@ -19,6 +19,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
 #include "JackMachServerNotifyChannel.h"
 #include "JackRPCEngineUser.c"
+#include "JackNotification.h"
 #include "JackTools.h"
 #include "JackConstants.h"
 #include "JackError.h"
@@ -42,9 +43,7 @@ int JackMachServerNotifyChannel::Open(const char* server_name)
 }
 
 void JackMachServerNotifyChannel::Close()
-{
-    //fClientPort.DisconnectPort(); pas ncessaire car le JackMachServerChannel a dja disparu?
-}
+{}
 
 void JackMachServerNotifyChannel::Notify(int refnum, int notify, int value)
 {
@@ -53,6 +52,18 @@ void JackMachServerNotifyChannel::Notify(int refnum, int notify, int value)
         jack_error("Could not write request ref = %d notify = %d err = %s", refnum, notify, mach_error_string(res));
     }
 }
+    
+void JackMachServerNotifyChannel::NotifyQuit()
+{
+ #ifdef MAC_OS_X_VERSION_10_5
+    // Nothing : since exception does not work in this case on pre Snow Loopard systems, see JackMachServerChannel::Close()
+ #else
+    kern_return_t res = rpc_jack_client_rt_notify(fClientPort.GetPort(), -1, kQUIT, 0, 0);
+    if (res != KERN_SUCCESS) {
+        jack_error("Could not write request ref = %d notify = %d err = %s", -1, kQUIT, mach_error_string(res));
+    }
+#endif
+}
 
 } // end of namespace
 
diff --git a/macosx/JackMachServerNotifyChannel.h b/macosx/JackMachServerNotifyChannel.h
index 98523a8..8eb7b72 100644
--- a/macosx/JackMachServerNotifyChannel.h
+++ b/macosx/JackMachServerNotifyChannel.h
@@ -46,7 +46,8 @@ class JackMachServerNotifyChannel
         void Close();                       // Close the Server/Client connection
 
         void Notify(int refnum, int notify, int value);
-};
+        void NotifyQuit();
+};  
 
 } // end of namespace
 
diff --git a/macosx/Jackdmp.xcodeproj/project.pbxproj b/macosx/Jackdmp.xcodeproj/project.pbxproj
index c8aae4f..86c48a5 100644
--- a/macosx/Jackdmp.xcodeproj/project.pbxproj
+++ b/macosx/Jackdmp.xcodeproj/project.pbxproj
@@ -323,6 +323,83 @@
 		4B43A8CB1014605000E52943 /* JackLoopbackDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B43A8C91014605000E52943 /* JackLoopbackDriver.h */; };
 		4B43A8DF1014615800E52943 /* JackLoopbackDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B43A8C91014605000E52943 /* JackLoopbackDriver.h */; };
 		4B43A8E11014615800E52943 /* JackLoopbackDriver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B43A8C81014605000E52943 /* JackLoopbackDriver.cpp */; };
+		4B47AC8210B5890100469C67 /* JackMachPort.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B799AD707899652003F3F15 /* JackMachPort.h */; };
+		4B47AC8310B5890100469C67 /* JackError.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1770834EE4800C94B91 /* JackError.h */; };
+		4B47AC8410B5890100469C67 /* JackTime.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1830834EE5800C94B91 /* JackTime.h */; };
+		4B47AC8510B5890100469C67 /* JackShmMem.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1870834EE7900C94B91 /* JackShmMem.h */; };
+		4B47AC8610B5890100469C67 /* shm.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D18F0834EE8400C94B91 /* shm.h */; };
+		4B47AC8710B5890100469C67 /* JackThread.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D19F0834EE9E00C94B91 /* JackThread.h */; };
+		4B47AC8810B5890100469C67 /* JackActivationCount.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1A70834EEB400C94B91 /* JackActivationCount.h */; };
+		4B47AC8910B5890100469C67 /* JackChannel.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1AF0834EEC400C94B91 /* JackChannel.h */; };
+		4B47AC8A10B5890100469C67 /* JackGraphManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1C70834EF2200C94B91 /* JackGraphManager.h */; };
+		4B47AC8B10B5890100469C67 /* JackPort.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1CF0834EF2F00C94B91 /* JackPort.h */; };
+		4B47AC8C10B5890100469C67 /* JackClientInterface.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1D90834EF4500C94B91 /* JackClientInterface.h */; };
+		4B47AC8D10B5890100469C67 /* JackClientControl.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1DD0834EF4D00C94B91 /* JackClientControl.h */; };
+		4B47AC8E10B5890100469C67 /* JackClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1E10834EF5500C94B91 /* JackClient.h */; };
+		4B47AC8F10B5890100469C67 /* JackInternalClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1EE0834EF9200C94B91 /* JackInternalClient.h */; };
+		4B47AC9010B5890100469C67 /* JackLibGlobals.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1FB0834EFD100C94B91 /* JackLibGlobals.h */; };
+		4B47AC9110B5890100469C67 /* JackLibClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1FC0834EFD100C94B91 /* JackLibClient.h */; };
+		4B47AC9210B5890100469C67 /* JackConnectionManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8D1C30834EF1400C94B91 /* JackConnectionManager.h */; };
+		4B47AC9310B5890100469C67 /* JackFrameTimer.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF8FB0E08AC88EF00D1A344 /* JackFrameTimer.h */; };
+		4B47AC9410B5890100469C67 /* JackMachSemaphore.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF6C1D608ACE64C001E2013 /* JackMachSemaphore.h */; };
+		4B47AC9510B5890100469C67 /* JackGlobals.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BFB73F608AD291A00DB99B8 /* JackGlobals.h */; };
+		4B47AC9610B5890100469C67 /* JackMachThread.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BFB741F08AD2B9900DB99B8 /* JackMachThread.h */; };
+		4B47AC9710B5890100469C67 /* JackMachClientChannel.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BFB298708AF450200D450D4 /* JackMachClientChannel.h */; };
+		4B47AC9810B5890100469C67 /* JackSynchro.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BD561C708EEB910006BBC2A /* JackSynchro.h */; };
+		4B47AC9910B5890100469C67 /* JackDebugClient.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B98AE010931D30C0091932A /* JackDebugClient.h */; };
+		4B47AC9A10B5890100469C67 /* JackConstants.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B66A8580934964500A89560 /* JackConstants.h */; };
+		4B47AC9B10B5890100469C67 /* JackTransportEngine.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BD4B4D409BACD9600750C0F /* JackTransportEngine.h */; };
+		4B47AC9C10B5890100469C67 /* timestamps.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BF520580CB8D1010037470E /* timestamps.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47AC9D10B5890100469C67 /* intclient.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C73790CC60A6D001AFFD4 /* intclient.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47AC9E10B5890100469C67 /* jack.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C737A0CC60A6D001AFFD4 /* jack.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47AC9F10B5890100469C67 /* ringbuffer.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C737B0CC60A6D001AFFD4 /* ringbuffer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA010B5890100469C67 /* statistics.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C737C0CC60A6D001AFFD4 /* statistics.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA110B5890100469C67 /* thread.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C737D0CC60A6D001AFFD4 /* thread.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA210B5890100469C67 /* transport.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C737E0CC60A6D001AFFD4 /* transport.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA310B5890100469C67 /* types.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6C737F0CC60A6D001AFFD4 /* types.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA410B5890100469C67 /* JackPortType.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BAB95B70B9E20B800A0C723 /* JackPortType.h */; };
+		4B47ACA510B5890100469C67 /* JackMidiPort.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B80D7E50BA0D17400F035BB /* JackMidiPort.h */; };
+		4B47ACA610B5890100469C67 /* midiport.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B6B9EF50CD0958B0051EE5A /* midiport.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA710B5890100469C67 /* JackTools.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BE4CC000CDA153400CCF5BB /* JackTools.h */; };
+		4B47ACA810B5890100469C67 /* jslist.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B9A26000DBF8584006E9FBC /* jslist.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B47ACA910B5890100469C67 /* JackMessageBuffer.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4F9C8B0DC20C0400706CB0 /* JackMessageBuffer.h */; };
+		4B47ACAA10B5890100469C67 /* JackPosixThread.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BC3B6A30E703B2E0066E42F /* JackPosixThread.h */; };
+		4B47ACAB10B5890100469C67 /* JackProcessSync.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BECB2F40F4451C10091B70A /* JackProcessSync.h */; };
+		4B47ACAE10B5890100469C67 /* JackMacLibClientRPC.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF3937C0626BF3600CC67FA /* JackMacLibClientRPC.cpp */; };
+		4B47ACAF10B5890100469C67 /* JackRPCEngineUser.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B89B769076B74D200D170DE /* JackRPCEngineUser.c */; };
+		4B47ACB010B5890100469C67 /* JackMachPort.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B799AD607899652003F3F15 /* JackMachPort.cpp */; };
+		4B47ACB110B5890100469C67 /* JackShmMem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1880834EE7900C94B91 /* JackShmMem.cpp */; };
+		4B47ACB210B5890100469C67 /* shm.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1900834EE8400C94B91 /* shm.c */; };
+		4B47ACB310B5890100469C67 /* JackActivationCount.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1A80834EEB400C94B91 /* JackActivationCount.cpp */; };
+		4B47ACB410B5890100469C67 /* JackGraphManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1C80834EF2200C94B91 /* JackGraphManager.cpp */; };
+		4B47ACB510B5890100469C67 /* JackPort.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1D00834EF2F00C94B91 /* JackPort.cpp */; };
+		4B47ACB610B5890100469C67 /* JackClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1E50834EF6700C94B91 /* JackClient.cpp */; };
+		4B47ACB710B5890100469C67 /* JackAPI.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1E90834EF7500C94B91 /* JackAPI.cpp */; };
+		4B47ACB810B5890100469C67 /* JackLibClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1FD0834EFD100C94B91 /* JackLibClient.cpp */; };
+		4B47ACB910B5890100469C67 /* JackLibAPI.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1FE0834EFD100C94B91 /* JackLibAPI.cpp */; };
+		4B47ACBA10B5890100469C67 /* JackConnectionManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8D1C40834EF1400C94B91 /* JackConnectionManager.cpp */; };
+		4B47ACBB10B5890100469C67 /* JackFrameTimer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF8FB0D08AC88EF00D1A344 /* JackFrameTimer.cpp */; };
+		4B47ACBC10B5890100469C67 /* JackMachSemaphore.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF6C1D508ACE64C001E2013 /* JackMachSemaphore.cpp */; };
+		4B47ACBD10B5890100469C67 /* JackMachThread.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BFB741E08AD2B9900DB99B8 /* JackMachThread.cpp */; };
+		4B47ACBE10B5890100469C67 /* JackMachClientChannel.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BFB29AE08AF45FD00D450D4 /* JackMachClientChannel.cpp */; };
+		4B47ACBF10B5890100469C67 /* JackGlobals.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B2C28F908DAD01E00249230 /* JackGlobals.cpp */; };
+		4B47ACC010B5890100469C67 /* ringbuffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B003AB008E2B2BA0060EFDC /* ringbuffer.c */; };
+		4B47ACC110B5890100469C67 /* JackDebugClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B98AE000931D30C0091932A /* JackDebugClient.cpp */; };
+		4B47ACC210B5890100469C67 /* JackTransportEngine.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BD4B4D509BACD9600750C0F /* JackTransportEngine.cpp */; };
+		4B47ACC310B5890100469C67 /* timestamps.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BF520520CB8D0E80037470E /* timestamps.c */; };
+		4B47ACC410B5890100469C67 /* JackPortType.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BAB95B60B9E20B800A0C723 /* JackPortType.cpp */; };
+		4B47ACC510B5890100469C67 /* JackAudioPort.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BAB95EC0B9E21A500A0C723 /* JackAudioPort.cpp */; };
+		4B47ACC610B5890100469C67 /* JackMidiPort.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B80D7E60BA0D17400F035BB /* JackMidiPort.cpp */; };
+		4B47ACC710B5890100469C67 /* JackMidiAPI.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B80D7E70BA0D17400F035BB /* JackMidiAPI.cpp */; };
+		4B47ACC810B5890100469C67 /* JackEngineControl.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B6F7AEC0CD0CDBD00F48A9D /* JackEngineControl.cpp */; };
+		4B47ACC910B5890100469C67 /* JackTools.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BE4CBFF0CDA153400CCF5BB /* JackTools.cpp */; };
+		4B47ACCA10B5890100469C67 /* JackError.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B9A25B30DBF8330006E9FBC /* JackError.cpp */; };
+		4B47ACCB10B5890100469C67 /* JackMessageBuffer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B4F9C8A0DC20C0400706CB0 /* JackMessageBuffer.cpp */; };
+		4B47ACCC10B5890100469C67 /* JackPosixServerLaunch.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BF5FBBA0E878B9C003D2374 /* JackPosixServerLaunch.cpp */; };
+		4B47ACCD10B5890100469C67 /* JackPosixThread.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BC3B6A20E703B2E0066E42F /* JackPosixThread.cpp */; };
+		4B47ACCE10B5890100469C67 /* JackMachTime.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BF5FBC80E878D24003D2374 /* JackMachTime.c */; };
+		4B47ACCF10B5890100469C67 /* JackProcessSync.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BECB2F30F4451C10091B70A /* JackProcessSync.cpp */; };
+		4B47ACD210B5890100469C67 /* Accelerate.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4BCC87950D57168300A7FEB1 /* Accelerate.framework */; };
 		4B4CA9750E02CF9600F4BFDA /* JackRestartThreadedDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4CA9730E02CF9600F4BFDA /* JackRestartThreadedDriver.h */; };
 		4B4CA9760E02CF9600F4BFDA /* JackRestartThreadedDriver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4B4CA9740E02CF9600F4BFDA /* JackRestartThreadedDriver.cpp */; };
 		4B4CA9770E02CF9600F4BFDA /* JackRestartThreadedDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4CA9730E02CF9600F4BFDA /* JackRestartThreadedDriver.h */; };
@@ -638,11 +715,11 @@
 		4BA4ADB50E87AB2600F26C85 /* JackCoreAudioDriver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BE5FECC0E725C090020B576 /* JackCoreAudioDriver.h */; };
 		4BA692B30CBE4C2D00EAD520 /* ipload.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BA692B20CBE4C2D00EAD520 /* ipload.c */; };
 		4BA692D70CBE4CC600EAD520 /* ipunload.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BA692D60CBE4CC600EAD520 /* ipunload.c */; };
-		4BA7BE0F0DC232A400AA3457 /* Jackservermp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */; };
-		4BA7BE1A0DC2347500AA3457 /* Jackservermp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */; };
-		4BA7BE200DC234FB00AA3457 /* Jackservermp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */; };
-		4BA7BE240DC2350D00AA3457 /* Jackservermp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */; };
-		4BA7BE270DC2352A00AA3457 /* Jackservermp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */; };
+		4BA7BE0F0DC232A400AA3457 /* Jackdmp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */; };
+		4BA7BE1A0DC2347500AA3457 /* Jackdmp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */; };
+		4BA7BE200DC234FB00AA3457 /* Jackdmp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */; };
+		4BA7BE240DC2350D00AA3457 /* Jackdmp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */; };
+		4BA7BE270DC2352A00AA3457 /* Jackdmp.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */; };
 		4BA7FECA0D8E76650017FF73 /* control.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BA7FEC80D8E76650017FF73 /* control.c */; };
 		4BAB95B80B9E20B800A0C723 /* JackPortType.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BAB95B60B9E20B800A0C723 /* JackPortType.cpp */; };
 		4BAB95B90B9E20B800A0C723 /* JackPortType.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BAB95B70B9E20B800A0C723 /* JackPortType.h */; };
@@ -676,6 +753,18 @@
 		4BC3B6BE0E703BCC0066E42F /* JackNetUnixSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BC3B6BA0E703BCC0066E42F /* JackNetUnixSocket.h */; };
 		4BC3B6BF0E703BCC0066E42F /* JackNetUnixSocket.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BC3B6B90E703BCC0066E42F /* JackNetUnixSocket.cpp */; };
 		4BC3B6C00E703BCC0066E42F /* JackNetUnixSocket.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BC3B6BA0E703BCC0066E42F /* JackNetUnixSocket.h */; };
+		4BCBCE5D10C4FE3F00450FFE /* JackPhysicalMidiInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BCBCE5910C4FE3F00450FFE /* JackPhysicalMidiInput.cpp */; };
+		4BCBCE5E10C4FE3F00450FFE /* JackPhysicalMidiInput.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BCBCE5A10C4FE3F00450FFE /* JackPhysicalMidiInput.h */; };
+		4BCBCE5F10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BCBCE5B10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp */; };
+		4BCBCE6010C4FE3F00450FFE /* JackPhysicalMidiOutput.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BCBCE5C10C4FE3F00450FFE /* JackPhysicalMidiOutput.h */; };
+		4BCBCE6110C4FE3F00450FFE /* JackPhysicalMidiInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BCBCE5910C4FE3F00450FFE /* JackPhysicalMidiInput.cpp */; };
+		4BCBCE6210C4FE3F00450FFE /* JackPhysicalMidiInput.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BCBCE5A10C4FE3F00450FFE /* JackPhysicalMidiInput.h */; };
+		4BCBCE6310C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BCBCE5B10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp */; };
+		4BCBCE6410C4FE3F00450FFE /* JackPhysicalMidiOutput.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BCBCE5C10C4FE3F00450FFE /* JackPhysicalMidiOutput.h */; };
+		4BCBCE6510C4FE3F00450FFE /* JackPhysicalMidiInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BCBCE5910C4FE3F00450FFE /* JackPhysicalMidiInput.cpp */; };
+		4BCBCE6610C4FE3F00450FFE /* JackPhysicalMidiInput.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BCBCE5A10C4FE3F00450FFE /* JackPhysicalMidiInput.h */; };
+		4BCBCE6710C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4BCBCE5B10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp */; };
+		4BCBCE6810C4FE3F00450FFE /* JackPhysicalMidiOutput.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BCBCE5C10C4FE3F00450FFE /* JackPhysicalMidiOutput.h */; };
 		4BCC87960D57168300A7FEB1 /* Accelerate.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4BCC87950D57168300A7FEB1 /* Accelerate.framework */; };
 		4BCC87970D57168300A7FEB1 /* Accelerate.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4BCC87950D57168300A7FEB1 /* Accelerate.framework */; };
 		4BCC87980D57168300A7FEB1 /* Accelerate.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4BCC87950D57168300A7FEB1 /* Accelerate.framework */; };
@@ -1353,7 +1442,7 @@
 		4B0A28E60D52073D002EFF74 /* jack_thread_wait */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_thread_wait; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B0A28EC0D520852002EFF74 /* tw.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = tw.c; path = "../example-clients/tw.c"; sourceTree = SOURCE_ROOT; };
 		4B0A292D0D52108E002EFF74 /* jack_thread_wait */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_thread_wait; sourceTree = BUILT_PRODUCTS_DIR; };
-		4B19B3000E23620F00DD4A82 /* audioadapter.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = audioadapter.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B19B3000E23620F00DD4A82 /* netmanager.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netmanager.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B19B3060E2362E700DD4A82 /* JackAudioAdapter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackAudioAdapter.cpp; path = ../common/JackAudioAdapter.cpp; sourceTree = SOURCE_ROOT; };
 		4B19B3070E2362E700DD4A82 /* JackAudioAdapter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackAudioAdapter.h; path = ../common/JackAudioAdapter.h; sourceTree = SOURCE_ROOT; };
 		4B19B3080E2362E700DD4A82 /* JackAudioAdapterInterface.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackAudioAdapterInterface.cpp; path = ../common/JackAudioAdapterInterface.cpp; sourceTree = SOURCE_ROOT; };
@@ -1376,7 +1465,7 @@
 		4B32257B10A3190C00838A8E /* jack_netsource */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_netsource; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C4250D4731D1000DE7AE /* jackdmp */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jackdmp; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C4830D4731D1000DE7AE /* Jackmp.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jackmp.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jackservermp.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jackdmp.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C5140D4731D1000DE7AE /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C5200D4731D1000DE7AE /* jack_midisine */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midisine; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C52C0D4731D1000DE7AE /* jack_metro */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_metro; sourceTree = BUILT_PRODUCTS_DIR; };
@@ -1400,30 +1489,31 @@
 		4B35C6290D4731D2000DE7AE /* jack_portaudio.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_portaudio.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C6340D4731D2000DE7AE /* jack_dummy.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_dummy.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B35C63E0D4731D3000DE7AE /* inprocess.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = inprocess.so; sourceTree = BUILT_PRODUCTS_DIR; };
-		4B363DD80DEB02F6001F72D9 /* jack_alias */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_alias; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B363DD80DEB02F6001F72D9 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363DDE0DEB034E001F72D9 /* alias.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = alias.c; path = "../example-clients/alias.c"; sourceTree = SOURCE_ROOT; };
-		4B363E1A0DEB03C5001F72D9 /* jack_evmon */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_evmon; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B363E1A0DEB03C5001F72D9 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363E200DEB0401001F72D9 /* evmon.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = evmon.c; path = "../example-clients/evmon.c"; sourceTree = SOURCE_ROOT; };
-		4B363E4E0DEB0775001F72D9 /* jack_bufsize */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_bufsize; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B363E4E0DEB0775001F72D9 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363E710DEB0808001F72D9 /* bufsize.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = bufsize.c; path = "../example-clients/bufsize.c"; sourceTree = SOURCE_ROOT; };
-		4B363EE90DEB091C001F72D9 /* jack_rec */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_rec; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B363EE90DEB091C001F72D9 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363EED0DEB094B001F72D9 /* capture_client.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = capture_client.c; path = "../example-clients/capture_client.c"; sourceTree = SOURCE_ROOT; };
-		4B363F1E0DEB0A6A001F72D9 /* jack_monitor_client */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_monitor_client; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B363F1E0DEB0A6A001F72D9 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363F220DEB0AB0001F72D9 /* monitor_client.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = monitor_client.c; path = "../example-clients/monitor_client.c"; sourceTree = SOURCE_ROOT; };
 		4B363F350DEB0BD1001F72D9 /* jack_showtime */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_showtime; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363F3D0DEB0C31001F72D9 /* showtime.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = showtime.c; path = "../example-clients/showtime.c"; sourceTree = SOURCE_ROOT; };
-		4B363F720DEB0D4E001F72D9 /* jack_impulse_grabber */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_impulse_grabber; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B363F720DEB0D4E001F72D9 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B363F750DEB0D7D001F72D9 /* impulse_grabber.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = impulse_grabber.c; path = "../example-clients/impulse_grabber.c"; sourceTree = SOURCE_ROOT; };
 		4B37C20306DF1FBE0016E567 /* CALatencyLog.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = CALatencyLog.cpp; path = /Developer/Examples/CoreAudio/PublicUtility/CALatencyLog.cpp; sourceTree = "<absolute>"; };
 		4B37C20406DF1FBE0016E567 /* CALatencyLog.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = CALatencyLog.h; path = /Developer/Examples/CoreAudio/PublicUtility/CALatencyLog.h; sourceTree = "<absolute>"; };
 		4B37C20906DF1FE20016E567 /* latency.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = latency.c; path = /Developer/Examples/CoreAudio/PublicUtility/latency.c; sourceTree = "<absolute>"; };
 		4B3F49070AD8503300491C6E /* cpu.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = cpu.c; path = ../tests/cpu.c; sourceTree = SOURCE_ROOT; };
 		4B4259E5076B635E00C1ECE1 /* JackMacEngineRPC.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = JackMacEngineRPC.cpp; sourceTree = SOURCE_ROOT; };
-		4B43A8BA10145F6F00E52943 /* jack_loopback.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_loopback.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B43A8BA10145F6F00E52943 /* jack_dummy.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_dummy.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B43A8C81014605000E52943 /* JackLoopbackDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackLoopbackDriver.cpp; path = ../common/JackLoopbackDriver.cpp; sourceTree = SOURCE_ROOT; };
 		4B43A8C91014605000E52943 /* JackLoopbackDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackLoopbackDriver.h; path = ../common/JackLoopbackDriver.h; sourceTree = SOURCE_ROOT; };
-		4B43A8E71014615800E52943 /* jack_loopback.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_loopback.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B43A8E71014615800E52943 /* jack_dummy.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_dummy.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B464301076CAC7700E5077C /* Jack-Info.plist */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = text.plist.xml; path = "Jack-Info.plist"; sourceTree = SOURCE_ROOT; };
+		4B47ACD710B5890100469C67 /* Jackmp.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jackmp.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B4CA9730E02CF9600F4BFDA /* JackRestartThreadedDriver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackRestartThreadedDriver.h; path = ../common/JackRestartThreadedDriver.h; sourceTree = SOURCE_ROOT; };
 		4B4CA9740E02CF9600F4BFDA /* JackRestartThreadedDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackRestartThreadedDriver.cpp; path = ../common/JackRestartThreadedDriver.cpp; sourceTree = SOURCE_ROOT; };
 		4B4E9AF80E5F1090000A3278 /* JackControlAPI.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackControlAPI.cpp; path = ../common/JackControlAPI.cpp; sourceTree = SOURCE_ROOT; };
@@ -1435,7 +1525,7 @@
 		4B5A1BBD0CD1CC110005BF74 /* midiseq.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = midiseq.c; path = "../example-clients/midiseq.c"; sourceTree = SOURCE_ROOT; };
 		4B5A1BDA0CD1CCE10005BF74 /* jack_midisine */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midisine; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B5A1BDC0CD1CD420005BF74 /* midisine.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = midisine.c; path = "../example-clients/midisine.c"; sourceTree = SOURCE_ROOT; };
-		4B5E08D50E5B66EE00BEE4E0 /* netadapter.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netadapter.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B5E08D50E5B66EE00BEE4E0 /* netmanager.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netmanager.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4B5E08DF0E5B676C00BEE4E0 /* JackNetAdapter.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = JackNetAdapter.cpp; path = ../common/JackNetAdapter.cpp; sourceTree = SOURCE_ROOT; };
 		4B5E08E00E5B676C00BEE4E0 /* JackNetAdapter.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = JackNetAdapter.h; path = ../common/JackNetAdapter.h; sourceTree = SOURCE_ROOT; };
 		4B5F253D0DEE9B8F0041E486 /* JackLockedEngine.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackLockedEngine.h; path = ../common/JackLockedEngine.h; sourceTree = SOURCE_ROOT; };
@@ -1487,15 +1577,14 @@
 		4B98AE010931D30C0091932A /* JackDebugClient.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = JackDebugClient.h; path = ../common/JackDebugClient.h; sourceTree = SOURCE_ROOT; };
 		4B9A25B30DBF8330006E9FBC /* JackError.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackError.cpp; path = ../common/JackError.cpp; sourceTree = SOURCE_ROOT; };
 		4B9A26000DBF8584006E9FBC /* jslist.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = jslist.h; path = ../common/jack/jslist.h; sourceTree = SOURCE_ROOT; };
-		4BA339AC10B2E36800190E3B /* Jackservermp.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jackservermp.framework; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BA339AD10B2E36800190E3B /* Jack-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "Jack-Info.plist"; sourceTree = "<group>"; };
+		4BA339AC10B2E36800190E3B /* Jackdmp.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jackdmp.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BA577BC08BF8BE200F82DE1 /* testSynchroClient.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = testSynchroClient.cpp; path = ../tests/testSynchroClient.cpp; sourceTree = SOURCE_ROOT; };
 		4BA577FB08BF8E4600F82DE1 /* testSynchroServer.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = testSynchroServer.cpp; path = ../tests/testSynchroServer.cpp; sourceTree = SOURCE_ROOT; };
 		4BA692B00CBE4BC700EAD520 /* jack_load */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_load; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BA692B20CBE4C2D00EAD520 /* ipload.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = ipload.c; path = "../example-clients/ipload.c"; sourceTree = SOURCE_ROOT; };
 		4BA692D40CBE4C9000EAD520 /* jack_unload */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_unload; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BA692D60CBE4CC600EAD520 /* ipunload.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = ipunload.c; path = "../example-clients/ipunload.c"; sourceTree = SOURCE_ROOT; };
-		4BA7FEC30D8E76270017FF73 /* jack_server_control */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_server_control; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BA7FEC30D8E76270017FF73 /* jack_lsp */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_lsp; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BA7FEC80D8E76650017FF73 /* control.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = control.c; path = "../example-clients/control.c"; sourceTree = SOURCE_ROOT; };
 		4BAB95B60B9E20B800A0C723 /* JackPortType.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = JackPortType.cpp; path = ../common/JackPortType.cpp; sourceTree = SOURCE_ROOT; };
 		4BAB95B70B9E20B800A0C723 /* JackPortType.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = JackPortType.h; path = ../common/JackPortType.h; sourceTree = SOURCE_ROOT; };
@@ -1531,6 +1620,10 @@
 		4BC3B6B90E703BCC0066E42F /* JackNetUnixSocket.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackNetUnixSocket.cpp; path = ../posix/JackNetUnixSocket.cpp; sourceTree = SOURCE_ROOT; };
 		4BC3B6BA0E703BCC0066E42F /* JackNetUnixSocket.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackNetUnixSocket.h; path = ../posix/JackNetUnixSocket.h; sourceTree = SOURCE_ROOT; };
 		4BC8326D0DF42C7D00DD1C93 /* JackMutex.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackMutex.h; path = ../common/JackMutex.h; sourceTree = SOURCE_ROOT; };
+		4BCBCE5910C4FE3F00450FFE /* JackPhysicalMidiInput.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackPhysicalMidiInput.cpp; path = ../common/JackPhysicalMidiInput.cpp; sourceTree = SOURCE_ROOT; };
+		4BCBCE5A10C4FE3F00450FFE /* JackPhysicalMidiInput.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackPhysicalMidiInput.h; path = ../common/JackPhysicalMidiInput.h; sourceTree = SOURCE_ROOT; };
+		4BCBCE5B10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JackPhysicalMidiOutput.cpp; path = ../common/JackPhysicalMidiOutput.cpp; sourceTree = SOURCE_ROOT; };
+		4BCBCE5C10C4FE3F00450FFE /* JackPhysicalMidiOutput.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JackPhysicalMidiOutput.h; path = ../common/JackPhysicalMidiOutput.h; sourceTree = SOURCE_ROOT; };
 		4BCC87950D57168300A7FEB1 /* Accelerate.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Accelerate.framework; path = /System/Library/Frameworks/Accelerate.framework; sourceTree = "<absolute>"; };
 		4BD4B4D409BACD9600750C0F /* JackTransportEngine.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = JackTransportEngine.h; path = ../common/JackTransportEngine.h; sourceTree = SOURCE_ROOT; };
 		4BD4B4D509BACD9600750C0F /* JackTransportEngine.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = JackTransportEngine.cpp; path = ../common/JackTransportEngine.cpp; sourceTree = SOURCE_ROOT; };
@@ -1540,8 +1633,8 @@
 		4BDCDB9D1001FB9C00B15929 /* jack_coremidi.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_coremidi.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BDCDBC51001FCC000B15929 /* jack_net.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_net.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BDCDBE81001FD2D00B15929 /* netmanager.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netmanager.so; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BDCDBFF1001FD7300B15929 /* audioadapter.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = audioadapter.so; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BDCDC251001FDE300B15929 /* netadapter.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netadapter.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BDCDBFF1001FD7300B15929 /* netmanager.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netmanager.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BDCDC251001FDE300B15929 /* netmanager.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = netmanager.so; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BE4CBFF0CDA153400CCF5BB /* JackTools.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = JackTools.cpp; path = ../common/JackTools.cpp; sourceTree = SOURCE_ROOT; };
 		4BE4CC000CDA153400CCF5BB /* JackTools.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = JackTools.h; path = ../common/JackTools.h; sourceTree = SOURCE_ROOT; };
 		4BE5FECB0E725C090020B576 /* JackCoreAudioDriver.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = JackCoreAudioDriver.cpp; path = coreaudio/JackCoreAudioDriver.cpp; sourceTree = SOURCE_ROOT; };
@@ -1623,14 +1716,14 @@
 		4BF8D2470834F20600C94B91 /* testSem.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = testSem.cpp; path = ../tests/testSem.cpp; sourceTree = SOURCE_ROOT; };
 		4BF8FB0D08AC88EF00D1A344 /* JackFrameTimer.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = JackFrameTimer.cpp; path = ../common/JackFrameTimer.cpp; sourceTree = SOURCE_ROOT; };
 		4BF8FB0E08AC88EF00D1A344 /* JackFrameTimer.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = JackFrameTimer.h; path = ../common/JackFrameTimer.h; sourceTree = SOURCE_ROOT; };
-		4BFA5E980DEC4D9C00FA4CDB /* testMutex */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = testMutex; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BFA5E980DEC4D9C00FA4CDB /* testSem */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = testSem; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BFA5E9E0DEC4DD900FA4CDB /* testMutex.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = testMutex.cpp; path = ../tests/testMutex.cpp; sourceTree = SOURCE_ROOT; };
-		4BFA828C0DF6A9E40087B4E1 /* jack_evmon */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_evmon; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BFA829F0DF6A9E40087B4E1 /* jack_bufsize */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_bufsize; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BFA82AB0DF6A9E40087B4E1 /* jack_rec */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_rec; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BFA82B70DF6A9E40087B4E1 /* jack_monitor_client */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_monitor_client; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BFA828C0DF6A9E40087B4E1 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BFA829F0DF6A9E40087B4E1 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BFA82AB0DF6A9E40087B4E1 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BFA82B70DF6A9E40087B4E1 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BFA82C30DF6A9E40087B4E1 /* jack_showtime */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_showtime; sourceTree = BUILT_PRODUCTS_DIR; };
-		4BFA82CF0DF6A9E40087B4E1 /* jack_impulse_grabber */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_impulse_grabber; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BFA82CF0DF6A9E40087B4E1 /* jack_midiseq */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jack_midiseq; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BFA99A20AAAF3B0009E916C /* jdelay */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = jdelay; sourceTree = BUILT_PRODUCTS_DIR; };
 		4BFA99A90AAAF40C009E916C /* jdelay.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; name = jdelay.cpp; path = ../tests/jdelay.cpp; sourceTree = SOURCE_ROOT; };
 		4BFB297708AF44ED00D450D4 /* JackMachServerNotifyChannel.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = JackMachServerNotifyChannel.cpp; sourceTree = "<group>"; };
@@ -1796,7 +1889,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4BA7BE0F0DC232A400AA3457 /* Jackservermp.framework in Frameworks */,
+				4BA7BE0F0DC232A400AA3457 /* Jackdmp.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1804,7 +1897,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4BA7BE1A0DC2347500AA3457 /* Jackservermp.framework in Frameworks */,
+				4BA7BE1A0DC2347500AA3457 /* Jackdmp.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1847,7 +1940,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4BA7BE200DC234FB00AA3457 /* Jackservermp.framework in Frameworks */,
+				4BA7BE200DC234FB00AA3457 /* Jackdmp.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1855,7 +1948,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4BA7BE240DC2350D00AA3457 /* Jackservermp.framework in Frameworks */,
+				4BA7BE240DC2350D00AA3457 /* Jackdmp.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1863,7 +1956,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4BA7BE270DC2352A00AA3457 /* Jackservermp.framework in Frameworks */,
+				4BA7BE270DC2352A00AA3457 /* Jackdmp.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1958,6 +2051,14 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		4B47ACD110B5890100469C67 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B47ACD210B5890100469C67 /* Accelerate.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		4B5A1BB50CD1CB9E0005BF74 /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
@@ -2288,7 +2389,6 @@
 				0249A662FF388D9811CA2CEA /* External Frameworks and Libraries */,
 				1AB674ADFE9D54B511CA2CBB /* Products */,
 				4B464301076CAC7700E5077C /* Jack-Info.plist */,
-				4BA339AD10B2E36800190E3B /* Jack-Info.plist */,
 			);
 			name = JackServer;
 			sourceTree = "<group>";
@@ -2346,7 +2446,7 @@
 				4B5A1BDA0CD1CCE10005BF74 /* jack_midisine */,
 				4B35C4250D4731D1000DE7AE /* jackdmp */,
 				4B35C4830D4731D1000DE7AE /* Jackmp.framework */,
-				4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */,
+				4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */,
 				4B35C5140D4731D1000DE7AE /* jack_midiseq */,
 				4B35C5200D4731D1000DE7AE /* jack_midisine */,
 				4B35C52C0D4731D1000DE7AE /* jack_metro */,
@@ -2373,39 +2473,40 @@
 				4B0A28E60D52073D002EFF74 /* jack_thread_wait */,
 				4B0A292D0D52108E002EFF74 /* jack_thread_wait */,
 				4B57F5950D72C27900B4E719 /* jack_thread_wait */,
-				4BA7FEC30D8E76270017FF73 /* jack_server_control */,
+				4BA7FEC30D8E76270017FF73 /* jack_lsp */,
 				BA222ACF0DC88132001A17F4 /* jack_net.so */,
 				BA222AE90DC882DB001A17F4 /* netmanager.so */,
-				4BA7FEC30D8E76270017FF73 /* jack_server_control */,
-				4B363DD80DEB02F6001F72D9 /* jack_alias */,
-				4B363E1A0DEB03C5001F72D9 /* jack_evmon */,
-				4B363E4E0DEB0775001F72D9 /* jack_bufsize */,
-				4B363EE90DEB091C001F72D9 /* jack_rec */,
-				4B363F1E0DEB0A6A001F72D9 /* jack_monitor_client */,
+				4BA7FEC30D8E76270017FF73 /* jack_lsp */,
+				4B363DD80DEB02F6001F72D9 /* jack_midiseq */,
+				4B363E1A0DEB03C5001F72D9 /* jack_midiseq */,
+				4B363E4E0DEB0775001F72D9 /* jack_midiseq */,
+				4B363EE90DEB091C001F72D9 /* jack_midiseq */,
+				4B363F1E0DEB0A6A001F72D9 /* jack_midiseq */,
 				4B363F350DEB0BD1001F72D9 /* jack_showtime */,
-				4B363F720DEB0D4E001F72D9 /* jack_impulse_grabber */,
-				4BFA5E980DEC4D9C00FA4CDB /* testMutex */,
-				4BFA828C0DF6A9E40087B4E1 /* jack_evmon */,
-				4BFA829F0DF6A9E40087B4E1 /* jack_bufsize */,
-				4BFA82AB0DF6A9E40087B4E1 /* jack_rec */,
-				4BFA82B70DF6A9E40087B4E1 /* jack_monitor_client */,
+				4B363F720DEB0D4E001F72D9 /* jack_midiseq */,
+				4BFA5E980DEC4D9C00FA4CDB /* testSem */,
+				4BFA828C0DF6A9E40087B4E1 /* jack_midiseq */,
+				4BFA829F0DF6A9E40087B4E1 /* jack_midiseq */,
+				4BFA82AB0DF6A9E40087B4E1 /* jack_midiseq */,
+				4BFA82B70DF6A9E40087B4E1 /* jack_midiseq */,
 				4BFA82C30DF6A9E40087B4E1 /* jack_showtime */,
-				4BFA82CF0DF6A9E40087B4E1 /* jack_impulse_grabber */,
-				4B19B3000E23620F00DD4A82 /* audioadapter.so */,
-				4B5E08D50E5B66EE00BEE4E0 /* netadapter.so */,
+				4BFA82CF0DF6A9E40087B4E1 /* jack_midiseq */,
+				4B19B3000E23620F00DD4A82 /* netmanager.so */,
+				4B5E08D50E5B66EE00BEE4E0 /* netmanager.so */,
 				4BF3390C0F8B864B0080FB5B /* jack_coremidi.so */,
 				4BDCDB9D1001FB9C00B15929 /* jack_coremidi.so */,
 				4BDCDBC51001FCC000B15929 /* jack_net.so */,
 				4BDCDBE81001FD2D00B15929 /* netmanager.so */,
-				4BDCDBFF1001FD7300B15929 /* audioadapter.so */,
-				4BDCDC251001FDE300B15929 /* netadapter.so */,
-				4B43A8BA10145F6F00E52943 /* jack_loopback.so */,
-				4B43A8E71014615800E52943 /* jack_loopback.so */,
+				4BDCDBFF1001FD7300B15929 /* netmanager.so */,
+				4BDCDC251001FDE300B15929 /* netmanager.so */,
+				4B43A8BA10145F6F00E52943 /* jack_dummy.so */,
+				4B43A8E71014615800E52943 /* jack_dummy.so */,
 				4B3224E510A3156800838A8E /* jack_netone.so */,
 				4B32252B10A316B200838A8E /* jack_netone.so */,
 				4B32256110A3187800838A8E /* jack_netsource */,
 				4B32257B10A3190C00838A8E /* jack_netsource */,
-				4BA339AC10B2E36800190E3B /* Jackservermp.framework */,
+				4BA339AC10B2E36800190E3B /* Jackdmp.framework */,
+				4B47ACD710B5890100469C67 /* Jackmp.framework */,
 			);
 			name = Products;
 			sourceTree = "<group>";
@@ -2856,6 +2957,10 @@
 		4BF3390D0F8B86AF0080FB5B /* MIDI */ = {
 			isa = PBXGroup;
 			children = (
+				4BCBCE5910C4FE3F00450FFE /* JackPhysicalMidiInput.cpp */,
+				4BCBCE5A10C4FE3F00450FFE /* JackPhysicalMidiInput.h */,
+				4BCBCE5B10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp */,
+				4BCBCE5C10C4FE3F00450FFE /* JackPhysicalMidiOutput.h */,
 				4BF3391F0F8B873E0080FB5B /* JackMidiDriver.cpp */,
 				4BF339200F8B873E0080FB5B /* JackMidiDriver.h */,
 				4BF339140F8B86DC0080FB5B /* JackCoreMidiDriver.h */,
@@ -3120,6 +3225,8 @@
 				4BF339220F8B873E0080FB5B /* JackMidiDriver.h in Headers */,
 				4BDCDBD21001FD0200B15929 /* JackWaitThreadedDriver.h in Headers */,
 				4BDCDC0A1001FDA800B15929 /* JackArgParser.h in Headers */,
+				4BCBCE6210C4FE3F00450FFE /* JackPhysicalMidiInput.h in Headers */,
+				4BCBCE6410C4FE3F00450FFE /* JackPhysicalMidiOutput.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3354,6 +3461,55 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		4B47AC8110B5890100469C67 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B47AC8210B5890100469C67 /* JackMachPort.h in Headers */,
+				4B47AC8310B5890100469C67 /* JackError.h in Headers */,
+				4B47AC8410B5890100469C67 /* JackTime.h in Headers */,
+				4B47AC8510B5890100469C67 /* JackShmMem.h in Headers */,
+				4B47AC8610B5890100469C67 /* shm.h in Headers */,
+				4B47AC8710B5890100469C67 /* JackThread.h in Headers */,
+				4B47AC8810B5890100469C67 /* JackActivationCount.h in Headers */,
+				4B47AC8910B5890100469C67 /* JackChannel.h in Headers */,
+				4B47AC8A10B5890100469C67 /* JackGraphManager.h in Headers */,
+				4B47AC8B10B5890100469C67 /* JackPort.h in Headers */,
+				4B47AC8C10B5890100469C67 /* JackClientInterface.h in Headers */,
+				4B47AC8D10B5890100469C67 /* JackClientControl.h in Headers */,
+				4B47AC8E10B5890100469C67 /* JackClient.h in Headers */,
+				4B47AC8F10B5890100469C67 /* JackInternalClient.h in Headers */,
+				4B47AC9010B5890100469C67 /* JackLibGlobals.h in Headers */,
+				4B47AC9110B5890100469C67 /* JackLibClient.h in Headers */,
+				4B47AC9210B5890100469C67 /* JackConnectionManager.h in Headers */,
+				4B47AC9310B5890100469C67 /* JackFrameTimer.h in Headers */,
+				4B47AC9410B5890100469C67 /* JackMachSemaphore.h in Headers */,
+				4B47AC9510B5890100469C67 /* JackGlobals.h in Headers */,
+				4B47AC9610B5890100469C67 /* JackMachThread.h in Headers */,
+				4B47AC9710B5890100469C67 /* JackMachClientChannel.h in Headers */,
+				4B47AC9810B5890100469C67 /* JackSynchro.h in Headers */,
+				4B47AC9910B5890100469C67 /* JackDebugClient.h in Headers */,
+				4B47AC9A10B5890100469C67 /* JackConstants.h in Headers */,
+				4B47AC9B10B5890100469C67 /* JackTransportEngine.h in Headers */,
+				4B47AC9C10B5890100469C67 /* timestamps.h in Headers */,
+				4B47AC9D10B5890100469C67 /* intclient.h in Headers */,
+				4B47AC9E10B5890100469C67 /* jack.h in Headers */,
+				4B47AC9F10B5890100469C67 /* ringbuffer.h in Headers */,
+				4B47ACA010B5890100469C67 /* statistics.h in Headers */,
+				4B47ACA110B5890100469C67 /* thread.h in Headers */,
+				4B47ACA210B5890100469C67 /* transport.h in Headers */,
+				4B47ACA310B5890100469C67 /* types.h in Headers */,
+				4B47ACA410B5890100469C67 /* JackPortType.h in Headers */,
+				4B47ACA510B5890100469C67 /* JackMidiPort.h in Headers */,
+				4B47ACA610B5890100469C67 /* midiport.h in Headers */,
+				4B47ACA710B5890100469C67 /* JackTools.h in Headers */,
+				4B47ACA810B5890100469C67 /* jslist.h in Headers */,
+				4B47ACA910B5890100469C67 /* JackMessageBuffer.h in Headers */,
+				4B47ACAA10B5890100469C67 /* JackPosixThread.h in Headers */,
+				4B47ACAB10B5890100469C67 /* JackProcessSync.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		4B5A1BB20CD1CB9E0005BF74 /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
@@ -3506,6 +3662,8 @@
 				4BECB2F60F4451C10091B70A /* JackProcessSync.h in Headers */,
 				4BF339240F8B873E0080FB5B /* JackMidiDriver.h in Headers */,
 				4B94334B10A5E666002A187F /* systemdeps.h in Headers */,
+				4BCBCE5E10C4FE3F00450FFE /* JackPhysicalMidiInput.h in Headers */,
+				4BCBCE6010C4FE3F00450FFE /* JackPhysicalMidiOutput.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3681,6 +3839,8 @@
 				4BA3396D10B2E36800190E3B /* JackMidiDriver.h in Headers */,
 				4BA3396E10B2E36800190E3B /* JackWaitThreadedDriver.h in Headers */,
 				4BA3396F10B2E36800190E3B /* JackArgParser.h in Headers */,
+				4BCBCE6610C4FE3F00450FFE /* JackPhysicalMidiInput.h in Headers */,
+				4BCBCE6810C4FE3F00450FFE /* JackPhysicalMidiOutput.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3921,7 +4081,7 @@
 			);
 			name = "audioadapter Universal";
 			productName = jack_coreaudio;
-			productReference = 4B19B3000E23620F00DD4A82 /* audioadapter.so */;
+			productReference = 4B19B3000E23620F00DD4A82 /* netmanager.so */;
 			productType = "com.apple.product-type.library.dynamic";
 		};
 		4B3224D710A3156800838A8E /* jack_netone Universal */ = {
@@ -4050,7 +4210,7 @@
 			);
 			name = "Jackservermp.framework 64 bits";
 			productName = Jack;
-			productReference = 4B35C4FC0D4731D1000DE7AE /* Jackservermp.framework */;
+			productReference = 4B35C4FC0D4731D1000DE7AE /* Jackdmp.framework */;
 			productType = "com.apple.product-type.framework";
 		};
 		4B35C50A0D4731D1000DE7AE /* jack_midiseq 64 bits */ = {
@@ -4499,7 +4659,7 @@
 			name = "jack_alias Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4B363DD80DEB02F6001F72D9 /* jack_alias */;
+			productReference = 4B363DD80DEB02F6001F72D9 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4B363E100DEB03C5001F72D9 /* jack_evmon Universal */ = {
@@ -4518,7 +4678,7 @@
 			name = "jack_evmon Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4B363E1A0DEB03C5001F72D9 /* jack_evmon */;
+			productReference = 4B363E1A0DEB03C5001F72D9 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4B363E440DEB0775001F72D9 /* jack_bufsize Universal */ = {
@@ -4537,7 +4697,7 @@
 			name = "jack_bufsize Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4B363E4E0DEB0775001F72D9 /* jack_bufsize */;
+			productReference = 4B363E4E0DEB0775001F72D9 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4B363EDF0DEB091C001F72D9 /* jack_rec Universal */ = {
@@ -4556,7 +4716,7 @@
 			name = "jack_rec Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4B363EE90DEB091C001F72D9 /* jack_rec */;
+			productReference = 4B363EE90DEB091C001F72D9 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4B363F140DEB0A6A001F72D9 /* jack_monitor_client Universal */ = {
@@ -4575,7 +4735,7 @@
 			name = "jack_monitor_client Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4B363F1E0DEB0A6A001F72D9 /* jack_monitor_client */;
+			productReference = 4B363F1E0DEB0A6A001F72D9 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4B363F2B0DEB0BD1001F72D9 /* jack_showtime Universal */ = {
@@ -4613,7 +4773,7 @@
 			name = "jack_impulse_grabber Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4B363F720DEB0D4E001F72D9 /* jack_impulse_grabber */;
+			productReference = 4B363F720DEB0D4E001F72D9 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4B43A8B010145F6F00E52943 /* jack_loopback Universal */ = {
@@ -4630,7 +4790,7 @@
 			);
 			name = "jack_loopback Universal";
 			productName = jack_coreaudio;
-			productReference = 4B43A8BA10145F6F00E52943 /* jack_loopback.so */;
+			productReference = 4B43A8BA10145F6F00E52943 /* jack_dummy.so */;
 			productType = "com.apple.product-type.library.dynamic";
 		};
 		4B43A8DD1014615800E52943 /* jack_loopback 64 bits */ = {
@@ -4647,9 +4807,28 @@
 			);
 			name = "jack_loopback 64 bits";
 			productName = jack_coreaudio;
-			productReference = 4B43A8E71014615800E52943 /* jack_loopback.so */;
+			productReference = 4B43A8E71014615800E52943 /* jack_dummy.so */;
 			productType = "com.apple.product-type.library.dynamic";
 		};
+		4B47AC8010B5890100469C67 /* Jackmp.framework 64 bits debugging */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 4B47ACD310B5890100469C67 /* Build configuration list for PBXNativeTarget "Jackmp.framework 64 bits debugging" */;
+			buildPhases = (
+				4B47AC8110B5890100469C67 /* Headers */,
+				4B47ACAC10B5890100469C67 /* Resources */,
+				4B47ACAD10B5890100469C67 /* Sources */,
+				4B47ACD010B5890100469C67 /* Rez */,
+				4B47ACD110B5890100469C67 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "Jackmp.framework 64 bits debugging";
+			productName = Jack;
+			productReference = 4B47ACD710B5890100469C67 /* Jackmp.framework */;
+			productType = "com.apple.product-type.framework";
+		};
 		4B5A1BB10CD1CB9E0005BF74 /* jack_midiseq Universal */ = {
 			isa = PBXNativeTarget;
 			buildConfigurationList = 4B5A1BB70CD1CB9E0005BF74 /* Build configuration list for PBXNativeTarget "jack_midiseq Universal" */;
@@ -4702,7 +4881,7 @@
 			);
 			name = "netadapter Universal";
 			productName = jack_coreaudio;
-			productReference = 4B5E08D50E5B66EE00BEE4E0 /* netadapter.so */;
+			productReference = 4B5E08D50E5B66EE00BEE4E0 /* netmanager.so */;
 			productType = "com.apple.product-type.library.dynamic";
 		};
 		4B699BA7097D421600A18468 /* jackdmp framework Universal */ = {
@@ -5058,7 +5237,7 @@
 			);
 			name = "Jackservermp.framework 64 bits profiling";
 			productName = Jack;
-			productReference = 4BA339AC10B2E36800190E3B /* Jackservermp.framework */;
+			productReference = 4BA339AC10B2E36800190E3B /* Jackdmp.framework */;
 			productType = "com.apple.product-type.framework";
 		};
 		4BA692A60CBE4BC700EAD520 /* jack_load Universal */ = {
@@ -5115,7 +5294,7 @@
 			name = "jack_server_control Universal";
 			productInstallPath = /usr/local/bin;
 			productName = jack_lsp;
-			productReference = 4BA7FEC30D8E76270017FF73 /* jack_server_control */;
+			productReference = 4BA7FEC30D8E76270017FF73 /* jack_lsp */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BD623ED0CBCF0F000DE782F /* inprocess Universal */ = {
@@ -5200,7 +5379,7 @@
 			);
 			name = "audioadapter 64 bits";
 			productName = jack_coreaudio;
-			productReference = 4BDCDBFF1001FD7300B15929 /* audioadapter.so */;
+			productReference = 4BDCDBFF1001FD7300B15929 /* netmanager.so */;
 			productType = "com.apple.product-type.library.dynamic";
 		};
 		4BDCDC0F1001FDE300B15929 /* netadapter 64 bits */ = {
@@ -5217,7 +5396,7 @@
 			);
 			name = "netadapter 64 bits";
 			productName = jack_coreaudio;
-			productReference = 4BDCDC251001FDE300B15929 /* netadapter.so */;
+			productReference = 4BDCDC251001FDE300B15929 /* netmanager.so */;
 			productType = "com.apple.product-type.library.dynamic";
 		};
 		4BE6C6910A3E096F005A203A /* jack_test Universal */ = {
@@ -5291,7 +5470,7 @@
 			name = "testMutex Universal";
 			productInstallPath = /usr/local/bin;
 			productName = testSem;
-			productReference = 4BFA5E980DEC4D9C00FA4CDB /* testMutex */;
+			productReference = 4BFA5E980DEC4D9C00FA4CDB /* testSem */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BFA82820DF6A9E40087B4E1 /* jack_evmon 64 bits */ = {
@@ -5310,7 +5489,7 @@
 			name = "jack_evmon 64 bits";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4BFA828C0DF6A9E40087B4E1 /* jack_evmon */;
+			productReference = 4BFA828C0DF6A9E40087B4E1 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BFA82950DF6A9E40087B4E1 /* jack_bufsize 64 bits */ = {
@@ -5329,7 +5508,7 @@
 			name = "jack_bufsize 64 bits";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4BFA829F0DF6A9E40087B4E1 /* jack_bufsize */;
+			productReference = 4BFA829F0DF6A9E40087B4E1 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BFA82A10DF6A9E40087B4E1 /* jack_rec 64 bits */ = {
@@ -5348,7 +5527,7 @@
 			name = "jack_rec 64 bits";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4BFA82AB0DF6A9E40087B4E1 /* jack_rec */;
+			productReference = 4BFA82AB0DF6A9E40087B4E1 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BFA82AD0DF6A9E40087B4E1 /* jack_monitor_client 64 bits */ = {
@@ -5367,7 +5546,7 @@
 			name = "jack_monitor_client 64 bits";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4BFA82B70DF6A9E40087B4E1 /* jack_monitor_client */;
+			productReference = 4BFA82B70DF6A9E40087B4E1 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BFA82B90DF6A9E40087B4E1 /* jack_showtime 64 bits */ = {
@@ -5405,7 +5584,7 @@
 			name = "jack_impulse_grabber 64 bits";
 			productInstallPath = /usr/local/bin;
 			productName = jack_metro;
-			productReference = 4BFA82CF0DF6A9E40087B4E1 /* jack_impulse_grabber */;
+			productReference = 4BFA82CF0DF6A9E40087B4E1 /* jack_midiseq */;
 			productType = "com.apple.product-type.tool";
 		};
 		4BFA99980AAAF3B0009E916C /* jdelay Universal */ = {
@@ -5522,6 +5701,7 @@
 				4B5E08BF0E5B66EE00BEE4E0 /* netadapter Universal */,
 				4B35C41B0D4731D1000DE7AE /* jackdmp framework 64bits */,
 				4B35C4270D4731D1000DE7AE /* Jackmp.framework 64 bits */,
+				4B47AC8010B5890100469C67 /* Jackmp.framework 64 bits debugging */,
 				4B35C4850D4731D1000DE7AE /* Jackservermp.framework 64 bits */,
 				4BA3393310B2E36800190E3B /* Jackservermp.framework 64 bits profiling */,
 				4B35C50A0D4731D1000DE7AE /* jack_midiseq 64 bits */,
@@ -5581,6 +5761,13 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		4B47ACAC10B5890100469C67 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		4B699C23097D421600A18468 /* Resources */ = {
 			isa = PBXResourcesBuildPhase;
 			buildActionMask = 2147483647;
@@ -5836,6 +6023,13 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		4B47ACD010B5890100469C67 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		4B5A1BB60CD1CB9E0005BF74 /* Rez */ = {
 			isa = PBXRezBuildPhase;
 			buildActionMask = 2147483647;
@@ -6229,6 +6423,8 @@
 				4BF339210F8B873E0080FB5B /* JackMidiDriver.cpp in Sources */,
 				4BDCDBD11001FD0100B15929 /* JackWaitThreadedDriver.cpp in Sources */,
 				4BDCDC091001FDA800B15929 /* JackArgParser.cpp in Sources */,
+				4BCBCE6110C4FE3F00450FFE /* JackPhysicalMidiInput.cpp in Sources */,
+				4BCBCE6310C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -6490,6 +6686,47 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		4B47ACAD10B5890100469C67 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B47ACAE10B5890100469C67 /* JackMacLibClientRPC.cpp in Sources */,
+				4B47ACAF10B5890100469C67 /* JackRPCEngineUser.c in Sources */,
+				4B47ACB010B5890100469C67 /* JackMachPort.cpp in Sources */,
+				4B47ACB110B5890100469C67 /* JackShmMem.cpp in Sources */,
+				4B47ACB210B5890100469C67 /* shm.c in Sources */,
+				4B47ACB310B5890100469C67 /* JackActivationCount.cpp in Sources */,
+				4B47ACB410B5890100469C67 /* JackGraphManager.cpp in Sources */,
+				4B47ACB510B5890100469C67 /* JackPort.cpp in Sources */,
+				4B47ACB610B5890100469C67 /* JackClient.cpp in Sources */,
+				4B47ACB710B5890100469C67 /* JackAPI.cpp in Sources */,
+				4B47ACB810B5890100469C67 /* JackLibClient.cpp in Sources */,
+				4B47ACB910B5890100469C67 /* JackLibAPI.cpp in Sources */,
+				4B47ACBA10B5890100469C67 /* JackConnectionManager.cpp in Sources */,
+				4B47ACBB10B5890100469C67 /* JackFrameTimer.cpp in Sources */,
+				4B47ACBC10B5890100469C67 /* JackMachSemaphore.cpp in Sources */,
+				4B47ACBD10B5890100469C67 /* JackMachThread.cpp in Sources */,
+				4B47ACBE10B5890100469C67 /* JackMachClientChannel.cpp in Sources */,
+				4B47ACBF10B5890100469C67 /* JackGlobals.cpp in Sources */,
+				4B47ACC010B5890100469C67 /* ringbuffer.c in Sources */,
+				4B47ACC110B5890100469C67 /* JackDebugClient.cpp in Sources */,
+				4B47ACC210B5890100469C67 /* JackTransportEngine.cpp in Sources */,
+				4B47ACC310B5890100469C67 /* timestamps.c in Sources */,
+				4B47ACC410B5890100469C67 /* JackPortType.cpp in Sources */,
+				4B47ACC510B5890100469C67 /* JackAudioPort.cpp in Sources */,
+				4B47ACC610B5890100469C67 /* JackMidiPort.cpp in Sources */,
+				4B47ACC710B5890100469C67 /* JackMidiAPI.cpp in Sources */,
+				4B47ACC810B5890100469C67 /* JackEngineControl.cpp in Sources */,
+				4B47ACC910B5890100469C67 /* JackTools.cpp in Sources */,
+				4B47ACCA10B5890100469C67 /* JackError.cpp in Sources */,
+				4B47ACCB10B5890100469C67 /* JackMessageBuffer.cpp in Sources */,
+				4B47ACCC10B5890100469C67 /* JackPosixServerLaunch.cpp in Sources */,
+				4B47ACCD10B5890100469C67 /* JackPosixThread.cpp in Sources */,
+				4B47ACCE10B5890100469C67 /* JackMachTime.c in Sources */,
+				4B47ACCF10B5890100469C67 /* JackProcessSync.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		4B5A1BB30CD1CB9E0005BF74 /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
@@ -6624,6 +6861,8 @@
 				4BBAE4110F42FA6100B8BD3F /* JackEngineProfiling.cpp in Sources */,
 				4BECB2F50F4451C10091B70A /* JackProcessSync.cpp in Sources */,
 				4BF339230F8B873E0080FB5B /* JackMidiDriver.cpp in Sources */,
+				4BCBCE5D10C4FE3F00450FFE /* JackPhysicalMidiInput.cpp in Sources */,
+				4BCBCE5F10C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -6802,6 +7041,8 @@
 				4BA339A210B2E36800190E3B /* JackMidiDriver.cpp in Sources */,
 				4BA339A310B2E36800190E3B /* JackWaitThreadedDriver.cpp in Sources */,
 				4BA339A410B2E36800190E3B /* JackArgParser.cpp in Sources */,
+				4BCBCE6510C4FE3F00450FFE /* JackPhysicalMidiInput.cpp in Sources */,
+				4BCBCE6710C4FE3F00450FFE /* JackPhysicalMidiOutput.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -12152,6 +12393,199 @@
 			};
 			name = Default;
 		};
+		4B47ACD410B5890100469C67 /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_64_BIT_PRE_XCODE_3_1)";
+				ARCHS_STANDARD_32_64_BIT_PRE_XCODE_3_1 = "x86_64 i386 ppc";
+				COPY_PHASE_STRIP = NO;
+				DEBUGGING_SYMBOLS = YES;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SRCROOT)/build/Development\"";
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_WARN_FOUR_CHARACTER_CONSTANTS = NO;
+				GCC_WARN_UNKNOWN_PRAGMAS = NO;
+				GENERATE_PKGINFO_FILE = NO;
+				HEADER_SEARCH_PATHS = (
+					../common,
+					../posix,
+					RPC,
+					../common/jack,
+				);
+				INFOPLIST_FILE = "Jack-Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LIBRARY_SEARCH_PATHS = /usr/lib/gcc/darwin/3.3;
+				OTHER_CFLAGS = (
+					"-DUSE_POSIX_SHM",
+					"-DJACK_32_64",
+					"-D__SMP__",
+				);
+				OTHER_CPLUSPLUSFLAGS = (
+					"-D__CLIENTDEBUG__",
+					"-DMACH_RPC_MACH_SEMA",
+					"-D__SMP__",
+					"-DJACK_32_64",
+					"$(OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_1)",
+					"$(OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_2)",
+				);
+				OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_1 = "-DJACK_LOCATION=\\\"/usr/local/bin\\\"";
+				OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_2 = "-DADDON_DIR=\\\"/usr/local/lib/jackmp\\\"";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = Jackmp;
+				REZ_EXECUTABLE = NO;
+				SDKROOT = "";
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = "-Wmost";
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B47ACD510B5890100469C67 /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_64_BIT_PRE_XCODE_3_1)";
+				ARCHS_STANDARD_32_64_BIT_PRE_XCODE_3_1 = "x86_64 i386 ppc";
+				COPY_PHASE_STRIP = YES;
+				DEAD_CODE_STRIPPING = YES;
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SRCROOT)/build/Development\"";
+				FRAMEWORK_VERSION = A;
+				GCC_AUTO_VECTORIZATION = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_ENABLE_SSE3_EXTENSIONS = YES;
+				GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS = YES;
+				GCC_OPTIMIZATION_LEVEL = 3;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_WARN_FOUR_CHARACTER_CONSTANTS = NO;
+				GCC_WARN_UNKNOWN_PRAGMAS = NO;
+				GENERATE_PKGINFO_FILE = NO;
+				HEADER_SEARCH_PATHS = (
+					../common,
+					../posix,
+					RPC,
+					../common/jack,
+				);
+				INFOPLIST_FILE = "Jack-Info.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LIBRARY_SEARCH_PATHS = /usr/lib/gcc/darwin/3.3;
+				MACOSX_DEPLOYMENT_TARGET = 10.4;
+				OTHER_CFLAGS = (
+					"-DUSE_POSIX_SHM",
+					"-DJACK_32_64",
+					"-D__SMP__",
+				);
+				OTHER_CPLUSPLUSFLAGS = (
+					"-D__CLIENTDEBUG__",
+					"-DMACH_RPC_MACH_SEMA",
+					"-DJACK_32_64",
+					"-D__SMP__",
+					"$(OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_1)",
+					"$(OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_2)",
+				);
+				OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_1 = "-DADDON_DIR=\\\"/usr/local/lib/jackmp\\\"";
+				OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_2 = "-DJACK_LOCATION=\\\"/usr/local/bin\\\"";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = Jackmp;
+				REZ_EXECUTABLE = NO;
+				SDKROOT = "";
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = "-Wmost";
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B47ACD610B5890100469C67 /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					ppc64,
+					ppc,
+					i386,
+					x86_64,
+				);
+				DEBUG_INFORMATION_FORMAT = dwarf;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = (
+					"$(inherited)",
+					"$(FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1)",
+				);
+				FRAMEWORK_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = "\"$(SRCROOT)/build/Development\"";
+				FRAMEWORK_VERSION = A;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				GCC_WARN_FOUR_CHARACTER_CONSTANTS = NO;
+				GCC_WARN_UNKNOWN_PRAGMAS = NO;
+				GENERATE_PKGINFO_FILE = NO;
+				HEADER_SEARCH_PATHS = (
+					RPC,
+					../common/jack,
+				);
+				INFOPLIST_FILE = "Jack-Info copy 2.plist";
+				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+				LIBRARY_SEARCH_PATHS = /usr/lib/gcc/darwin/3.3;
+				OTHER_CFLAGS = (
+					"-DUSE_POSIX_SHM",
+					"-DJACK_32_64",
+					"-D__SMP__",
+				);
+				OTHER_CPLUSPLUSFLAGS = (
+					"-DMACH_RPC_MACH_SEMA",
+					"-DJACK_32_64",
+					"-D__SMP__",
+					"$(OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_1)",
+					"$(OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_2)",
+				);
+				OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_1 = "-DJACK_LOCATION=\\\"/usr/local/bin\\\"";
+				OTHER_CPLUSPLUSFLAGS_QUOTED_FOR_TARGET_2 = "-DADDON_DIR=\\\"/usr/local/lib/jackmp\\\"";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Carbon,
+					"-framework",
+					AudioToolBox,
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = Jackmp;
+				REZ_EXECUTABLE = NO;
+				SDKROOT = "";
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = "-Wmost";
+			};
+			name = Default;
+		};
 		4B5A1BB80CD1CB9E0005BF74 /* Development */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
@@ -17952,6 +18386,16 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Default;
 		};
+		4B47ACD310B5890100469C67 /* Build configuration list for PBXNativeTarget "Jackmp.framework 64 bits debugging" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B47ACD410B5890100469C67 /* Development */,
+				4B47ACD510B5890100469C67 /* Deployment */,
+				4B47ACD610B5890100469C67 /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
 		4B5A1BB70CD1CB9E0005BF74 /* Build configuration list for PBXNativeTarget "jack_midiseq Universal" */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
diff --git a/macosx/coreaudio/JackCoreAudioDriver.cpp b/macosx/coreaudio/JackCoreAudioDriver.cpp
index e540a16..361008e 100644
--- a/macosx/coreaudio/JackCoreAudioDriver.cpp
+++ b/macosx/coreaudio/JackCoreAudioDriver.cpp
@@ -250,10 +250,10 @@ OSStatus JackCoreAudioDriver::MeasureCallback(AudioDeviceID inDevice,
 }
 
 OSStatus JackCoreAudioDriver::SRNotificationCallback(AudioDeviceID inDevice,
-        UInt32 inChannel,
-        Boolean	isInput,
-        AudioDevicePropertyID inPropertyID,
-        void* inClientData)
+                                                    UInt32 inChannel,
+                                                    Boolean	isInput,
+                                                    AudioDevicePropertyID inPropertyID,
+                                                    void* inClientData)
 {
     JackCoreAudioDriver* driver = (JackCoreAudioDriver*)inClientData;
 
@@ -262,6 +262,16 @@ OSStatus JackCoreAudioDriver::SRNotificationCallback(AudioDeviceID inDevice,
         case kAudioDevicePropertyNominalSampleRate: {
             jack_log("JackCoreAudioDriver::SRNotificationCallback kAudioDevicePropertyNominalSampleRate");
             driver->fState = true;
+            // Check new sample rate
+            Float64 sampleRate;
+            UInt32 outSize =  sizeof(Float64);
+            OSStatus err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outSize, &sampleRate);
+            if (err != noErr) {
+                jack_error("Cannot get current sample rate");
+                printError(err);
+            } else {
+                jack_log("SRNotificationCallback : checked sample rate = %f", sampleRate);
+            }
             break;
         }
     }
@@ -271,14 +281,23 @@ OSStatus JackCoreAudioDriver::SRNotificationCallback(AudioDeviceID inDevice,
 
 // A better implementation would possibly try to recover in case of hardware device change (see HALLAB HLFilePlayerWindowControllerAudioDevicePropertyListenerProc code)
 OSStatus JackCoreAudioDriver::DeviceNotificationCallback(AudioDeviceID inDevice,
-        UInt32 inChannel,
-        Boolean	isInput,
-        AudioDevicePropertyID inPropertyID,
-        void* inClientData)
+                                                        UInt32 inChannel,
+                                                        Boolean	isInput,
+                                                        AudioDevicePropertyID inPropertyID,
+                                                        void* inClientData)
 {
     JackCoreAudioDriver* driver = (JackCoreAudioDriver*)inClientData;
          
     switch (inPropertyID) {
+            
+        case kAudioDevicePropertyDeviceIsRunning: {
+            UInt32 isrunning = 0;
+            UInt32 outsize = sizeof(UInt32);
+            if (AudioDeviceGetProperty(driver->fDeviceID, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyDeviceIsRunning, &outsize, &isrunning) == noErr) {
+                jack_log("JackCoreAudioDriver::DeviceNotificationCallback kAudioDevicePropertyDeviceIsRunning = %d", isrunning);
+            }
+            break;
+        }
         
         case kAudioDeviceProcessorOverload: {
             jack_error("JackCoreAudioDriver::DeviceNotificationCallback kAudioDeviceProcessorOverload");
@@ -296,12 +315,52 @@ OSStatus JackCoreAudioDriver::DeviceNotificationCallback(AudioDeviceID inDevice,
         }
         
         case kAudioDevicePropertyNominalSampleRate: {
-            jack_error("Cannot handle kAudioDevicePropertyNominalSampleRate : server will quit...");
-            driver->NotifyFailure(JackBackendError, "Another application has changed the sample rate.");    // Message length limited to JACK_MESSAGE_SIZE
-            driver->CloseAUHAL();
-            kill(JackTools::GetPID(), SIGINT);
-            return kAudioHardwareUnsupportedOperationError;
-		}
+            Float64 sampleRate = 0;
+            UInt32 outsize = sizeof(Float64);
+            OSStatus err = AudioDeviceGetProperty(driver->fDeviceID, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outsize, &sampleRate);
+            if (err != noErr)
+                return kAudioHardwareUnsupportedOperationError;
+            
+            char device_name[256];
+            const char* digidesign_name = "Digidesign";
+            driver->GetDeviceNameFromID(driver->fDeviceID, device_name);
+        
+            if (sampleRate != driver->fEngineControl->fSampleRate) {
+               
+               // Digidesign hardware, so "special" code : change the SR again here
+               if (strncmp(device_name, digidesign_name, sizeof(digidesign_name)) == 0) {
+                   
+                    jack_log("Digidesign HW = %s", device_name);
+                
+                    // Set sample rate again...
+                    sampleRate = driver->fEngineControl->fSampleRate;
+                    err = AudioDeviceSetProperty(driver->fDeviceID, NULL, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, outsize, &sampleRate);
+                    if (err != noErr) {
+                        jack_error("Cannot set sample rate = %f", sampleRate);
+                        printError(err);
+                    } else {
+                        jack_log("Set sample rate = %f", sampleRate);
+                    }
+                    
+                    // Check new sample rate again...
+                    outsize = sizeof(Float64);
+                    err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outsize, &sampleRate);
+                    if (err != noErr) {
+                        jack_error("Cannot get current sample rate");
+                        printError(err);
+                    } else {
+                        jack_log("Checked sample rate = %f", sampleRate);
+                    }
+                    return noErr;
+                    
+                } else {
+                    driver->NotifyFailure(JackBackendError, "Another application has changed the sample rate.");    // Message length limited to JACK_MESSAGE_SIZE
+                    driver->CloseAUHAL();
+                    kill(JackTools::GetPID(), SIGINT);
+                    return kAudioHardwareUnsupportedOperationError;
+                }
+            }
+        }
             
     }
     return noErr;
@@ -926,8 +985,6 @@ int JackCoreAudioDriver::SetupDevices(const char* capture_driver_uid,
     if (fHogged) {
         if (TakeHog()) {
             jack_info("Device = %ld has been hogged", fDeviceID);
-        } else {
-            jack_error("Cannot hog device = %ld", fDeviceID);
         }
     }
 
@@ -1020,6 +1077,8 @@ int JackCoreAudioDriver::SetupSampleRateAux(AudioDeviceID inDevice, jack_nframes
         jack_error("Cannot get current sample rate");
         printError(err);
         return -1;
+    } else {
+        jack_log("Current sample rate = %f", sampleRate);
     }
 
     // If needed, set new sample rate
@@ -1046,6 +1105,16 @@ int JackCoreAudioDriver::SetupSampleRateAux(AudioDeviceID inDevice, jack_nframes
             usleep(100000);
             jack_log("Wait count = %d", count);
         }
+        
+        // Check new sample rate
+        outSize =  sizeof(Float64);
+        err = AudioDeviceGetProperty(inDevice, 0, kAudioDeviceSectionGlobal, kAudioDevicePropertyNominalSampleRate, &outSize, &sampleRate);
+        if (err != noErr) {
+            jack_error("Cannot get current sample rate");
+            printError(err);
+        } else {
+            jack_log("Checked sample rate = %f", sampleRate);
+        }
 
         // Remove SR change notification
         AudioDeviceRemovePropertyListener(inDevice, 0, true, kAudioDevicePropertyNominalSampleRate, SRNotificationCallback);
@@ -1493,8 +1562,7 @@ int JackCoreAudioDriver::Attach()
     char channel_name[64];
     char name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
     char alias[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
-    unsigned long port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
-
+ 
     jack_log("JackCoreAudioDriver::Attach fBufferSize %ld fSampleRate %ld", fEngineControl->fBufferSize, fEngineControl->fSampleRate);
 
     for (int i = 0; i < fCaptureChannels; i++) {
@@ -1513,7 +1581,7 @@ int JackCoreAudioDriver::Attach()
 
         snprintf(name, sizeof(name) - 1, "%s:capture_%d", fClientControl.fName, i + 1);
 
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, CaptureDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("Cannot register port for %s", name);
             return -1;
         }
@@ -1534,8 +1602,6 @@ int JackCoreAudioDriver::Attach()
         fCapturePortList[i] = port_index;
     }
 
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     for (int i = 0; i < fPlaybackChannels; i++) {
 
         err = AudioDeviceGetPropertyInfo(fDeviceID, i + 1, false, kAudioDevicePropertyChannelName, &size, &isWritable);
@@ -1552,7 +1618,7 @@ int JackCoreAudioDriver::Attach()
 
         snprintf(name, sizeof(name) - 1, "%s:playback_%d", fClientControl.fName, i + 1);
 
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, PlaybackDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("Cannot register port for %s", name);
             return -1;
         }
@@ -1577,7 +1643,7 @@ int JackCoreAudioDriver::Attach()
         if (fWithMonitorPorts) {
             jack_log("Create monitor port ");
             snprintf(name, sizeof(name) - 1, "%s:monitor_%u", fClientControl.fName, i + 1);
-            if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, fEngineControl->fBufferSize)) == NO_PORT) {
+            if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_AUDIO_TYPE, MonitorDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
                 jack_error("Cannot register monitor port for %s", name);
                 return -1;
             } else {
@@ -1623,7 +1689,7 @@ int JackCoreAudioDriver::Start()
         return -1;
     }
     
-    // Waiting for Measure callback to be called ( = driver has started)
+    // Waiting for Measure callback to be called (= driver has started)
     fState = false;
     int count = 0;
     while (!fState && count++ < WAIT_COUNTER) {
@@ -1695,7 +1761,7 @@ bool JackCoreAudioDriver::TakeHogAux(AudioDeviceID deviceID, bool isInput)
         hog_pid = getpid();
         err = AudioDeviceSetProperty(deviceID, 0, 0, isInput, kAudioDevicePropertyHogMode, propSize, &hog_pid);
         if (err != noErr) {
-            jack_error("Can't hog device = %d because it's being hogged by another program", deviceID);
+            jack_error("Can't hog device = %d because it's being hogged by another program or cannot be hogged", deviceID);
             return false;
         }
     }
diff --git a/macosx/coremidi/JackCoreMidiDriver.cpp b/macosx/coremidi/JackCoreMidiDriver.cpp
index 891af94..0f52e90 100644
--- a/macosx/coremidi/JackCoreMidiDriver.cpp
+++ b/macosx/coremidi/JackCoreMidiDriver.cpp
@@ -52,19 +52,17 @@ void JackCoreMidiDriver::ReadProcAux(const MIDIPacketList *pktlist, jack_ringbuf
         
         // TODO : use timestamp
         
+        // Check available size first..
+        size = jack_ringbuffer_write_space(ringbuffer);
+        if (size < (sizeof(UInt16) + packet->length)) {
+           jack_error("ReadProc : ring buffer is full, skip events...");
+           return;
+        }
         // Write length of each packet first
-        size = jack_ringbuffer_write(ringbuffer, (char*)&packet->length, sizeof(UInt16));
-        if (size != sizeof(UInt16)) {
-            jack_error("ReadProc : ring buffer is full, skip events...");
-            return;
-        }  
+        jack_ringbuffer_write(ringbuffer, (char*)&packet->length, sizeof(UInt16));
         // Write event actual data
-        size = jack_ringbuffer_write(ringbuffer, (char*)packet->data, packet->length);
-        if (size != packet->length) {
-            jack_error("ReadProc : ring buffer is full, skip events...");
-            return;
-        }  
-        
+        jack_ringbuffer_write(ringbuffer, (char*)packet->data, packet->length);
+            
         packet = MIDIPacketNext(packet);
     }
 }
@@ -224,7 +222,6 @@ int JackCoreMidiDriver::Attach()
     char name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
     char endpoint_name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
     char alias[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
-    unsigned long port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
     int i;
 
     jack_log("JackCoreMidiDriver::Attach fBufferSize = %ld fSampleRate = %ld", fEngineControl->fBufferSize, fEngineControl->fSampleRate);
@@ -241,7 +238,7 @@ int JackCoreMidiDriver::Attach()
         }
         
         snprintf(name, sizeof(name) - 1, "%s:capture_%d", fClientControl.fName, i + 1);
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, CaptureDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
@@ -251,8 +248,6 @@ int JackCoreMidiDriver::Attach()
         jack_log("JackCoreMidiDriver::Attach fCapturePortList[i] port_index = %ld", port_index);
     }
 
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     for (i = 0; i < fPlaybackChannels; i++) {
         
         err = MIDIObjectGetStringProperty(fMidiSource[i], kMIDIPropertyName, &pname);
@@ -265,7 +260,7 @@ int JackCoreMidiDriver::Attach()
         }
         
         snprintf(name, sizeof(name) - 1, "%s:playback_%d", fClientControl.fName, i + 1);
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, PlaybackDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
diff --git a/posix/JackPosixMutex.h b/posix/JackPosixMutex.h
index 91d2113..ddf8955 100644
--- a/posix/JackPosixMutex.h
+++ b/posix/JackPosixMutex.h
@@ -103,11 +103,12 @@ class JackPosixMutex
             pthread_mutex_destroy(&fMutex);
         }
 
-        void Lock()
+        bool Lock()
         {
             int res = pthread_mutex_lock(&fMutex);
             if (res != 0)
                 jack_error("JackPosixMutex::Lock res = %d", res);
+            return (res == 0);
         }
 
         bool Trylock()
@@ -115,11 +116,12 @@ class JackPosixMutex
             return (pthread_mutex_trylock(&fMutex) == 0);
         }
 
-        void Unlock()
+        bool Unlock()
         {
             int res = pthread_mutex_unlock(&fMutex);
             if (res != 0)
                 jack_error("JackPosixMutex::Unlock res = %d", res);
+            return (res == 0);
         }
 
 };
diff --git a/posix/JackSocketServerChannel.cpp b/posix/JackSocketServerChannel.cpp
index a562521..d2a59b3 100644
--- a/posix/JackSocketServerChannel.cpp
+++ b/posix/JackSocketServerChannel.cpp
@@ -26,6 +26,8 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "JackClient.h"
 #include "JackTools.h"
 #include "JackNotification.h"
+#include "JackException.h"
+
 #include <assert.h>
 #include <signal.h>
 
@@ -64,7 +66,7 @@ int JackSocketServerChannel::Open(const char* server_name, JackServer* server)
 
 void JackSocketServerChannel::Close()
 {
-    fThread.Kill();
+    fThread.Stop();
     fRequestListenSocket.Close();
 
     // Close remaining client sockets
@@ -387,8 +389,14 @@ bool JackSocketServerChannel::HandleRequest(int fd)
         case JackRequest::kNotification: {
             jack_log("JackRequest::Notification");
             JackClientNotificationRequest req;
-            if (req.Read(socket) == 0)
-                fServer->Notify(req.fRefNum, req.fNotify, req.fValue);
+            if (req.Read(socket) == 0) {
+                if (req.fNotify == kQUIT) {
+                    jack_log("JackRequest::Notification kQUIT");
+                    throw JackQuitException();
+                } else {
+                    fServer->Notify(req.fRefNum, req.fNotify, req.fValue);
+                }
+            }
             break;
         }
 
@@ -436,35 +444,42 @@ bool JackSocketServerChannel::Init()
 
 bool JackSocketServerChannel::Execute()
 {
-    // Global poll
-    if ((poll(fPollTable, fSocketTable.size() + 1, 10000) < 0) && (errno != EINTR)) {
-        jack_error("Engine poll failed err = %s request thread quits...", strerror(errno));
-        return false;
-    } else {
-
-        // Poll all clients
-        for (unsigned int i = 1; i < fSocketTable.size() + 1; i++) {
-            int fd = fPollTable[i].fd;
-            jack_log("fPollTable i = %ld fd = %ld", i, fd);
-            if (fPollTable[i].revents & ~POLLIN) {
-                jack_log("Poll client error err = %s", strerror(errno));
-                ClientKill(fd);
-            } else if (fPollTable[i].revents & POLLIN) {
-                if (!HandleRequest(fd)) 
-                    jack_log("Could not handle external client request");
+    try {
+    
+        // Global poll
+        if ((poll(fPollTable, fSocketTable.size() + 1, 10000) < 0) && (errno != EINTR)) {
+            jack_error("Engine poll failed err = %s request thread quits...", strerror(errno));
+            return false;
+        } else {
+
+            // Poll all clients
+            for (unsigned int i = 1; i < fSocketTable.size() + 1; i++) {
+                int fd = fPollTable[i].fd;
+                jack_log("fPollTable i = %ld fd = %ld", i, fd);
+                if (fPollTable[i].revents & ~POLLIN) {
+                    jack_log("Poll client error err = %s", strerror(errno));
+                    ClientKill(fd);
+                } else if (fPollTable[i].revents & POLLIN) {
+                    if (!HandleRequest(fd)) 
+                        jack_log("Could not handle external client request");
+                }
             }
+
+            // Check the server request socket */
+            if (fPollTable[0].revents & POLLERR) 
+                jack_error("Error on server request socket err = %s", strerror(errno));
+       
+            if (fPollTable[0].revents & POLLIN) 
+                ClientCreate();
         }
 
-        // Check the server request socket */
-        if (fPollTable[0].revents & POLLERR) 
-            jack_error("Error on server request socket err = %s", strerror(errno));
-   
-        if (fPollTable[0].revents & POLLIN) 
-            ClientCreate();
+        BuildPoolTable();
+        return true;
+        
+    } catch (JackQuitException& e) {
+        jack_log("JackMachServerChannel::Execute JackQuitException");
+        return false;
     }
-
-    BuildPoolTable();
-    return true;
 }
 
 } // end of namespace
diff --git a/posix/JackSocketServerNotifyChannel.cpp b/posix/JackSocketServerNotifyChannel.cpp
index c4e4888..df7381f 100644
--- a/posix/JackSocketServerNotifyChannel.cpp
+++ b/posix/JackSocketServerNotifyChannel.cpp
@@ -21,6 +21,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "JackError.h"
 #include "JackRequest.h"
 #include "JackConstants.h"
+#include "JackNotification.h"
 
 namespace Jack
 {
@@ -55,6 +56,15 @@ void JackSocketServerNotifyChannel::Notify(int refnum, int notify, int value)
     }
 }
 
+void JackSocketServerNotifyChannel::NotifyQuit()
+{
+    JackClientNotificationRequest req(-1, kQUIT, 0);
+    if (req.Write(&fRequestSocket) < 0) {
+        jack_error("Could not write request ref = %d notify = %d", -1, kQUIT);
+    }
+}
+    
+
 } // end of namespace
 
 
diff --git a/posix/JackSocketServerNotifyChannel.h b/posix/JackSocketServerNotifyChannel.h
index d8687df..261ddbd 100644
--- a/posix/JackSocketServerNotifyChannel.h
+++ b/posix/JackSocketServerNotifyChannel.h
@@ -44,6 +44,7 @@ class JackSocketServerNotifyChannel
         void Close();
 
         void Notify(int refnum, int notify, int value);
+        void NotifyQuit();
 };
 
 } // end of namespace
diff --git a/tests/test.cpp b/tests/test.cpp
index e77edf4..b5d2467 100644
--- a/tests/test.cpp
+++ b/tests/test.cpp
@@ -85,6 +85,7 @@ int reorder = 0;	// graph reorder callback
 int RT = 0;			// is real time or not...
 int FW = 0;			// freewheel mode
 int init_clbk = 0;	// init callback
+int port_rename_clbk = 0;	// portrename callback
 int i, j, k = 0;
 int port_callback_reg = 0;
 jack_nframes_t cur_buffer_size, old_buffer_size, cur_pos;
@@ -180,6 +181,13 @@ void Jack_Client_Registration_Callback(const char* name, int val, void *arg)
 		client_register--;
 }
 
+int Jack_Port_Rename_Callback(jack_port_id_t port, const char* old_name, const char* new_name, void *arg)
+{
+     Log("Rename callback has been successfully called with old_name '%s' and new_name '%s'. (msg from callback)\n");
+     port_rename_clbk = 1;
+     return 0;
+}
+
 int Jack_Update_Buffer_Size(jack_nframes_t nframes, void *arg)
 {
     cur_buffer_size = jack_get_buffer_size(client1);
@@ -679,6 +687,7 @@ int main (int argc, char *argv[])
         printf("!!! ERROR !!! while calling jack_set_thread_init_callback()...\n");
     if (jack_set_freewheel_callback(client1, Jack_Freewheel_Callback, 0) != 0 )
         printf("\n!!! ERROR !!! while calling jack_set_freewheel_callback()...\n");
+  
 
     if (jack_set_process_callback(client1, process1, 0) != 0) {
         printf("Error when calling jack_set_process_callback() !\n");
@@ -694,6 +703,9 @@ int main (int argc, char *argv[])
     if (jack_set_graph_order_callback(client1, Jack_Graph_Order_Callback, 0) != 0) {
         printf("Error when calling Jack_Graph_Order_Callback() !\n");
     }
+    
+    if (jack_set_port_rename_callback(client1, Jack_Port_Rename_Callback, 0) != 0 )
+        printf("\n!!! ERROR !!! while calling jack_set_rename_callback()...\n");
 
     if (jack_set_xrun_callback(client1, Jack_XRun_Callback, 0 ) != 0) {
         printf("Error when calling jack_set_xrun_callback() !\n");
@@ -810,6 +822,8 @@ int main (int argc, char *argv[])
         printf("error : port_set_name function can't be tested...\n");
     }
 
+    port_callback_reg = 0;	// number of port registration received by the callback
+    
     /**
      * Activate the client
      *
@@ -818,13 +832,37 @@ int main (int argc, char *argv[])
         printf ("Fatal error : cannot activate client1\n");
         exit(1);
     }
+    
+    /**
+     * Test if portrename callback have been called.
+     *
+     */
+    jack_port_set_name (output_port1, "renamed-port#");
+    jack_sleep(1 * 1000); 
+
+    if (port_rename_clbk == 0)
+        printf("!!! ERROR !!! Jack_Port_Rename_Callback was not called !!.\n");
+        
+        
+    /**
+     * Test if portregistration callback have been called.
+     *
+     */
+     
+    jack_sleep(1 * 1000); 
 
+    if (1 == port_callback_reg) {
+        Log("%i ports have been successfully created, and %i callback reg ports have been received... ok\n", 1, port_callback_reg);
+    } else {
+        printf("!!! ERROR !!! %i ports have been created, and %i callback reg ports have been received !\n", 1, port_callback_reg);
+    }
+ 
     /**
      * Test if init callback initThread have been called.
      *
      */
     if (init_clbk == 0)
-        printf("!!! ERROR !!! JackThreadInitCallback was not called !!.\n");
+        printf("!!! ERROR !!! Jack_Thread_Init_Callback was not called !!.\n");
 
     jack_sleep(10 * 1000); // test see the clock in the graph at the begining...
 
@@ -1073,11 +1111,14 @@ int main (int argc, char *argv[])
     }
 
     jack_sleep(1 * 1000); // To hope all port registration and reorder callback have been received...
+    
+    // Check port registration callback
     if (j == port_callback_reg) {
         Log("%i ports have been successfully created, and %i callback reg ports have been received... ok\n", j, port_callback_reg);
     } else {
-        printf("!!! ERROR !!! %i ports have been created, and %i callback reg ports have been received !\n", j, k);
+        printf("!!! ERROR !!! %i ports have been created, and %i callback reg ports have been received !\n", j, port_callback_reg);
     }
+    
     if (reorder == (2 * j)) {
         Log("%i graph reorder callback have been received... ok\n", reorder);
     } else {
@@ -1125,6 +1166,7 @@ int main (int argc, char *argv[])
      * Deregister all ports previously created.
      *
      */
+    port_callback_reg = 0; // to check registration callback
     Log("Deregistering all ports of the client...\n");
     inports = jack_get_ports(client1, NULL, NULL, 0);
     a = 0;
@@ -1138,6 +1180,13 @@ int main (int argc, char *argv[])
         }
         a++;
     }
+    
+    // Check port registration callback again
+    if (j == port_callback_reg) { 
+        Log("%i ports have been successfully created, and %i callback reg ports have been received... ok\n", j, port_callback_reg);
+    } else {
+        printf("!!! ERROR !!! %i ports have been created, and %i callback reg ports have been received !\n", j, port_callback_reg);
+    }
 
     free(inports); // free array of ports (as mentionned in the doc of jack_get_ports)
 
diff --git a/windows/JackRouter/JackRouter.cpp b/windows/JackRouter/JackRouter.cpp
new file mode 100644
index 0000000..47727af
--- /dev/null
+++ b/windows/JackRouter/JackRouter.cpp
@@ -0,0 +1,840 @@
+/*
+Copyright (C) 2006 Grame  
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifdef WIN32
+#pragma warning (disable : 4786)
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <process.h>
+#include "JackRouter.h"
+#include "profport.h"
+
+/*
+
+	08/07/2007 SL : USe jack_client_open instead of jack_client_new (automatic client renaming).
+	09/08/2007 SL : Add JackRouter.ini parameter file.
+	09/20/2007 SL : Better error report in DllRegisterServer (for Vista).
+	09/27/2007 SL : Add AUDO_CONNECT property in JackRouter.ini file.
+	10/10/2007 SL : Use ASIOSTInt32LSB instead of ASIOSTInt16LSB.
+
+ */
+
+//------------------------------------------------------------------------------------------
+// extern
+void getNanoSeconds(ASIOTimeStamp *time);
+
+// local
+double AsioSamples2double (ASIOSamples* samples);
+
+static const double twoRaisedTo32 = 4294967296.;
+static const double twoRaisedTo32Reciprocal = 1. / twoRaisedTo32;
+
+//------------------------------------------------------------------------------------------
+// on windows, we do the COM stuff.
+
+#if WINDOWS
+#include "windows.h"
+#include "mmsystem.h"
+#include "psapi.h"
+
+using namespace std;
+
+// class id. 
+// {838FE50A-C1AB-4b77-B9B6-0A40788B53F3}
+CLSID IID_ASIO_DRIVER = { 0x838fe50a, 0xc1ab, 0x4b77, { 0xb9, 0xb6, 0xa, 0x40, 0x78, 0x8b, 0x53, 0xf3 } };
+
+
+CFactoryTemplate g_Templates[1] = {
+    {L"ASIOJACK", &IID_ASIO_DRIVER, JackRouter::CreateInstance} 
+};
+int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
+
+CUnknown* JackRouter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
+{
+	return (CUnknown*)new JackRouter(pUnk,phr);
+};
+
+STDMETHODIMP JackRouter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
+{
+	if (riid == IID_ASIO_DRIVER) {
+		return GetInterface(this, ppv);
+	}
+	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
+}
+
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+//		Register ASIO Driver
+// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+extern LONG RegisterAsioDriver(CLSID,char *,char *,char *,char *);
+extern LONG UnregisterAsioDriver(CLSID,char *,char *);
+
+//
+// Server registration, called on REGSVR32.EXE "the dllname.dll"
+//
+HRESULT _stdcall DllRegisterServer()
+{
+	LONG	rc;
+	char	errstr[128];
+
+	rc = RegisterAsioDriver (IID_ASIO_DRIVER,"JackRouter.dll","JackRouter","JackRouter","Apartment");
+
+	if (rc) {
+		memset(errstr,0,128);
+		sprintf(errstr,"Register Server failed ! (%d)",rc);
+		MessageBox(0,(LPCTSTR)errstr,(LPCTSTR)"JackRouter",MB_OK);
+		return -1;
+	}
+
+	return S_OK;
+}
+
+//
+// Server unregistration
+//
+HRESULT _stdcall DllUnregisterServer()
+{
+	LONG	rc;
+	char	errstr[128];
+
+	rc = UnregisterAsioDriver (IID_ASIO_DRIVER,"JackRouter.dll","JackRouter");
+
+	if (rc) {
+		memset(errstr,0,128);
+		sprintf(errstr,"Unregister Server failed ! (%d)",rc);
+		MessageBox(0,(LPCTSTR)errstr,(LPCTSTR)"JackRouter",MB_OK);
+		return -1;
+	}
+
+	return S_OK;
+}
+
+// Globals
+
+list<pair<string, string> > JackRouter::fConnections;
+bool JackRouter::fFirstActivate = true;
+
+//------------------------------------------------------------------------------------------
+//------------------------------------------------------------------------------------------
+JackRouter::JackRouter (LPUNKNOWN pUnk, HRESULT *phr)
+	: CUnknown("ASIOJACK", pUnk, phr)
+
+//------------------------------------------------------------------------------------------
+
+#else
+
+// when not on windows, we derive from AsioDriver
+JackRouter::JackRouter() : AsioDriver()
+
+#endif
+{
+	long i;
+
+	fSamplePosition = 0;
+	fActive = false;
+	fStarted = false;
+	fTimeInfoMode = false;
+	fTcRead = false;
+	fClient = NULL;
+	fAutoConnectIn = true;
+	fAutoConnectOut = true;
+
+	for (i = 0; i < kNumInputs; i++) {
+		fInputBuffers[i] = 0;
+		fInputPorts[i] = 0;
+		fInMap[i] = 0;
+	}
+	for (i = 0; i < kNumOutputs; i++) {
+		fOutputBuffers[i] = 0;
+		fOutputPorts[i] = 0;
+		fOutMap[i] = 0;
+	}
+	fCallbacks = 0;
+	fActiveInputs = fActiveOutputs = 0;
+	fToggle = 0;
+	fBufferSize = 512;
+	fSampleRate = 44100;
+	printf("Constructor\n");
+
+	// Use "jackrouter.ini" parameters if available
+	HMODULE handle = LoadLibrary("JackRouter.dll");
+
+	if (handle) {
+
+		// Get JackRouter.dll path
+		char dllName[512];
+		string confPath;
+		DWORD res = GetModuleFileName(handle, dllName, 512);
+		
+		// Compute .ini file path
+		string fullPath = dllName;
+		int lastPos = fullPath.find_last_of(PATH_SEP);
+		string  dllFolder =  fullPath.substr(0, lastPos);
+		confPath = dllFolder + PATH_SEP + "JackRouter.ini";
+
+		// Get parameters
+		kNumInputs = get_private_profile_int("IO", "input", 2, confPath.c_str());
+		kNumOutputs = get_private_profile_int("IO", "output", 2, confPath.c_str());
+
+		fAutoConnectIn = get_private_profile_int("AUTO_CONNECT", "input", 1, confPath.c_str());
+		fAutoConnectOut = get_private_profile_int("AUTO_CONNECT", "output", 1, confPath.c_str());
+
+		FreeLibrary(handle);
+
+	} else {
+		printf("LoadLibrary error\n");
+	}
+}
+
+//------------------------------------------------------------------------------------------
+JackRouter::~JackRouter()
+{
+	stop ();
+	disposeBuffers ();
+	printf("Destructor\n");
+	jack_client_close(fClient);
+}
+
+//------------------------------------------------------------------------------------------
+#include <windows.h>
+#include <stdio.h>
+#include <tchar.h>
+#include "psapi.h"
+
+static bool GetEXEName(DWORD dwProcessID, char* name)
+{
+    DWORD aProcesses [1024], cbNeeded, cProcesses;
+    unsigned int i;
+        
+    // Enumerate all processes
+    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
+        return false;
+
+    // Calculate how many process identifiers were returned.
+    cProcesses = cbNeeded / sizeof(DWORD);
+
+    TCHAR szEXEName[MAX_PATH];
+    // Loop through all process to find the one that matches
+    // the one we are looking for
+
+    for (i = 0; i < cProcesses; i++) {
+        if (aProcesses [i] == dwProcessID) {
+            // Get a handle to the process
+            HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
+                              PROCESS_VM_READ, FALSE, dwProcessID);
+        
+            // Get the process name
+            if (NULL != hProcess) {
+                HMODULE hMod;
+                DWORD cbNeeded;
+            
+                if(EnumProcessModules(hProcess, &hMod, 
+                                      sizeof(hMod), &cbNeeded)) {
+                    //Get the name of the exe file
+                    GetModuleBaseName(hProcess, hMod, szEXEName, 
+                        sizeof(szEXEName)/sizeof(TCHAR));
+					int len = strlen((char*)szEXEName) - 4; // remove ".exe"
+					strncpy(name, (char*)szEXEName, len); 
+					name[len] = '\0';
+					return true;
+                 }
+            }
+        }    
+    }
+
+    return false;
+}
+
+ //------------------------------------------------------------------------------------------
+static inline float ClipFloat(float sample)
+{
+     return (sample < -1.0f) ? -1.0f : (sample > 1.0f) ? 1.0f : sample;
+}
+
+//------------------------------------------------------------------------------------------
+void JackRouter::shutdown(void* arg)
+{
+	JackRouter* driver = (JackRouter*)arg;
+	/*
+	//exit(1);
+	char errstr[128];
+
+	memset(errstr,0,128);
+	sprintf(errstr,"JACK server has quitted");
+	MessageBox(0,(LPCTSTR)errstr,(LPCTSTR)"JackRouter",MB_OK);
+	*/
+}
+
+//------------------------------------------------------------------------------------------
+int JackRouter::process(jack_nframes_t nframes, void* arg)
+{
+	JackRouter* driver = (JackRouter*)arg;
+	int i,j;
+	int pos = (driver->fToggle) ? 0 : driver->fBufferSize ;	
+	
+	for (i = 0; i < driver->fActiveInputs; i++) {	
+		
+#ifdef LONG_SAMPLE		
+		float* buffer = (float*)jack_port_get_buffer(driver->fInputPorts[i], nframes);
+		long* in = driver->fInputBuffers[i] + pos;
+		for (j = 0; j < nframes; j++) {
+			in[j] = buffer[j] * float(0x7fffffff);
+		}
+#else
+		memcpy(driver->fInputBuffers[i] + pos,
+				jack_port_get_buffer(driver->fInputPorts[i], nframes),
+				nframes * sizeof(float));
+#endif
+
+	}	
+
+	driver->bufferSwitch();
+
+	for (i = 0; i < driver->fActiveOutputs; i++) {
+
+#ifdef LONG_SAMPLE
+		float* buffer = (float*)jack_port_get_buffer(driver->fOutputPorts[i], nframes);
+		long* out = driver->fOutputBuffers[i] + pos;
+		float gain = 1.f/float(0x7fffffff);
+		for (j = 0; j < nframes; j++) {
+			buffer[j] = out[j] * gain;
+		}
+#else
+		memcpy(jack_port_get_buffer(driver->fOutputPorts[i], nframes),
+				driver->fOutputBuffers[i] + pos,
+				nframes * sizeof(float));
+#endif
+	}
+	
+	return 0;
+}
+
+//------------------------------------------------------------------------------------------
+void JackRouter::getDriverName(char *name)
+{
+	strcpy (name, "JackRouter");
+}
+
+//------------------------------------------------------------------------------------------
+long JackRouter::getDriverVersion()
+{
+	return 0x00000001L;
+}
+
+//------------------------------------------------------------------------------------------
+void JackRouter::getErrorMessage(char *string)
+{
+	strcpy (string, fErrorMessage);
+}
+
+//------------------------------------------------------------------------------------------
+ASIOBool JackRouter::init(void* sysRef)
+{
+	char name[MAX_PATH];
+	sysRef = sysRef;
+
+	if (fActive)
+		return true;
+
+	HANDLE win = (HANDLE)sysRef;
+	int	my_pid = _getpid();
+	
+	if (!GetEXEName(my_pid, name)) { // If getting the .exe name fails, takes a generic one.
+		_snprintf(name, sizeof(name) - 1, "JackRouter_%d", my_pid);
+	}
+
+	if (fClient) {
+		printf("Error: jack client still present...\n");
+		return true;
+	}
+		
+	fClient = jack_client_open(name, JackNullOption, NULL);
+	if (fClient == NULL) {
+		strcpy (fErrorMessage, "Open error: is jack server running?");
+		printf("Open error: is jack server running?\n");
+		return false;
+	}
+	
+	fBufferSize = jack_get_buffer_size(fClient);
+	fSampleRate = jack_get_sample_rate(fClient);
+	jack_set_process_callback(fClient, process, this);
+	jack_on_shutdown(fClient, shutdown, this);
+  	
+	fInputLatency = fBufferSize;		// typically
+	fOutputLatency = fBufferSize * 2;
+	fMilliSeconds = (long)((double)(fBufferSize * 1000) / fSampleRate);
+
+	// Typically fBufferSize * 2; try to get 1 by offering direct buffer
+	// access, and using asioPostOutput for lower latency
+
+	printf("Init ASIO Jack\n");
+	fActive = true;
+	return true;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::start()
+{
+	if (fCallbacks) {
+		fSamplePosition = 0;
+		fTheSystemTime.lo = fTheSystemTime.hi = 0;
+		fToggle = 0;
+		fStarted = true;
+		printf("Start ASIO Jack\n");
+	
+		if (jack_activate(fClient) == 0) {
+
+			if (fFirstActivate) {
+				AutoConnect();
+				fFirstActivate = false;
+			} else {
+				RestoreConnections();
+			}
+
+			return ASE_OK;
+
+		} else {
+			return ASE_NotPresent;
+		}		
+	}
+	
+	return ASE_NotPresent;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::stop()
+{
+	fStarted = false;
+	printf("Stop ASIO Jack\n");
+	SaveConnections();
+	jack_deactivate(fClient);
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getChannels(long *numInputChannels, long *numOutputChannels)
+{
+	*numInputChannels = kNumInputs;
+	*numOutputChannels = kNumOutputs;
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getLatencies(long *_inputLatency, long *_outputLatency)
+{
+	*_inputLatency = fInputLatency;
+	*_outputLatency = fOutputLatency;
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getBufferSize(long *minSize, long *maxSize, long *preferredSize, long *granularity)
+{
+	*minSize = *maxSize = *preferredSize = fBufferSize;		// allow this size only
+	*granularity = 0;
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::canSampleRate(ASIOSampleRate sampleRate)
+{
+	return (sampleRate == fSampleRate) ? ASE_OK : ASE_NoClock;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getSampleRate(ASIOSampleRate *sampleRate)
+{
+	*sampleRate = fSampleRate;
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::setSampleRate(ASIOSampleRate sampleRate)
+{
+	return (sampleRate == fSampleRate) ? ASE_OK : ASE_NoClock;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getClockSources(ASIOClockSource *clocks, long *numSources)
+{
+	// Internal
+	if (clocks && numSources) {
+		clocks->index = 0;
+		clocks->associatedChannel = -1;
+		clocks->associatedGroup = -1;
+		clocks->isCurrentSource = ASIOTrue;
+		strcpy(clocks->name, "Internal");
+		*numSources = 1;
+		return ASE_OK;
+	} else {
+		return ASE_InvalidParameter;
+	}
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::setClockSource(long index)
+{
+	if (!index) {
+		fAsioTime.timeInfo.flags |= kClockSourceChanged;
+		return ASE_OK;
+	} else {
+		return ASE_NotPresent;
+	}
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getSamplePosition(ASIOSamples *sPos, ASIOTimeStamp *tStamp)
+{
+	tStamp->lo = fTheSystemTime.lo;
+	tStamp->hi = fTheSystemTime.hi;
+
+	if (fSamplePosition >= twoRaisedTo32) {
+		sPos->hi = (unsigned long)(fSamplePosition * twoRaisedTo32Reciprocal);
+		sPos->lo = (unsigned long)(fSamplePosition - (sPos->hi * twoRaisedTo32));
+	} else {
+		sPos->hi = 0;
+		sPos->lo = (unsigned long)fSamplePosition;
+	}
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::getChannelInfo(ASIOChannelInfo *info)
+{
+	if (info->channel < 0 || (info->isInput ? info->channel >= kNumInputs : info->channel >= kNumOutputs))
+		return ASE_InvalidParameter;
+#ifdef LONG_SAMPLE
+	info->type = ASIOSTInt32LSB;
+#else
+	info->type = ASIOSTFloat32LSB;
+#endif
+
+	info->channelGroup = 0;
+	info->isActive = ASIOFalse;
+	long i;
+	char buf[32];
+
+	if (info->isInput) {
+		for (i = 0; i < fActiveInputs; i++) {		
+			if (fInMap[i] == info->channel) { 
+				info->isActive = ASIOTrue;
+				//_snprintf(buf, sizeof(buf) - 1, "Jack::In%d ", info->channel);
+				//strcpy(info->name, buf);
+				//strcpy(info->name, jack_port_name(fInputPorts[i]));
+				break;
+			}
+		}
+		_snprintf(buf, sizeof(buf) - 1, "In%d ", info->channel);
+		strcpy(info->name, buf);
+	} else {
+		for (i = 0; i < fActiveOutputs; i++) {	
+			if (fOutMap[i] == info->channel) {  //NOT USED !!
+				info->isActive = ASIOTrue;
+				//_snprintf(buf, sizeof(buf) - 1, "Jack::Out%d ", info->channel);
+				//strcpy(info->name, buf);
+				//strcpy(info->name, jack_port_name(fOutputPorts[i]));
+				break;
+			}
+		}
+		_snprintf(buf, sizeof(buf) - 1, "Out%d ", info->channel);
+		strcpy(info->name, buf);
+	}
+	return ASE_OK;
+}
+
+//------------------------------------------------------------------------------------------
+ASIOError JackRouter::createBuffers(ASIOBufferInfo *bufferInfos, long numChannels,
+	long bufferSize, ASIOCallbacks *callbacks)
+{
+	ASIOBufferInfo *info = bufferInfos;
+	long i;
+	bool notEnoughMem = false;
+	char buf[256];
+	fActiveInputs = 0;
+	fActiveOutputs = 0;
+
+	for (i = 0; i < numChannels; i++, info++) {
+		if (info->isInput) {
+			if (info->channelNum < 0 || info->channelNum >= kNumInputs)
+				goto error;
+			fInMap[fActiveInputs] = info->channelNum;
+		#ifdef LONG_SAMPLE
+			fInputBuffers[fActiveInputs] = new long[fBufferSize * 2];	// double buffer
+		#else
+			fInputBuffers[fActiveInputs] = new float[fBufferSize * 2];	// double buffer
+		#endif
+			if (fInputBuffers[fActiveInputs]) {
+				info->buffers[0] = fInputBuffers[fActiveInputs];
+				info->buffers[1] = fInputBuffers[fActiveInputs] + fBufferSize;
+			} else {
+				info->buffers[0] = info->buffers[1] = 0;
+				notEnoughMem = true;
+			}
+			
+			_snprintf(buf, sizeof(buf) - 1, "in%d", fActiveInputs + 1);
+			fInputPorts[fActiveInputs] 
+				= jack_port_register(fClient, buf, JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput,0);
+			if (fInputPorts[fActiveInputs] == NULL)
+				goto error;
+
+			fActiveInputs++;
+			if (fActiveInputs > kNumInputs) {
+error:
+				disposeBuffers();
+				return ASE_InvalidParameter;
+			}
+		} else {	// output			
+			if (info->channelNum < 0 || info->channelNum >= kNumOutputs)
+				goto error;
+			fOutMap[fActiveOutputs] = info->channelNum;
+	
+		#ifdef LONG_SAMPLE
+			fOutputBuffers[fActiveOutputs] = new long[fBufferSize * 2];	// double buffer
+		#else
+			fOutputBuffers[fActiveOutputs] = new float[fBufferSize * 2];	// double buffer
+		#endif
+	
+			if (fOutputBuffers[fActiveOutputs]) {
+				info->buffers[0] = fOutputBuffers[fActiveOutputs];
+				info->buffers[1] = fOutputBuffers[fActiveOutputs] + fBufferSize;
+			} else {
+				info->buffers[0] = info->buffers[1] = 0;
+				notEnoughMem = true;
+			}
+			
+			_snprintf(buf, sizeof(buf) - 1, "out%d", fActiveOutputs + 1);
+			fOutputPorts[fActiveOutputs] 
+				= jack_port_register(fClient, buf, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput,0);
+			if (fOutputPorts[fActiveOutputs] == NULL)
+				goto error;
+
+			fActiveOutputs++;
+			if (fActiveOutputs > kNumOutputs) {
+				fActiveOutputs--;
+				disposeBuffers();
+				return ASE_InvalidParameter;
+			}
+		}
+	}		
+
+	if (notEnoughMem) {
+		disposeBuffers();
+		return ASE_NoMemory;
+	}
+
+	this->fCallbacks = callbacks;
+	if (callbacks->asioMessage (kAsioSupportsTimeInfo, 0, 0, 0)) {
+		fTimeInfoMode = true;
+		fAsioTime.timeInfo.speed = 1.;
+		fAsioTime.timeInfo.systemTime.hi = fAsioTime.timeInfo.systemTime.lo = 0;
+		fAsioTime.timeInfo.samplePosition.hi = fAsioTime.timeInfo.samplePosition.lo = 0;
+		fAsioTime.timeInfo.sampleRate = fSampleRate;
+		fAsioTime.timeInfo.flags = kSystemTimeValid | kSamplePositionValid | kSampleRateValid;
+
+		fAsioTime.timeCode.speed = 1.;
+		fAsioTime.timeCode.timeCodeSamples.lo = fAsioTime.timeCode.timeCodeSamples.hi = 0;
+		fAsioTime.timeCode.flags = kTcValid | kTcRunning ;
+	} else {
+		fTimeInfoMode = false;	
+	}
+	
+	return ASE_OK;
+}
+
+//---------------------------------------------------------------------------------------------
+ASIOError JackRouter::disposeBuffers()
+{
+	long i;
+	
+	fCallbacks = 0;
+	stop();
+
+	for (i = 0; i < fActiveInputs; i++) {
+		delete[] fInputBuffers[i];
+		jack_port_unregister(fClient, fInputPorts[i]);
+	}		
+	fActiveInputs = 0;
+
+	for (i = 0; i < fActiveOutputs; i++) {
+		delete[] fOutputBuffers[i];
+		jack_port_unregister(fClient, fOutputPorts[i]);
+	}
+	fActiveOutputs = 0;
+
+	return ASE_OK;
+}
+
+//---------------------------------------------------------------------------------------------
+ASIOError JackRouter::controlPanel()
+{
+	return ASE_NotPresent;
+}
+
+//---------------------------------------------------------------------------------------------
+ASIOError JackRouter::future(long selector, void* opt)	// !!! check properties 
+{
+	ASIOTransportParameters* tp = (ASIOTransportParameters*)opt;
+	switch (selector)
+	{
+		case kAsioEnableTimeCodeRead:	fTcRead = true;	return ASE_SUCCESS;
+		case kAsioDisableTimeCodeRead:	fTcRead = false; return ASE_SUCCESS;
+		case kAsioSetInputMonitor:		return ASE_SUCCESS;	// for testing!!!
+		case kAsioCanInputMonitor:		return ASE_SUCCESS;	// for testing!!!
+		case kAsioCanTimeInfo:			return ASE_SUCCESS;
+		case kAsioCanTimeCode:			return ASE_SUCCESS;
+	}
+	return ASE_NotPresent;
+}
+
+//--------------------------------------------------------------------------------------------------------
+// private methods
+//--------------------------------------------------------------------------------------------------------
+
+//---------------------------------------------------------------------------------------------
+void JackRouter::bufferSwitch()
+{
+	if (fStarted && fCallbacks) {
+		getNanoSeconds(&fTheSystemTime);			// latch system time
+		fSamplePosition += fBufferSize;
+		if (fTimeInfoMode) {
+			bufferSwitchX ();
+		} else {
+			fCallbacks->bufferSwitch (fToggle, ASIOFalse);
+		}
+		fToggle = fToggle ? 0 : 1;
+	}
+}
+
+//---------------------------------------------------------------------------------------------
+// asio2 buffer switch
+void JackRouter::bufferSwitchX ()
+{
+	getSamplePosition (&fAsioTime.timeInfo.samplePosition, &fAsioTime.timeInfo.systemTime);
+	long offset = fToggle ? fBufferSize : 0;
+	if (fTcRead) {
+		// Create a fake time code, which is 10 minutes ahead of the card's sample position
+		// Please note that for simplicity here time code will wrap after 32 bit are reached
+		fAsioTime.timeCode.timeCodeSamples.lo = fAsioTime.timeInfo.samplePosition.lo + 600.0 * fSampleRate;
+		fAsioTime.timeCode.timeCodeSamples.hi = 0;
+	}
+	fCallbacks->bufferSwitchTimeInfo (&fAsioTime, fToggle, ASIOFalse);
+	fAsioTime.timeInfo.flags &= ~(kSampleRateChanged | kClockSourceChanged);
+}
+
+//---------------------------------------------------------------------------------------------
+ASIOError JackRouter::outputReady()
+{
+	return ASE_NotPresent;
+}
+
+//---------------------------------------------------------------------------------------------
+double AsioSamples2double(ASIOSamples* samples)
+{
+	double a = (double)(samples->lo);
+	if (samples->hi)
+		a += (double)(samples->hi) * twoRaisedTo32;
+	return a;
+}
+
+//---------------------------------------------------------------------------------------------
+void getNanoSeconds(ASIOTimeStamp* ts)
+{
+	double nanoSeconds = (double)((unsigned long)timeGetTime ()) * 1000000.;
+	ts->hi = (unsigned long)(nanoSeconds / twoRaisedTo32);
+	ts->lo = (unsigned long)(nanoSeconds - (ts->hi * twoRaisedTo32));
+}
+
+//------------------------------------------------------------------------
+void JackRouter::SaveConnections()
+{
+    const char** connections;
+ 	int i;
+
+    for (i = 0; i < fActiveInputs; ++i) {
+        if (fInputPorts[i] && (connections = jack_port_get_connections(fInputPorts[i])) != 0) {
+            for (int j = 0; connections[j]; j++) {
+                fConnections.push_back(make_pair(connections[j], jack_port_name(fInputPorts[i])));
+            }
+            jack_free(connections);
+        }
+    }
+
+    for (i = 0; i < fActiveOutputs; ++i) {
+        if (fOutputPorts[i] && (connections = jack_port_get_connections(fOutputPorts[i])) != 0) {
+            for (int j = 0; connections[j]; j++) {
+                fConnections.push_back(make_pair(jack_port_name(fOutputPorts[i]), connections[j]));
+            }
+            jack_free(connections);
+        }
+    }
+}
+
+//------------------------------------------------------------------------
+void JackRouter::RestoreConnections()
+{
+    list<pair<string, string> >::const_iterator it;
+
+    for (it = fConnections.begin(); it != fConnections.end(); it++) {
+        pair<string, string> connection = *it;
+        jack_connect(fClient, connection.first.c_str(), connection.second.c_str());
+    }
+
+    fConnections.clear();
+}
+
+//------------------------------------------------------------------------------------------
+void JackRouter::AutoConnect()
+{
+	const char** ports;
+	
+	if ((ports = jack_get_ports(fClient, NULL, NULL, JackPortIsPhysical | JackPortIsOutput)) == NULL) {
+		printf("Cannot find any physical capture ports\n");
+	} else {
+		if (fAutoConnectIn) {
+			for (int i = 0; i < fActiveInputs; i++) {
+				if (!ports[i]) {
+					printf("source port is null i = %ld\n", i);
+					break;
+				} else if (jack_connect(fClient, ports[i], jack_port_name(fInputPorts[i])) != 0) {
+					printf("Cannot connect input ports\n");
+				}
+			}
+		}
+		jack_free(ports); 
+	}
+	
+	if ((ports = jack_get_ports(fClient, NULL, NULL, JackPortIsPhysical | JackPortIsInput)) == NULL) {
+		printf("Cannot find any physical playback ports");
+	} else {
+		if (fAutoConnectOut) {
+			for (int i = 0; i < fActiveOutputs; i++) {
+				if (!ports[i]){
+					printf("destination port is null i = %ld\n", i);
+					break;
+				} else if (jack_connect(fClient, jack_port_name(fOutputPorts[i]), ports[i]) != 0) {
+					printf("Cannot connect output ports\n");
+				}
+			}
+		}
+		jack_free(ports); 
+	}
+}
+
diff --git a/windows/JackRouter/JackRouter.def b/windows/JackRouter/JackRouter.def
new file mode 100644
index 0000000..1316d71
--- /dev/null
+++ b/windows/JackRouter/JackRouter.def
@@ -0,0 +1,9 @@
+LIBRARY			JackRouter
+DESCRIPTION		'ASIO Jack Driver'
+PROTMODE
+EXPORTS	
+				DllMain
+				DllGetClassObject
+				DllCanUnloadNow
+				DllRegisterServer
+				DllUnregisterServer
diff --git a/windows/JackRouter/JackRouter.dsp b/windows/JackRouter/JackRouter.dsp
new file mode 100644
index 0000000..c92ddf9
--- /dev/null
+++ b/windows/JackRouter/JackRouter.dsp
@@ -0,0 +1,163 @@
+# Microsoft Developer Studio Project File - Name="JackRouter" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=JackRouter - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "JackRouter.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "JackRouter.mak" CFG="JackRouter - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "JackRouter - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "JackRouter - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "JackRouter - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\..\..\..\..\ASIOSDK2\common" /I "..\..\common" /I "..\..\common\jack" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib winmm.lib /nologo /subsystem:windows /dll /machine:I386
+
+!ELSEIF  "$(CFG)" == "JackRouter - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /GZ /c
+# ADD CPP /nologo /G5 /MDd /W3 /Gm /GX /Zi /Od /I "..\..\..\..\..\ASIOSDK2\common" /I "..\..\common" /I "..\..\common\jack" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /FR /YX /FD /GZ /c
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib winmm.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:"Debug/JackRouter_debug.dll" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "JackRouter - Win32 Release"
+# Name "JackRouter - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\..\..\..\..\ASIOSDK2\common\combase.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\..\..\ASIOSDK2\common\dllentry.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\JackRouter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\JackRouter.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\profport.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\..\..\ASIOSDK2\common\register.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\resource.rc
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\..\..\common\asio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\Common\Asiodrvr.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\asiosmpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\common\asiosys.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\common\combase.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\..\common\iasiodrv.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# Begin Source File
+
+SOURCE=.\Psapi.Lib
+# End Source File
+# Begin Source File
+
+SOURCE=..\Release\bin\libjack.lib
+# End Source File
+# End Target
+# End Project
diff --git a/windows/JackRouter/JackRouter.dsw b/windows/JackRouter/JackRouter.dsw
new file mode 100644
index 0000000..e26ab1e
--- /dev/null
+++ b/windows/JackRouter/JackRouter.dsw
@@ -0,0 +1,29 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "JackRouter"=".\JackRouter.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff --git a/windows/JackRouter/JackRouter.h b/windows/JackRouter/JackRouter.h
new file mode 100644
index 0000000..bf5d44c
--- /dev/null
+++ b/windows/JackRouter/JackRouter.h
@@ -0,0 +1,174 @@
+/*
+Copyright (C) 2006 Grame  
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef _asiosmpl_
+#define _asiosmpl_
+
+#include "asiosys.h"
+
+
+// Globals
+static int	kBlockFrames = 256;
+static int	kNumInputs = 4;
+static int	kNumOutputs = 4;
+
+
+#if WINDOWS
+
+#include "jack.h"
+#include "rpc.h"
+#include "rpcndr.h"
+#ifndef COM_NO_WINDOWS_H
+#include <windows.h>
+#include "ole2.h"
+
+#endif
+
+#include "combase.h"
+#include "iasiodrv.h"
+
+#define MAX_PORTS 32
+
+#define LONG_SAMPLE 1
+
+#define PATH_SEP "\\"
+
+#include <list>
+#include <string>
+
+class JackRouter : public IASIO, public CUnknown
+{
+public:
+	JackRouter(LPUNKNOWN pUnk, HRESULT *phr);
+	~JackRouter();
+
+	DECLARE_IUNKNOWN
+    //STDMETHODIMP QueryInterface(REFIID riid, void **ppv) {      \
+    //    return GetOwner()->QueryInterface(riid,ppv);            \
+    //};                                                          \
+    //STDMETHODIMP_(ULONG) AddRef() {                             \
+    //    return GetOwner()->AddRef();                            \
+    //};                                                          \
+    //STDMETHODIMP_(ULONG) Release() {                            \
+    //    return GetOwner()->Release();                           \
+    //};
+
+	// Factory method
+	static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
+	// IUnknown
+	virtual HRESULT STDMETHODCALLTYPE NonDelegatingQueryInterface(REFIID riid,void **ppvObject);
+#else
+
+#include "asiodrvr.h"
+
+
+//---------------------------------------------------------------------------------------------
+class JackRouter : public AsioDriver
+{
+public:
+	JackRouter();
+	~JackRouter();
+#endif
+
+	static int process(jack_nframes_t nframes, void* arg);
+	static void shutdown(void* arg);
+
+	ASIOBool init(void* sysRef);
+	void getDriverName(char *name);		// max 32 bytes incl. terminating zero
+	long getDriverVersion();
+	void getErrorMessage(char *string);	// max 128 bytes incl.
+
+	ASIOError start();
+	ASIOError stop();
+
+	ASIOError getChannels(long *numInputChannels, long *numOutputChannels);
+	ASIOError getLatencies(long *inputLatency, long *outputLatency);
+	ASIOError getBufferSize(long *minSize, long *maxSize,
+		long *preferredSize, long *granularity);
+
+	ASIOError canSampleRate(ASIOSampleRate sampleRate);
+	ASIOError getSampleRate(ASIOSampleRate *sampleRate);
+	ASIOError setSampleRate(ASIOSampleRate sampleRate);
+	ASIOError getClockSources(ASIOClockSource *clocks, long *numSources);
+	ASIOError setClockSource(long index);
+
+	ASIOError getSamplePosition(ASIOSamples *sPos, ASIOTimeStamp *tStamp);
+	ASIOError getChannelInfo(ASIOChannelInfo *info);
+
+	ASIOError createBuffers(ASIOBufferInfo *bufferInfos, long numChannels,
+		long bufferSize, ASIOCallbacks *callbacks);
+	ASIOError disposeBuffers();
+
+	ASIOError controlPanel();
+	ASIOError future(long selector, void *opt);
+	ASIOError outputReady();
+
+	void bufferSwitch();
+	long getMilliSeconds() {return fMilliSeconds;}
+
+	static bool fFirstActivate;
+	static std::list<std::pair<std::string, std::string> > fConnections;  // Connections list
+
+private:
+
+	void bufferSwitchX();
+
+	double fSamplePosition;
+	ASIOCallbacks* fCallbacks;
+	ASIOTime fAsioTime;
+	ASIOTimeStamp fTheSystemTime;
+
+#ifdef LONG_SAMPLE
+	long* fInputBuffers[MAX_PORTS * 2];
+	long* fOutputBuffers[MAX_PORTS * 2];
+#else
+	float* fInputBuffers[MAX_PORTS * 2];
+	float* fOutputBuffers[MAX_PORTS * 2];
+#endif
+	long fInMap[MAX_PORTS];
+	long fOutMap[MAX_PORTS];
+
+	long fInputLatency;
+	long fOutputLatency;
+	long fActiveInputs;
+	long fActiveOutputs;
+	long fToggle;
+	long fMilliSeconds;
+	bool fActive, fStarted;
+	bool fTimeInfoMode, fTcRead;
+	char fErrorMessage[128];
+
+	bool fAutoConnectIn;
+	bool fAutoConnectOut;
+
+	// Jack part
+	jack_client_t* fClient;
+	jack_port_t* fInputPorts[MAX_PORTS];
+	jack_port_t* fOutputPorts[MAX_PORTS];
+	long fBufferSize;
+	ASIOSampleRate fSampleRate;
+
+	void AutoConnect();
+	void SaveConnections();
+    void RestoreConnections();
+
+};
+
+#endif
+
diff --git a/windows/JackRouter/Psapi.Lib b/windows/JackRouter/Psapi.Lib
new file mode 100644
index 0000000..ae89691
Binary files /dev/null and b/windows/JackRouter/Psapi.Lib differ
diff --git a/windows/JackRouter/README b/windows/JackRouter/README
new file mode 100644
index 0000000..5f2bce1
--- /dev/null
+++ b/windows/JackRouter/README
@@ -0,0 +1,3 @@
+This folder contains the sources for ASIO/JACK bridge ASIO driver called "JackRouter". The included project is a Microsoft VC++ 6 one. 
+It requires some files (combase.cpp, dllentry.cpp, register.cpp) that are part on the ASIO driver SDK. The produced "JackRouter.dll" file
+has to be registered in the system using the "regsvr32" tool.
\ No newline at end of file
diff --git a/windows/JackRouter/profport.cpp b/windows/JackRouter/profport.cpp
new file mode 100644
index 0000000..eb77937
--- /dev/null
+++ b/windows/JackRouter/profport.cpp
@@ -0,0 +1,315 @@
+/*
+History : 
+01-28-02 : Change the location of temporary files created in write_private_profile_string
+		   now done in TmpDirectory.
+01-29-02 : Correct bug when the '=' character is not present.
+06-18-02 : Return default value if file does not exist, new write_private_profile_int function.
+*/
+
+/***** Routines to read profile strings --  by Joseph J. Graf ******/
+/***** corrections and improvements -- by D. Fober - Grame ******/
+/*
+	corrections: buffer sizes control
+	improvements: behavior more similar to windows
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <string>
+
+#include <ctype.h> 
+#include "profport.h"   /* function prototypes in here */
+
+#ifndef WIN32
+
+static int read_line (FILE *fp, char *bp, int size);
+static int read_section(FILE *fp, char *section);
+static int read_entry (FILE *fp, char *entry, char *buff, int size);
+static char * read_value (char *buff);
+static int read_int_value (char *buff, int def);
+static char * read_file (char *file);
+static char * str_search (char * buff, char * str, int stopCond);
+
+/*****************************************************************
+* Function:     read_line()
+* Arguments:    <FILE *> fp - a pointer to the file to be read from
+*               <char *> bp - a pointer to the copy buffer
+*               <int>  size - size of the copy buffer
+* Returns:      the line length if successful -1 otherwise
+******************************************************************/
+static int read_line(FILE *fp, char *bp, int size)
+{  
+	char c = '\0';
+	int i = 0, limit = size-2;
+
+	/* Read one line from the source file */
+	while (((c = getc(fp)) != '\n') && (i < limit)) {
+		if (c == EOF) {
+			if (!i) return -1;
+			else break;
+		}
+		bp[i++] = c;
+	}
+	bp[i] = '\0';
+	return i;
+}
+
+static int read_section (FILE *fp, char *section)
+{  
+	char buff[MAX_LINE_LENGTH];
+	char t_section[MAX_LINE_LENGTH];
+	int n, slen;
+
+	sprintf(t_section,"[%s]", section); /* Format the section name */
+	slen = strlen (t_section);
+	/*  Move through file 1 line at a time until a section is matched or EOF */
+	do {
+		n = read_line(fp, buff, MAX_LINE_LENGTH); 
+		if (n == -1)   
+			return 0;
+	} while (strncmp (buff,t_section, slen));
+	return 1;
+ }
+
+static int read_entry (FILE *fp, char *entry, char *buff, int size)
+{  
+	int n, elen = strlen (entry);
+
+	do {
+		n = read_line(fp, buff, size); 
+		if (n == -1) 
+			return 0;
+		else if (*buff == '[')
+			return 0;	
+	} while (strncmp (buff, entry, elen));
+	return 1;
+ }
+
+#define isBlank(c)	((c == ' ') || (c == '\t'))
+static char * read_value (char *buff)
+{  
+    char * eq = strrchr (buff,'=');    /* Parse out the equal sign */
+    if (eq) {
+    	eq++;
+    	while (*eq && isBlank(*eq))
+    		eq++;
+//    	return *eq ? eq : 0;
+    	return eq;
+    }
+    return eq;
+ }
+
+#define isSignedDigit(c)	(isdigit(c) || (c == '+') || (c == '-'))
+static int read_int_value (char *buff, int def)
+{  
+    char * val = read_value (buff);
+    char value[20]; int i;
+    
+    if (!*val) return def;
+    
+	for (i = 0; isSignedDigit(*val) && (i <= 10); i++ )
+		value[i] = *val++;
+	value[i] = '\0';
+    return value[0] ? atoi(value) : def;
+}
+ 
+static char * read_file (char *file)
+{
+	FILE *fd = fopen (file,"r");
+	int size; char * buff = 0;
+	
+	if (!fd) return 0;
+	if (fseek (fd, 0, SEEK_END) == -1) goto err;
+	size = ftell (fd);
+	if (size < 0) goto err;
+	if (fseek (fd, 0, SEEK_SET) == -1) goto err;
+	buff = (char *) malloc (size+1);
+	if (buff) {
+		*buff = 0;
+		fread (buff, 1, size, fd);
+		buff[size] = 0;
+	}
+err:
+	fclose (fd);
+	return buff;
+}
+ 
+static char * str_search (char * buff, char * str, int stopCond)
+{
+	char *ptr = buff;
+	int len = strlen (str);
+	while (*ptr && strncmp (ptr, str, len)) {
+		while (*ptr && (*ptr++ != '\n')) 
+			;
+		if (*ptr == stopCond)
+			return 0;
+	}
+	return *ptr ? ptr : 0;
+}
+
+/**************************************************************************
+* Function:     get_private_profile_int()
+* Arguments:    <char *> section - the name of the section to search for
+*               <char *> entry - the name of the entry to find the value of
+*               <int> def - the default value in the event of a failed read
+*               <char *> file_name - the name of the .ini file to read from
+* Returns:      the value located at entry
+***************************************************************************/
+int get_private_profile_int(char *section,
+    char *entry, int def, char *file_name)
+{   
+    FILE *fp = fopen(file_name,"r");
+    char buff[MAX_LINE_LENGTH];
+    
+    if( !fp ) return def; /* Return default value if file does not exist */
+    if (!read_section (fp, section)) goto err;
+    if (!read_entry (fp, entry, buff, MAX_LINE_LENGTH)) goto err;
+	def = read_int_value (buff, def);
+err:
+	fclose (fp);
+	return def;
+}
+
+/**************************************************************************
+* Function:     get_private_profile_string()
+* Arguments:    <char *> section - the name of the section to search for
+*               <char *> entry - the name of the entry to find the value of
+*               <char *> def - default string in the event of a failed read
+*               <char *> buffer - a pointer to the buffer to copy into
+*               <int> buffer_len - the max number of characters to copy
+*               <char *> file_name - the name of the .ini file to read from
+* Returns:      the number of characters copied into the supplied buffer
+***************************************************************************/
+
+int get_private_profile_string(char *section, char *entry, char *def,
+    char *buffer, int buffer_len, char *file_name)
+{   
+    FILE *fp = fopen (file_name,"r");
+    char buff[MAX_LINE_LENGTH];
+    char *val;
+    
+    if( !fp ) goto err; /* Return default value if file does not exist */
+    if (!read_section (fp, section)) goto err;
+    if (!read_entry (fp, entry, buff, MAX_LINE_LENGTH)) goto err;
+	val = read_value (buff);
+    if(val) def = val;
+
+err:
+	if (fp) fclose (fp);
+	if (def) {
+		strncpy (buffer, def, buffer_len - 1);
+		buffer[buffer_len] = '\0';
+	}
+	else buffer[buffer_len] = '\0';
+	return strlen (buffer);
+}
+
+
+/***************************************************************************
+ * Function:    write_private_profile_string()
+ * Arguments:   <char *> section - the name of the section to search for
+ *              <char *> entry - the name of the entry to find the value of
+ *              <char *> buffer - pointer to the buffer that holds the string
+ *              <char *> file_name - the name of the .ini file to read from
+ * Returns:     TRUE if successful, otherwise FALSE
+ ***************************************************************************/
+int write_private_profile_string(char *section,
+    char *entry, char *buffer, char *file_name)
+
+{
+	char * content = read_file(file_name);
+	FILE * fd = fopen(file_name,"w");
+    char t_section[MAX_LINE_LENGTH], *ptr;
+    int ret = 0;
+	
+	if (!fd) goto end;
+	if (!content) {
+    	fprintf (fd, "[%s]\n%s = %s\n", section, entry, buffer);
+    	ret = 1;
+    	goto end;
+	}
+    sprintf(t_section,"[%s]",section);         /* Format the section name */
+    ptr = str_search (content, t_section, 0);  /* look for the section start */
+    if (!ptr) {
+    	/* no such section: add the new section at end of file */
+    	fprintf (fd, "%s\n[%s]\n%s = %s\n", content, section, entry, buffer);
+    }
+    else {
+    	char * eptr;
+    	eptr = str_search (ptr, entry, '[');
+    	if (!eptr) {
+    		/* no such entry: looks for next section */
+    		eptr = str_search (++ptr, "[", 0);
+	    	if (!eptr) {
+    			/* section is the last one */
+	    		fprintf (fd, "%s\n%s = %s\n", content, entry, buffer);
+	    	}
+	    	else {
+	    		while (*ptr && (*ptr != '\n')) ptr++;
+	    		*ptr = 0;
+	    		fprintf (fd, "%s\n%s = %s", content, entry, buffer);
+	    		*ptr = '\n';
+	    		fprintf (fd, "%s", ptr);
+	    	}
+	    }
+	    else {
+	    	*eptr++ = 0;
+	    	fprintf (fd, "%s%s = %s", content, entry, buffer);
+	    	while (*eptr && (*eptr != '\n')) eptr++;
+	    	if (eptr) fprintf (fd, "%s", eptr);
+	    }
+    }
+    ret = 1;
+
+end:
+	if (content) free(content);
+	if (fd) fclose(fd);
+	return 0;
+}
+
+/***************************************************************************
+ * Function:    write_private_profile_int()
+ * Arguments:   <char *> section - the name of the section to search for
+ *              <char *> entry - the name of the entry to find the value of
+ *              <int> buffer - the value to be written
+ *              <char *> file_name - the name of the .ini file to read from
+ * Returns:     TRUE if successful, otherwise FALSE
+ ***************************************************************************/
+int write_private_profile_int(char *section,
+    char *entry, int val, char *file_name)
+{
+    char buffer [64];
+    sprintf(buffer, "%d", val);
+    return write_private_profile_string (section,entry, buffer, file_name);
+}
+
+#endif // #ifndef WIN32
+
+
+/**************************************************************************
+* Function:     get_private_profile_float()
+* Arguments:    <char *> section - the name of the section to search for
+*               <char *> entry - the name of the entry to find the value of
+*               <float> def - the default value in the event of a failed read
+*               <char *> file_name - the name of the .ini file to read from
+* Returns:      the value located at entry
+* Warning:		The float value to be read must not contain more than 100 digits.
+* Author:		CD, 15/11/2006.
+***************************************************************************/
+#define maxFloatLen	100
+float get_private_profile_float	(char * section, char * entry, float def, char * file_name)
+{
+	float result = def;
+	char buffer[ maxFloatLen ], *endptr;
+
+	if ( get_private_profile_string(section, entry, "", buffer, maxFloatLen, file_name) > 0 )
+	{
+		result = (float)strtod(buffer, &endptr);
+		if ((result==0) && (endptr==buffer))
+			result = def;
+	}
+	return result;
+}
diff --git a/windows/JackRouter/profport.h b/windows/JackRouter/profport.h
new file mode 100644
index 0000000..2f71717
--- /dev/null
+++ b/windows/JackRouter/profport.h
@@ -0,0 +1,37 @@
+
+/******************************************************************************
+ PORTABLE ROUTINES FOR WRITING PRIVATE PROFILE STRINGS --  by Joseph J. Graf
+ Header file containing prototypes and compile-time configuration.
+ 
+ [09/05/02] D. Fober - Windows definitions added
+******************************************************************************/
+
+#ifndef __profport__
+#define __profport__
+
+#define MAX_LINE_LENGTH    1024
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef WIN32
+#include "Windows.h"
+#define get_private_profile_int        GetPrivateProfileInt
+#define get_private_profile_string     GetPrivateProfileString
+#define write_private_profile_string   WritePrivateProfileString
+#define write_private_profile_int      WritePrivateProfileInt
+#else
+int get_private_profile_int      (char * section, char * entry, int def, char * file_name);
+int get_private_profile_string   (char * section, char * entry, char * def, char * buffer, int buffer_len, char * file_name);
+int write_private_profile_string (char * section, char * entry, char * buffer, char * file_name);
+int write_private_profile_int    (char * section, char * entry, int val, char * file_name);
+#endif
+
+float get_private_profile_float	(char * section, char * entry, float def, char * file_name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //__profport__
diff --git a/windows/JackRouter/psapi.dll b/windows/JackRouter/psapi.dll
new file mode 100644
index 0000000..ff4c964
Binary files /dev/null and b/windows/JackRouter/psapi.dll differ
diff --git a/windows/JackRouter/psapi.h b/windows/JackRouter/psapi.h
new file mode 100644
index 0000000..af72931
--- /dev/null
+++ b/windows/JackRouter/psapi.h
@@ -0,0 +1,95 @@
+/*
+	psapi.h - Include file for PSAPI.DLL APIs
+
+	Written by Mumit Khan <khan@nanotech.wisc.edu>
+
+	This file is part of a free library for the Win32 API.
+
+	NOTE: This strictly does not belong in the Win32 API since it's
+	really part of Platform SDK. However,GDB needs it and we might
+	as well provide it here.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+*/
+#ifndef _PSAPI_H
+#define _PSAPI_H
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef RC_INVOKED
+
+typedef struct _MODULEINFO {
+	LPVOID lpBaseOfDll;
+	DWORD SizeOfImage;
+	LPVOID EntryPoint;
+} MODULEINFO,*LPMODULEINFO;
+
+typedef struct _PSAPI_WS_WATCH_INFORMATION {
+	LPVOID FaultingPc;
+	LPVOID FaultingVa;
+} PSAPI_WS_WATCH_INFORMATION,*PPSAPI_WS_WATCH_INFORMATION;
+
+typedef struct _PROCESS_MEMORY_COUNTERS {
+	DWORD cb;
+	DWORD PageFaultCount;
+	DWORD PeakWorkingSetSize;
+	DWORD WorkingSetSize;
+	DWORD QuotaPeakPagedPoolUsage;
+	DWORD QuotaPagedPoolUsage;
+	DWORD QuotaPeakNonPagedPoolUsage;
+	DWORD QuotaNonPagedPoolUsage;
+	DWORD PagefileUsage;
+	DWORD PeakPagefileUsage;
+} PROCESS_MEMORY_COUNTERS,*PPROCESS_MEMORY_COUNTERS;
+
+/* Grouped by application,not in alphabetical order. */
+BOOL WINAPI EnumProcesses(DWORD *,DWORD,DWORD *);
+BOOL WINAPI EnumProcessModules(HANDLE,HMODULE *,DWORD,LPDWORD);
+DWORD WINAPI GetModuleBaseNameA(HANDLE,HMODULE,LPSTR,DWORD);
+DWORD WINAPI GetModuleBaseNameW(HANDLE,HMODULE,LPWSTR,DWORD);
+DWORD WINAPI GetModuleFileNameExA(HANDLE,HMODULE,LPSTR,DWORD);
+DWORD WINAPI GetModuleFileNameExW(HANDLE,HMODULE,LPWSTR,DWORD);
+BOOL WINAPI GetModuleInformation(HANDLE,HMODULE,LPMODULEINFO,DWORD);
+BOOL WINAPI EmptyWorkingSet(HANDLE);
+BOOL WINAPI QueryWorkingSet(HANDLE,PVOID,DWORD);
+BOOL WINAPI InitializeProcessForWsWatch(HANDLE);
+BOOL WINAPI GetWsChanges(HANDLE,PPSAPI_WS_WATCH_INFORMATION,DWORD);
+DWORD WINAPI GetMappedFileNameW(HANDLE,LPVOID,LPWSTR,DWORD);
+DWORD WINAPI GetMappedFileNameA(HANDLE,LPVOID,LPSTR,DWORD);
+BOOL WINAPI EnumDeviceDrivers(LPVOID *,DWORD,LPDWORD);
+DWORD WINAPI GetDeviceDriverBaseNameA(LPVOID,LPSTR,DWORD);
+DWORD WINAPI GetDeviceDriverBaseNameW(LPVOID,LPWSTR,DWORD);
+DWORD WINAPI GetDeviceDriverFileNameA(LPVOID,LPSTR,DWORD);
+DWORD WINAPI GetDeviceDriverFileNameW(LPVOID,LPWSTR,DWORD);
+BOOL WINAPI GetProcessMemoryInfo(HANDLE,PPROCESS_MEMORY_COUNTERS,DWORD);
+
+#endif /* not RC_INVOKED */
+
+#ifdef UNICODE
+#define GetModuleBaseName GetModuleBaseNameW
+#define GetModuleFileNameEx GetModuleFileNameExW
+#define GetMappedFilenameEx GetMappedFilenameExW
+#define GetDeviceDriverBaseName GetDeviceDriverBaseNameW
+#define GetDeviceDriverFileName GetDeviceDriverFileNameW
+#else
+#define GetModuleBaseName GetModuleBaseNameA
+#define GetModuleFileNameEx GetModuleFileNameExA
+#define GetMappedFilenameEx GetMappedFilenameExA
+#define GetDeviceDriverBaseName GetDeviceDriverBaseNameA
+#define GetDeviceDriverFileName GetDeviceDriverFileNameA
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PSAPI_H */
+
diff --git a/windows/JackRouter/resource.h b/windows/JackRouter/resource.h
new file mode 100644
index 0000000..673206e
--- /dev/null
+++ b/windows/JackRouter/resource.h
@@ -0,0 +1,15 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Developer Studio generated include file.
+// Used by resource.rc
+//
+
+// Next default values for new objects
+//
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        102
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1000
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/windows/JackRouter/resource.rc b/windows/JackRouter/resource.rc
new file mode 100644
index 0000000..4289ddc
--- /dev/null
+++ b/windows/JackRouter/resource.rc
@@ -0,0 +1,109 @@
+//Microsoft Developer Studio generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// French (France) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_FRA)
+#ifdef _WIN32
+LANGUAGE LANG_FRENCH, SUBLANG_FRENCH
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 0,2,0,0
+ PRODUCTVERSION 0,2,0,0
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040c04b0"
+        BEGIN
+            VALUE "Comments", "\0"
+            VALUE "CompanyName", "Grame\0"
+            VALUE "FileDescription", "JackRouter ASIO driver\0"
+            VALUE "FileVersion", "0, 2, 0, 0\0"
+            VALUE "InternalName", "JackRouter\0"
+            VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
+            VALUE "LegalTrademarks", "\0"
+            VALUE "OriginalFilename", "JackRouter.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "JackRouter\0"
+            VALUE "ProductVersion", "0, 2, 0, 0\0"
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x40c, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // French (France) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/windows/JackWinNamedPipeServerChannel.cpp b/windows/JackWinNamedPipeServerChannel.cpp
index da0da44..3e6daa9 100644
--- a/windows/JackWinNamedPipeServerChannel.cpp
+++ b/windows/JackWinNamedPipeServerChannel.cpp
@@ -24,6 +24,8 @@ Copyright (C) 2004-2006 Grame
 #include "JackLockedEngine.h"
 #include "JackGlobals.h"
 #include "JackClient.h"
+#include "JackNotification.h"
+#include "JackException.h"
 #include <assert.h>
 
 using namespace std;
@@ -57,7 +59,7 @@ int JackClientPipeThread::Open(JackServer* server)	// Open the Server/Client con
         jack_error("Cannot start Jack server listener\n");
         return -1;
     }
-    
+
     fServer = server;
     return 0;
 }
@@ -71,15 +73,20 @@ void JackClientPipeThread::Close()					// Close the Server/Client connection
     	all ressources will be desallocated at the end.
     */
 
-    fThread.Kill();
+    fThread.Stop();
     fPipe->Close();
     fRefNum = -1;
 }
-    
+
 bool JackClientPipeThread::Execute()
 {
-    jack_log("JackClientPipeThread::Execute");
-    return(HandleRequest());
+    try{
+        jack_log("JackClientPipeThread::Execute");
+        return (HandleRequest());
+    } catch (JackQuitException& e) {
+        jack_log("JackMachServerChannel::Execute JackQuitException");
+        return false;
+    }
 }
 
 bool JackClientPipeThread::HandleRequest()
@@ -307,8 +314,14 @@ bool JackClientPipeThread::HandleRequest()
             case JackRequest::kNotification: {
                 jack_log("JackRequest::Notification");
                 JackClientNotificationRequest req;
-                if (req.Read(fPipe) == 0)
-                    fServer->Notify(req.fRefNum, req.fNotify, req.fValue);
+                if (req.Read(fPipe) == 0) {
+                    if (req.fNotify == kQUIT) {
+                        jack_log("JackRequest::Notification kQUIT");
+                        throw JackQuitException();
+                    } else {
+                        fServer->Notify(req.fRefNum, req.fNotify, req.fValue);
+                    }
+                }
                 break;
             }
 
@@ -317,7 +330,7 @@ bool JackClientPipeThread::HandleRequest()
                 break;
         }
     }
- 
+
     // Unlock the global mutex
     ReleaseMutex(fMutex);
     return ret;
@@ -373,17 +386,17 @@ int JackWinNamedPipeServerChannel::Open(const char* server_name, JackServer* ser
 {
     jack_log("JackWinNamedPipeServerChannel::Open ");
     snprintf(fServerName, sizeof(fServerName), server_name);
-    
+
     // Needed for internal connection from JackWinNamedPipeServerNotifyChannel object
     if (fRequestListenPipe.Bind(jack_server_dir, server_name, 0) < 0) {
         jack_error("JackWinNamedPipeServerChannel::Open : cannot create result listen pipe");
         return -1;
     }
-    
+
     fServer = server;
     return 0;
 }
-    
+
 void JackWinNamedPipeServerChannel::Close()
 {
     /* TODO : solve WIN32 thread Kill issue
@@ -403,11 +416,11 @@ int JackWinNamedPipeServerChannel::Start()
     if (fThread.Start() != 0) {
         jack_error("Cannot start Jack server listener");
         return -1;
-    }  
-    
+    }
+
     return 0;
-}    
-    
+}
+
 bool JackWinNamedPipeServerChannel::Init()
 {
     jack_log("JackWinNamedPipeServerChannel::Init ");
diff --git a/windows/JackWinNamedPipeServerNotifyChannel.cpp b/windows/JackWinNamedPipeServerNotifyChannel.cpp
index 1e3c4e2..8036d81 100644
--- a/windows/JackWinNamedPipeServerNotifyChannel.cpp
+++ b/windows/JackWinNamedPipeServerNotifyChannel.cpp
@@ -21,6 +21,7 @@ This program is free software; you can redistribute it and/or modify
 #include "JackError.h"
 #include "JackRequest.h"
 #include "JackConstants.h"
+#include "JackNotification.h"
 
 namespace Jack
 {
@@ -54,6 +55,14 @@ void JackWinNamedPipeServerNotifyChannel::Notify(int refnum, int notify, int val
     }
 }
 
+void JackWinNamedPipeServerNotifyChannel::NotifyQuit()
+{
+    JackClientNotificationRequest req(-1, kQUIT, 0);
+    if (req.Write(&fRequestPipe) < 0) {
+        jack_error("Could not write request ref = %d notify = %d", -1, kQUIT);
+    }
+}
+
 } // end of namespace
 
 
diff --git a/windows/JackWinNamedPipeServerNotifyChannel.h b/windows/JackWinNamedPipeServerNotifyChannel.h
index aa1a6c9..be4d7ff 100644
--- a/windows/JackWinNamedPipeServerNotifyChannel.h
+++ b/windows/JackWinNamedPipeServerNotifyChannel.h
@@ -45,6 +45,7 @@ class JackWinNamedPipeServerNotifyChannel
         void Close();
 
         void Notify(int refnum, int notify, int value);
+        void NotifyQuit();
 };
 
 } // end of namespace
diff --git a/windows/Setup/JackRouter.dll b/windows/Setup/JackRouter.dll
index 226ea66..f06fe1b 100644
Binary files a/windows/Setup/JackRouter.dll and b/windows/Setup/JackRouter.dll differ
diff --git a/windows/Setup/jack.ci b/windows/Setup/jack.ci
index 2c3eb9a..2523339 100644
--- a/windows/Setup/jack.ci
+++ b/windows/Setup/jack.ci
@@ -1,9 +1,9 @@
 <*project
       version = 4 civer = "Free v4.14.5" winver = "2.6/5.1.2600" > 
    <output> .</>
-   <exename> Jack_v1.9.4_setup.exe</>
+   <exename> Jack_v1.9.5_setup.exe</>
    <digitsign> </>
-   <appname> Jack v1.9.4</>
+   <appname> Jack v1.9.5</>
    <password> </>
    <addlang> </>
    <icon> Default - 2</>
@@ -72,6 +72,8 @@
 <_><src>..\Release\bin\libsamplerate-0.dll</><dest>inst</><custom></><ifexist>overnewer</><recurs>0</></>
 <_><src>..\Release\bin\portaudio_x86.dll</><dest>inst</><custom></><ifexist>overnewer</><recurs>0</></>
 <_><src>..\Release\bin\jack\jack_net.dll</><dest>inst</><custom>jack</><ifexist>overnewer</><recurs>0</></>
+<_><src>..\Release\bin\jack\jack_netone.dll</><dest>inst</><custom>jack</><ifexist>overnewer</><recurs>0</></>
+<_><src>..\Release\bin\jack_netsource.exe</><dest>inst</><custom></><ifexist>overnewer</><recurs>0</></>
 <_><src>..\Release\bin\jack\jack_dummy.dll</><dest>inst</><custom>jack</><ifexist>overnewer</><recurs>0</></>
 <_><src>..\Release\bin\jack\jack_loopback.dll</><dest>inst</><custom>jack</><ifexist>overnewer</><recurs>0</></>
 <_><src>..\Release\bin\jack\jack_winmme.dll</><dest>inst</><custom>jack</><ifexist>overnewer</><recurs>0</></>
diff --git a/windows/jack_disconnect.cbp b/windows/jack_disconnect.cbp
index cbb0251..994f212 100644
--- a/windows/jack_disconnect.cbp
+++ b/windows/jack_disconnect.cbp
@@ -37,7 +37,7 @@
 					<Add directory="..\common" />
 				</Compiler>
 				<Linker>
-					<Add directory="Release\bin" />
+					<Add directory="Debug\bin" />
 				</Linker>
 			</Target>
 			<Target title="Win32 Profiling">
diff --git a/windows/jack_netonedriver.cbp b/windows/jack_netonedriver.cbp
new file mode 100644
index 0000000..0aa9703
--- /dev/null
+++ b/windows/jack_netonedriver.cbp
@@ -0,0 +1,107 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="jack_netonedriver" />
+		<Option pch_mode="2" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Win32 Release">
+				<Option output="Release\bin\jack\jack_netone" prefix_auto="1" extension_auto="1" />
+				<Option object_output="Release\" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-O2" />
+					<Add option="-Wall" />
+					<Add option="-DBUILD_DLL" />
+					<Add option="-DSERVER_SIDE" />
+					<Add directory="..\windows" />
+					<Add directory="..\common\jack" />
+					<Add directory="..\common" />
+				</Compiler>
+				<Linker>
+					<Add directory="Release\bin" />
+				</Linker>
+			</Target>
+			<Target title="Win32 Debug">
+				<Option output="Debug\bin\jack\jack_netone" prefix_auto="1" extension_auto="1" />
+				<Option object_output="Debug\" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-Wall" />
+					<Add option="-g" />
+					<Add option="-DBUILD_DLL" />
+					<Add option="-DSERVER_SIDE" />
+					<Add directory="..\windows" />
+					<Add directory="..\common\jack" />
+					<Add directory="..\common" />
+				</Compiler>
+				<Linker>
+					<Add directory="Debug\bin" />
+				</Linker>
+			</Target>
+			<Target title="Win32 Profiling">
+				<Option output="Release\bin\jack\jack_netone" prefix_auto="1" extension_auto="1" />
+				<Option object_output="Release\" />
+				<Option type="3" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-O2" />
+					<Add option="-Wall" />
+					<Add option="-DBUILD_DLL" />
+					<Add option="-DJACK_MONITOR" />
+					<Add option="-DSERVER_SIDE" />
+					<Add directory="..\windows" />
+					<Add directory="..\common\jack" />
+					<Add directory="..\common" />
+				</Compiler>
+				<Linker>
+					<Add directory="Release\bin" />
+				</Linker>
+			</Target>
+		</Build>
+		<Compiler>
+			<Add option="-Wall" />
+		</Compiler>
+		<Linker>
+			<Add option="-enable-auto-import" />
+			<Add library="kernel32" />
+			<Add library="user32" />
+			<Add library="gdi32" />
+			<Add library="winspool" />
+			<Add library="comdlg32" />
+			<Add library="advapi32" />
+			<Add library="shell32" />
+			<Add library="ole32" />
+			<Add library="oleaut32" />
+			<Add library="uuid" />
+			<Add library="odbc32" />
+			<Add library="odbccp32" />
+			<Add library="libjackserver" />
+			<Add library="ws2_32" />
+		</Linker>
+		<Unit filename="..\common\JackNetOneDriver.cpp" />
+		<Unit filename="..\common\netjack.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="..\common\netjack_packet.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="jacknetonedriver.rc">
+			<Option compilerVar="WINDRES" />
+		</Unit>
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+			<lib_finder disable_auto="1" />
+			<AutoVersioning>
+				<Scheme minor_max="10" build_max="0" rev_max="0" rev_rand_max="10" build_times_to_increment_minor="100" />
+				<Settings autoincrement="1" date_declarations="1" do_auto_increment="0" ask_to_increment="0" language="C++" svn="0" svn_directory="" header_path="version.h" />
+				<Changes_Log show_changes_editor="0" app_title="released version %M.%m.%b of %p" changeslog_path="ChangesLog.txt" />
+			</AutoVersioning>
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
diff --git a/windows/jack_netsource.cbp b/windows/jack_netsource.cbp
new file mode 100644
index 0000000..ddfe02e
--- /dev/null
+++ b/windows/jack_netsource.cbp
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<CodeBlocks_project_file>
+	<FileVersion major="1" minor="6" />
+	<Project>
+		<Option title="jack_netsource" />
+		<Option pch_mode="2" />
+		<Option compiler="gcc" />
+		<Build>
+			<Target title="Win32 Release">
+				<Option output="Release\bin\jack_netsource" prefix_auto="1" extension_auto="1" />
+				<Option object_output="Release\" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-O2" />
+					<Add option="-Wall" />
+					<Add directory="..\example-clients" />
+					<Add directory="..\windows" />
+					<Add directory="..\common\jack" />
+					<Add directory="..\common" />
+				</Compiler>
+				<Linker>
+					<Add directory="Release\bin" />
+				</Linker>
+			</Target>
+			<Target title="Win32 Debug">
+				<Option output="Debug\bin\jack_netsource" prefix_auto="1" extension_auto="1" />
+				<Option object_output="Debug\" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-Wall" />
+					<Add option="-g" />
+					<Add directory="..\example-clients" />
+					<Add directory="..\windows" />
+					<Add directory="..\common\jack" />
+					<Add directory="..\common" />
+				</Compiler>
+				<Linker>
+					<Add directory="Debug\bin" />
+				</Linker>
+			</Target>
+			<Target title="Win32 Profiling">
+				<Option output="Release\bin\jack_netsource" prefix_auto="1" extension_auto="1" />
+				<Option object_output="Release\" />
+				<Option type="1" />
+				<Option compiler="gcc" />
+				<Compiler>
+					<Add option="-O2" />
+					<Add option="-Wall" />
+					<Add option="-DJACK_MONITOR" />
+					<Add directory="..\example-clients" />
+					<Add directory="..\windows" />
+					<Add directory="..\common\jack" />
+					<Add directory="..\common" />
+				</Compiler>
+				<Linker>
+					<Add directory="Release\bin" />
+				</Linker>
+			</Target>
+		</Build>
+		<Compiler>
+			<Add option="-Wall" />
+			<Add directory="..\example-clients" />
+			<Add directory="..\windows" />
+			<Add directory="..\common\jack" />
+			<Add directory="..\common" />
+		</Compiler>
+		<Linker>
+			<Add library="kernel32" />
+			<Add library="user32" />
+			<Add library="gdi32" />
+			<Add library="winspool" />
+			<Add library="comdlg32" />
+			<Add library="advapi32" />
+			<Add library="shell32" />
+			<Add library="ole32" />
+			<Add library="oleaut32" />
+			<Add library="uuid" />
+			<Add library="odbc32" />
+			<Add library="odbccp32" />
+			<Add library="libjack" />
+			<Add library="libsamplerate-0" />
+			<Add library="ws2_32" />
+			<Add directory="Release\bin" />
+		</Linker>
+		<Unit filename="..\common\netjack_packet.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="..\example-clients\netsource.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="getopt.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Unit filename="getopt1.c">
+			<Option compilerVar="CC" />
+		</Unit>
+		<Extensions>
+			<code_completion />
+			<envvars />
+			<debugger />
+			<AutoVersioning>
+				<Scheme minor_max="10" build_max="0" rev_max="0" rev_rand_max="10" build_times_to_increment_minor="100" />
+				<Settings autoincrement="1" date_declarations="1" do_auto_increment="0" ask_to_increment="0" language="C++" svn="0" svn_directory="" header_path="version.h" />
+				<Changes_Log show_changes_editor="0" app_title="released version %M.%m.%b of %p" changeslog_path="ChangesLog.txt" />
+			</AutoVersioning>
+		</Extensions>
+	</Project>
+</CodeBlocks_project_file>
diff --git a/windows/jackaudioadapter.rc b/windows/jackaudioadapter.rc
index 02d6694..25d4b15 100644
--- a/windows/jackaudioadapter.rc
+++ b/windows/jackaudioadapter.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp Audio Adapter for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "audioadapter\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "audioadapter.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "audioadapter\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/jackd.rc b/windows/jackd.rc
index 5f90941..db62e72 100644
--- a/windows/jackd.rc
+++ b/windows/jackd.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_APP
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jack server for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "jackd\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "jackd.exe\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "jackd\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/jackd.workspace b/windows/jackd.workspace
index 5db2880..2e5823e 100644
--- a/windows/jackd.workspace
+++ b/windows/jackd.workspace
@@ -11,6 +11,9 @@
 		<Project filename="jack_netdriver.cbp">
 			<Depends filename="libjackserver.cbp" />
 		</Project>
+		<Project filename="jack_netonedriver.cbp">
+			<Depends filename="libjackserver.cbp" />
+		</Project>
 		<Project filename="jack_dummy.cbp">
 			<Depends filename="libjackserver.cbp" />
 		</Project>
@@ -33,6 +36,10 @@
 		<Project filename="jack_lsp.cbp">
 			<Depends filename="libjack.cbp" />
 		</Project>
+		<Project filename="jack_netsource.cbp" active="1">
+			<Depends filename="libjack.cbp" />
+			<Depends filename="jack_netonedriver.cbp" />
+		</Project>
 		<Project filename="jack_metro.cbp">
 			<Depends filename="libjack.cbp" />
 		</Project>
@@ -47,6 +54,6 @@
 			<Depends filename="libjack.cbp" />
 		</Project>
 		<Project filename="jack_winmme.cbp" />
-		<Project filename="jack_loopback.cbp" active="1" />
+		<Project filename="jack_loopback.cbp" />
 	</Workspace>
 </CodeBlocks_workspace_file>
diff --git a/windows/jacknetadapter.rc b/windows/jacknetadapter.rc
index 62a7a3c..7488ea9 100644
--- a/windows/jacknetadapter.rc
+++ b/windows/jacknetadapter.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp Net Adapter for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "netadapter\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "netadapter.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "netadapter\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/jacknetdriver.rc b/windows/jacknetdriver.rc
index 8a7a180..a98f2fc 100644
--- a/windows/jacknetdriver.rc
+++ b/windows/jacknetdriver.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp Net Driver for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "jack_netdriver\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "jack_netdriver.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "jack_netdriver\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/jacknetmanager.rc b/windows/jacknetmanager.rc
index ffc1dde..c440861 100644
--- a/windows/jacknetmanager.rc
+++ b/windows/jacknetmanager.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp Net Manager for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "netmanager\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "netmanager.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "netmanager\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/jacknetonedriver.rc b/windows/jacknetonedriver.rc
new file mode 100644
index 0000000..9c184d3
--- /dev/null
+++ b/windows/jacknetonedriver.rc
@@ -0,0 +1,41 @@
+// Generated by ResEdit 1.4.3
+// Copyright (C) 2006-2008
+// http://www.resedit.net
+
+#include "resource.h"
+#include "afxres.h"
+
+
+//
+// Version Information resources
+//
+LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
+1 VERSIONINFO
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
+    FILEOS          VOS_UNKNOWN
+    FILETYPE        VFT_DLL
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040c04b0"
+        BEGIN
+            VALUE "Comments", "\0"
+            VALUE "CompanyName", "Grame\0"
+            VALUE "FileDescription", "Jackmp NetOne Driver for Windows\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
+            VALUE "InternalName", "jack_netonedriver\0"
+            VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
+            VALUE "LegalTrademarks", "\0"
+            VALUE "OriginalFilename", "jack_netonedriver.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "jack_netonedriver\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 1036, 1200
+    END
+END
diff --git a/windows/jackportaudio.rc b/windows/jackportaudio.rc
index 7e8429a..2c4e66d 100644
--- a/windows/jackportaudio.rc
+++ b/windows/jackportaudio.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp PortAudio Driver for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "jack_portaudio\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "jack_portaudio.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "jack_portaudio\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/jackwinmme.rc b/windows/jackwinmme.rc
index 5a38e82..6d8e19f 100644
--- a/windows/jackwinmme.rc
+++ b/windows/jackwinmme.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp WinMMEo Driver for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "jack_portaudio\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "jack_winmme.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "jack_winmme\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/libjack.rc b/windows/libjack.rc
index b4e7936..7beda3d 100644
--- a/windows/libjack.rc
+++ b/windows/libjack.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jack client library for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "libjack\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "libjack.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "libjack\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/libjackserver.cbp b/windows/libjackserver.cbp
index 8a82c34..b0b76f1 100644
--- a/windows/libjackserver.cbp
+++ b/windows/libjackserver.cbp
@@ -156,6 +156,8 @@
 		<Unit filename="..\common\JackTools.cpp" />
 		<Unit filename="..\common\JackTransportEngine.cpp" />
 		<Unit filename="..\common\JackWaitThreadedDriver.cpp" />
+		<Unit filename="..\common\JackPhysicalMidiInput.cpp" />
+		<Unit filename="..\common\JackPhysicalMidiOutput.cpp" />
 		<Unit filename="..\common\ringbuffer.c">
 			<Option compilerVar="CC" />
 		</Unit>
diff --git a/windows/libjackserver.rc b/windows/libjackserver.rc
index dc0bbb6..b62a275 100644
--- a/windows/libjackserver.rc
+++ b/windows/libjackserver.rc
@@ -11,8 +11,8 @@
 //
 LANGUAGE LANG_FRENCH, SUBLANG_DEFAULT
 1 VERSIONINFO
-    FILEVERSION     1,9,4,0
-    PRODUCTVERSION  1,9,4,0
+    FILEVERSION     1,9,5,0
+    PRODUCTVERSION  1,9,5,0
     FILEOS          VOS_UNKNOWN
     FILETYPE        VFT_DLL
 BEGIN
@@ -23,14 +23,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jack server library for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "libjackserver\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "libjackserver.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "libjackserver\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/resource.rc b/windows/resource.rc
index 51ba499..e5d5f15 100644
--- a/windows/resource.rc
+++ b/windows/resource.rc
@@ -14,8 +14,8 @@ LANGUAGE LANG_FRENCH, SUBLANG_FRENCH
 
 #ifndef _MAC
 VS_VERSION_INFO VERSIONINFO
- FILEVERSION 1,9,4,0
- PRODUCTVERSION 1,9,4,0
+ FILEVERSION 1,9,5,0
+ PRODUCTVERSION 1,9,5,0
  FILEFLAGSMASK 0x3fL
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -33,14 +33,14 @@ BEGIN
             VALUE "Comments", "\0"
             VALUE "CompanyName", "Grame\0"
             VALUE "FileDescription", "Jackmp for Windows\0"
-            VALUE "FileVersion", "1, 9, 4, 0\0"
+            VALUE "FileVersion", "1, 9, 5, 0\0"
             VALUE "InternalName", "libjackmp\0"
             VALUE "LegalCopyright", "Copyright Grame  2006-2009\0"
             VALUE "LegalTrademarks", "\0"
             VALUE "OriginalFilename", "libjackmp.dll\0"
             VALUE "PrivateBuild", "\0"
             VALUE "ProductName", "libjackmp\0"
-            VALUE "ProductVersion", "1, 9, 4, 0\0"
+            VALUE "ProductVersion", "1, 9, 5, 0\0"
             VALUE "SpecialBuild", "\0"
         END
     END
diff --git a/windows/winmme/JackWinMMEDriver.cpp b/windows/winmme/JackWinMMEDriver.cpp
index 65a7de6..b76a829 100644
--- a/windows/winmme/JackWinMMEDriver.cpp
+++ b/windows/winmme/JackWinMMEDriver.cpp
@@ -289,7 +289,6 @@ int JackWinMMEDriver::Attach()
     jack_port_id_t port_index;
     char name[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
     char alias[JACK_CLIENT_NAME_SIZE + JACK_PORT_NAME_SIZE];
-    unsigned long port_flags = JackPortIsOutput | JackPortIsPhysical | JackPortIsTerminal;
     MMRESULT res;
     int i;
 
@@ -305,7 +304,7 @@ int JackWinMMEDriver::Attach()
 		}
         snprintf(name, sizeof(name) - 1, "%s:capture_%d", fClientControl.fName, i + 1);
 
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, CaptureDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
@@ -315,8 +314,6 @@ int JackWinMMEDriver::Attach()
         jack_log("JackMidiDriver::Attach fCapturePortList[i] port_index = %ld", port_index);
     }
 
-    port_flags = JackPortIsInput | JackPortIsPhysical | JackPortIsTerminal;
-
     for (i = 0; i < fPlaybackChannels; i++) {
         MIDIOUTCAPS caps;
 		res = midiOutGetDevCaps(fMidiSource[i].fIndex, &caps, sizeof(caps));
@@ -327,7 +324,7 @@ int JackWinMMEDriver::Attach()
 		}
         snprintf(name, sizeof(name) - 1, "%s:playback_%d", fClientControl.fName, i + 1);
 
-        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, (JackPortFlags)port_flags, fEngineControl->fBufferSize)) == NO_PORT) {
+        if ((port_index = fGraphManager->AllocatePort(fClientControl.fRefNum, name, JACK_DEFAULT_MIDI_TYPE, PlaybackDriverFlags, fEngineControl->fBufferSize)) == NO_PORT) {
             jack_error("driver: cannot register port for %s", name);
             return -1;
         }
diff --git a/wscript b/wscript
index a9128cc..3346939 100644
--- a/wscript
+++ b/wscript
@@ -68,8 +68,8 @@ def set_options(opt):
     opt.add_option('--profile', action='store_true', default=False, help='Build with engine profiling')
     opt.add_option('--mixed', action='store_true', default=False, help='Build with 32/64 bits mixed mode')
     opt.add_option('--clients', default=64, type="int", dest="clients", help='Maximum number of JACK clients')
-    opt.add_option('--ports', default=2048, type="int", dest="ports", help='Maximum number of ports')
-    opt.add_option('--ports-per-application', default=512, type="int", dest="application_ports", help='Maximum number of ports per application')
+    opt.add_option('--ports-per-application', default=768, type="int", dest="application_ports", help='Maximum number of ports per application')
+    opt.add_option('--debug', action='store_true', default=False, dest='debug', help="Build debuggable binaries")
     opt.sub_options('dbus')
 
 def configure(conf):
@@ -112,6 +112,8 @@ def configure(conf):
         conf.sub_config('linux')
     if Options.options.dbus:
         conf.sub_config('dbus')
+        if conf.env['BUILD_JACKDBUS'] != True:
+            conf.fatal('jackdbus was explicitly requested but cannot be built')
     conf.sub_config('example-clients')
 
     if conf.check_cfg(package='celt', atleast_version='0.7.0', args='--cflags --libs'):
@@ -136,8 +138,8 @@ def configure(conf):
     conf.env['BUILD_DOXYGEN_DOCS'] = Options.options.doxygen
     conf.env['BUILD_WITH_PROFILE'] = Options.options.profile
     conf.env['BUILD_WITH_32_64'] = Options.options.mixed
-    conf.env['BUILD_JACKDBUS'] = Options.options.dbus
     conf.env['BUILD_CLASSIC'] = Options.options.classic
+    conf.env['BUILD_DEBUG'] = Options.options.debug
 
     if conf.env['BUILD_JACKDBUS']:
         conf.env['BUILD_JACKD'] = conf.env['BUILD_CLASSIC']
@@ -149,8 +151,12 @@ def configure(conf):
     else:
         conf.env['LIBDIR'] = conf.env['PREFIX'] + '/lib'
 
+    if conf.env['BUILD_DEBUG']:
+        conf.env.append_unique('CXXFLAGS', '-g')
+        conf.env.append_unique('CCFLAGS', '-g')
+        conf.env.append_unique('LINKFLAGS', '-g')
+
     conf.define('CLIENT_NUM', Options.options.clients)
-    conf.define('PORT_NUM', Options.options.ports)
     conf.define('PORT_NUM_FOR_CLIENT', Options.options.application_ports)
 
     conf.define('ADDON_DIR', os.path.normpath(os.path.join(conf.env['LIBDIR'], 'jack')))
@@ -184,12 +190,12 @@ def configure(conf):
     print version_msg
 
     print "Build with a maximum of %d JACK clients" % conf.env['CLIENT_NUM']
-    print "Build with a maximum of %d ports" % conf.env['PORT_NUM']
     print "Build with a maximum of %d ports per application" % conf.env['PORT_NUM_FOR_CLIENT']
  
     display_msg("Install prefix", conf.env['PREFIX'], 'CYAN')
     display_msg("Library directory", conf.env['LIBDIR'], 'CYAN')
     display_msg("Drivers directory", conf.env['ADDON_DIR'], 'CYAN')
+    display_feature('Build debuggable binaries', conf.env['BUILD_DEBUG'])
     display_feature('Build doxygen documentation', conf.env['BUILD_DOXYGEN_DOCS'])
     display_feature('Build with engine profiling', conf.env['BUILD_WITH_PROFILE'])
     display_feature('Build with 32/64 bits mixed mode', conf.env['BUILD_WITH_32_64'])
@@ -198,8 +204,9 @@ def configure(conf):
     display_feature('Build D-Bus JACK (jackdbus)', conf.env['BUILD_JACKDBUS'])
 
     if conf.env['BUILD_JACKDBUS'] and conf.env['BUILD_JACKD']:
-        print Logs.colors.RED + 'WARNING !! mixing both jackd and jackdbus may cause issues!' + Logs.colors.NORMAL
-    
+        print Logs.colors.RED + 'WARNING !! mixing both jackd and jackdbus may cause issues:' + Logs.colors.NORMAL
+        print Logs.colors.RED + 'WARNING !! jackdbus does not use .jackdrc nor qjackctl settings' + Logs.colors.NORMAL
+
     if conf.env['IS_LINUX']:
         display_feature('Build with ALSA support', conf.env['BUILD_DRIVER_ALSA'] == True)
         display_feature('Build with FireWire (FreeBob) support', conf.env['BUILD_DRIVER_FREEBOB'] == True)
